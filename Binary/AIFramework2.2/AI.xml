<?xml version="1.0"?>
<doc>
    <assembly>
        <name>AI</name>
    </assembly>
    <members>
        <member name="T:AI.AISettings">
            <summary>
            Глобальные настройки
            </summary>
        </member>
        <member name="P:AI.AISettings.GlobalEps">
            <summary>
            Глобальный эпсилон(смещение) (по-умолчанию = 1e-80)
            </summary>
        </member>
        <member name="P:AI.AISettings.FFTCore">
            <summary>
            Базовая функция БПФ
            </summary>
        </member>
        <member name="M:AI.AISettings.GetProvider">
            <summary>
            Получить провайдер для конвертирования чисел в строку и наоборот с точкой в кач. разделителя
            </summary>
        </member>
        <member name="M:AI.AISettings.GetProviderComa">
            <summary>
             Получить провайдер для конвертирования чисел в строку и наоборот с запятой в кач. разделителя
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.ByteConverter">
            <summary>
            Статический класс, предоставляющий методы для преобразования между байтами PCM и данными float[].
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.ByteConverter.ToFloats8Bit(System.Byte[],System.Single[][],System.Boolean)">
            <summary>
            Конвертирование из Pcm_8bit в float[]
            </summary>
            <param name="bytes"></param>
            <param name="floats"></param>
            <param name="normalize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.ByteConverter.FromFloats8Bit(System.Single[][],System.Byte[],System.Boolean)">
            <summary>
            Конвертирование из float[] в Pcm_8bit
            </summary>
            <param name="floats"></param>
            <param name="bytes"></param>
            <param name="normalized"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.ByteConverter.ToFloats16Bit(System.Byte[],System.Single[][],System.Boolean,System.Boolean)">
            <summary>
            Конвертирование из Pcm_16bit в float[]
            </summary>
            <param name="bytes"></param>
            <param name="floats"></param>
            <param name="normalize"></param>
            <param name="bigEndian"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.ByteConverter.FromFloats16Bit(System.Single[][],System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            Конвертирование из float[] в Pcm_16bit
            </summary>
            <param name="floats"></param>
            <param name="bytes"></param>
            <param name="normalized"></param>
            <param name="bigEndian"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.Channels">
            <summary>
            Наиболее используемые каналы: левый и правый.
            Также мы добавляем особый случай: чередующиеся каналы
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.Channels.Left">
            <summary>
            Левый канал (=0)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.Channels.Right">
            <summary>
            Правый канал (=1)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.Channels.Sum">
            <summary>
            Моно как сумма всех каналов
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.Channels.Average">
            <summary>
            Моно как среднее всех каналов
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.Channels.Interleave">
            <summary>
            Перемешаный канал
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioContainer">
            <summary>
            Интерфейс для контейнеров данных аудиофайлов
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioContainer.Signals">
            <summary>
            Дискретные сигналы (каналы)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioContainer.Item(AI.BackEnds.DSP.NWaves.Audio.Channels)">
            <summary>
            Индексация по типу канала
            </summary>
            <param name="channel">Типы каналов (правый, левый или чередующийся)</param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioPlayer">
            <summary>
            Интерфейс для воспроизведения звука
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioPlayer.Volume">
            <summary>
            Громкость звука в диапазоне [0.0f, 1.0f]
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioPlayer.PlayAsync(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32,System.Int16)">
            <summary>
            Асинхронное воспроизведение звука
            </summary>
            <param name="signal">Сигнал для проигрывания</param>
            <param name="startPos">Начальная позиция для воспроизведения</param>
            <param name="endPos">Конечная позиция для проигрывания (-1 — проигрывать весь файл)</param>
            <param name="bitDepth">Number of bits per one sample</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioPlayer.PlayAsync(System.String,System.Int32,System.Int32)">
            <summary>
            Воспроизведение сигналов, содержащихся в файле WAV (или другом источнике), асинхронно
            </summary>
            <param name="source">WAV-файл (или другой источник) для воспроизведения</param>
            <param name="startPos">Начальная позиция для воспроизведения</param>
            <param name="endPos">Конечная позиция для проигрывания (-1 — проигрывать весь файл)</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioPlayer.Pause">
            <summary>
            Пауза
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioPlayer.Resume">
            <summary>
            Возобновление воспроизведения аудио
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioPlayer.Stop">
            <summary>
            Остановка воспроизведения
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioRecorder">
            <summary>
            Интерфейс для записи звука
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioRecorder.StartRecording(System.Int32,System.Int16,System.Int16)">
            <summary>
            Начать запись звука с определенными настройками
            </summary>
            <param name="samplingRate">Частота дискретизации</param>
            <param name="channelCount">Число каналов (1-моно, 2-стерео)</param>
            <param name="bitsPerSample">Количество бит на отсчет (8, 16, 24 or 32)</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Interfaces.IAudioRecorder.StopRecording(System.String)">
            <summary>
            Остановка записи
            </summary>
            <param name="destination">Путь для сохранения</param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.Mci.Mci">
            <summary>
            Статический класс, содержащий функции MCI, импортированные из winmm.dll.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Mci.Mci.SendString(System.String,System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Посылает команду
            </summary>
            <param name="command">Команда</param>
            <param name="returnValue"></param>
            <param name="returnLength"></param>
            <param name="winHandle"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Mci.Mci.GetErrorString(System.Int32,System.Text.StringBuilder,System.UInt32)">
            <summary>
            Получает ошибку
            </summary>
            <param name="dwError"></param>
            <param name="lpstrBuffer"></param>
            <param name="wLength"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Mci.Mci.Execute(System.String)">
            <summary>
            Выполняет команду
            </summary>
            <param name="command">Команда</param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer">
            <summary>
            Аудиоплеер, основанный на MCI. 
            MciAudioPlayer работает только в Windows, поскольку использует winmm.dll и команды MCI. 
            MciAudioPlayer позволяет MCI выполнять всю тяжелую работу по воспроизведению звука. 
            Он запускает команду MCI и просто ожидает некоторое время, соответствующее длительности заданного сегмента. 
            Если воспроизведение было приостановлено, плеер запоминает, сколько миллисекунд он "простаивал", а затем добавляет это время к общему времени ожидания.
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer._alias">
            <summary>
            Скрытый псевдоним для устройства MCI waveaudio
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer._pauseDuration">
            <summary>
            Длительность паузы в миллисекундах
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer._pauseTime">
            <summary>
            Точное время, когда воспроизведение было приостановлено
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer._isPaused">
            <summary>
            Флаг, указывающий, приостановлено ли в данный момент воспроизведение аудио.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer.Volume">
            <summary>
            Громкость (измеряется в процентах из диапазона [0.0f, 1.0f])
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer.PlayAsync(System.String,System.Int32,System.Int32)">
            <summary>
            Асинхронное воспроизведение аудио из WAV-файла
            </summary>
            <param name="source">WAV-файл</param>
            <param name="startPos">Начальная позиция для воспроизведения</param>
            <param name="endPos">Конечная позиция для проигрывания (-1 — проигрывать весь файл)</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer.PlayAsync(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32,System.Int16)">
             <summary>
            К сожалению, MCI не предоставляет средств для воспроизведения аудио из буферов в памяти.Более того, поскольку библиотека NWaves является переносимой, 
             нет даже простого способа записать буфер во временный файл и воспроизвести его здесь (это может быть обходным решением проблемы).
             </summary>
             <param name="signal"></param>
             <param name="startPos"></param>
             <param name="endPos"></param>
             <param name="bitDepth"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer.Pause">
            <summary>
            Пауза
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer.Resume">
            <summary>
            Возобновление воспроизведения аудио
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioPlayer.Stop">
            <summary>
            Остановить проигрывание и закрыть MCI девайс
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioRecorder">
            <summary>
            Audio recorder based on MCI.
            
            MciAudioRecorder works only with Windows, since it uses winmm.dll and MCI commands.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioRecorder.StartRecording(System.Int32,System.Int16,System.Int16)">
            <summary>
            Начать запись звука с определенными настройками
            </summary>
            <param name="samplingRate">Частота дискретизации</param>
            <param name="channelCount">Число каналов (1-моно, 2-стерео)</param>
            <param name="bitsPerSample">Количество бит на отсчет (8, 16, 24 or 32)</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.Mci.MciAudioRecorder.StopRecording(System.String)">
            <summary>
            Остановка запись и сохранение в wave
            </summary>
            <param name="destination">Выходной WAV-файл, содержащий записанный звук</param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.WaveFile">
            <summary>
            Wav файл
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Audio.WaveFile.Signals">
            <summary>
            Сигналы со всех каналов.
             
                Signals.Count = 1 (Моно)
            или
                Signals.Count = 2 (Стерео)
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Audio.WaveFile.WaveFmt">
            <summary>
            Структура Wav заголовка
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.WaveFile.SupportedBitDepths">
            <summary>
            Поддерживаемые разрядности квантования
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.WaveFile.#ctor(System.IO.Stream,System.Boolean)">
             <summary>
             Этот конструктор загружает сигналы из волнового файла.
            
             Поскольку NWaves является библиотекой .NET Standard 2.0, универсального класса FileStream не существует.
             </summary>
             <param name="waveStream">Поток входа</param>
             <param name="normalized">Нормализовать ли данные</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.WaveFile.#ctor(System.Collections.Generic.IList{AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal},System.Int16)">
            <summary>
            Этот конструктор загружает сигналы в контейнер.
            </summary>
            <param name="signals">Сигналы для загрузки в контейнер</param>
            <param name="bitsPerSample">Биты квантования</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.WaveFile.#ctor(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int16)">
            <summary>
            Этот конструктор загружает сигналы в контейнер.
            </summary>
            <param name="signal">Сигналы для загрузки в контейнер</param>
            <param name="bitsPerSample">Биты квантования</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Audio.WaveFile.SaveTo(System.IO.Stream,System.Boolean)">
            <summary>
            Сохранение файла в поток
            </summary>
            <param name="waveStream">Поток для сохранения</param>
            <param name="normalized">Номализовать ли данные</param>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Audio.WaveFile.Item(AI.BackEnds.DSP.NWaves.Audio.Channels)">
            <summary>
            Легенда индексов:
            
                waveFile[Channels.Left] -> waveFile.Signals[0]
                waveFile[Channels.Right] -> waveFile.Signals[1]
                waveFile[Channels.Average] -> returns channel-averaged (Новый) signal
                waveFile[Channels.Interleave] -> Возвращает чередующийся (Новый) сигнал
            
            </summary>
            <param name="channel">Перечисление каналов</param>
            <returns>Сигнал из канала или чередующийся сигнал</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Audio.WaveFormat">
            <summary>
            Стандартный заголовок WAVE
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.WaveFormat.AudioFormat">
            <summary>
            PCM = 1
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.WaveFormat.ChannelCount">
            <summary>
            1 - моно, 2 - стерео звук
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.WaveFormat.SamplingRate">
            <summary>
            8000 Hz, 11025 Hz, 16000 Hz, 22050 Hz, 44100 Hz
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.WaveFormat.ByteRate">
            <summary>
            SamplingRate * NumChannels * BitsPerSample / 8
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.WaveFormat.Align">
            <summary>
            ChannelCount * BitsPerSample / 8
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Audio.WaveFormat.BitsPerSample">
            <summary>
            8, 16, 24, 32 (Разрядность квантования)
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Adaptive.AdaptiveFilter">
            <summary>
            Базовый абстрактный класс адаптивных фильтров
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.AdaptiveFilter.#ctor(System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.AdaptiveFilter.Init(System.Single[])">
            <summary>
            Начальные веса
            </summary>
            <param name="weights"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.AdaptiveFilter.Process(System.Single,System.Single)">
            <summary>
            Обработка одного образца входного сигнала и одного образца полезного сигнала
            </summary>
            <param name="input"></param>
            <param name="desired"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmfFilter">
            <summary>
            Адаптивный фильтр (Least-Mean-Fourth алгоритм)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmfFilter._mu">
            <summary>
            Mu
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmfFilter._leakage">
            <summary>
            Утечка
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmfFilter.#ctor(System.Int32,System.Single,System.Single)">
            <summary>
            Конструктор
            </summary>
            <param name="order"></param>
            <param name="mu"></param>
            <param name="leakage"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmfFilter.Process(System.Single,System.Single)">
            <summary>
            Входные данные процесса и целевые данные
            </summary>
            <param name="input"></param>
            <param name="desired"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmsFilter">
            <summary>
            Адаптивный фильтр (Least-Mean-Squares алгоритм)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmsFilter._mu">
            <summary>
            Mu
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmsFilter._leakage">
            <summary>
            Утечка
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmsFilter.#ctor(System.Int32,System.Single,System.Single)">
            <summary>
            Конструктор
            </summary>
            <param name="order"></param>
            <param name="mu"></param>
            <param name="leakage"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.LmsFilter.Process(System.Single,System.Single)">
            <summary>
            Входные данные процесса и целевые данные
            </summary>
            <param name="input"></param>
            <param name="desired"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmfFilter">
            <summary>
            Адаптивный фильтр (Нормализованный Least-Mean-Fourth алгоритм + смещение)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmfFilter._mu">
            <summary>
            Mu
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmfFilter._eps">
            <summary>
            Смещение
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmfFilter._leakage">
            <summary>
            Утечка
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmfFilter.#ctor(System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Конструктор
            </summary>
            <param name="order"></param>
            <param name="mu"></param>
            <param name="eps"></param>
            <param name="leakage"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmfFilter.Process(System.Single,System.Single)">
            <summary>
            Входные данные процесса и целевые данные
            </summary>
            <param name="input"></param>
            <param name="desired"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmsFilter">
            <summary>
            Адаптивный фильтр (нормализованный Least-Mean-Squares алгоритм + смещение)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmsFilter._mu">
            <summary>
            Mu
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmsFilter._eps">
            <summary>
            Смещение
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmsFilter._leakage">
            <summary>
            Утечка
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmsFilter.#ctor(System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Конструктор
            </summary>
            <param name="order"></param>
            <param name="mu"></param>
            <param name="eps"></param>
            <param name="leakage"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.NlmsFilter.Process(System.Single,System.Single)">
            <summary>
            Входные данные процесса и целевые данные
            </summary>
            <param name="input"></param>
            <param name="desired"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Adaptive.RlsFilter">
            <summary>
            Адаптивный фильтр (Recursive-Least-Squares алгоритм)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.RlsFilter._lambda">
            <summary>
            Lambda
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.RlsFilter._p">
            <summary>
            Обратная корреляционная матрица
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.RlsFilter._gains">
            <summary>
            Матрица коэффициентов усиления
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.RlsFilter._dp">
            <summary>
            Временные матрицы для расчетов
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.RlsFilter._tmp">
            <summary>
            Временные матрицы для расчетов
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.RlsFilter.#ctor(System.Int32,System.Single,System.Single)">
            <summary>
            Конструктор
            </summary>
            <param name="order"></param>
            <param name="lambda"></param>
            <param name="initCoeff"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.RlsFilter.Process(System.Single,System.Single)">
            <summary>
            Входные данные процесса и целевые данные
            </summary>
            <param name="input"></param>
            <param name="desired"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Adaptive.SignLmsFilter">
            <summary>
            Адаптивный фильтр (Sign Least-Mean-Squares алгоритм)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.SignLmsFilter._mu">
            <summary>
            Mu
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.SignLmsFilter._leakage">
            <summary>
            Утечка
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.SignLmsFilter.#ctor(System.Int32,System.Single,System.Single)">
            <summary>
            Конструктор
            </summary>
            <param name="order"></param>
            <param name="mu"></param>
            <param name="leakage"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.SignLmsFilter.Process(System.Single,System.Single)">
            <summary>
            Входные данные процесса и целевые данные
            </summary>
            <param name="input"></param>
            <param name="desired"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Adaptive.VariableStepLmsFilter">
            <summary>
            Адаптивный фильтр (Least-Mean-Squares with variable steps)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.VariableStepLmsFilter._mu">
            <summary>
            Mu
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Adaptive.VariableStepLmsFilter._leakage">
            <summary>
            Утечка
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.VariableStepLmsFilter.#ctor(System.Int32,System.Single[],System.Single)">
            <summary>
            Конструктор
            </summary>
            <param name="order"></param>
            <param name="mu"></param>
            <param name="leakage"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Adaptive.VariableStepLmsFilter.Process(System.Single,System.Single)">
            <summary>
            Входные данные процесса и целевые данные
            </summary>
            <param name="input"></param>
            <param name="desired"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64">
            <summary>
            КИХ фильтр
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.Kernel">
            <summary>
            Ядро фильтра (импульсная характеристика)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64._b">
            <summary>
            
            Числитель передаточной функции нерекурсивного фильтра
            Этот массив создан из дублированного ядра фильтра:
            
              Ядро                _b
            [1 2 3 4 5] -> [1 2 3 4 5 1 2 3 4 5]
            
            Такое расположение памяти приводит к значительному ускорению онлайн-фильтраци
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64._kernelSize">
            <summary>
            Размер ядра
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64._tf">
            <summary>
            Передаточная функция (создается лениво или устанавливается специально, если нужно)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.Tf">
            <summary>
            Передаточная функция
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.KernelSizeForBlockConvolution">
            <summary>
            Если _kernelSize превышает это значение, код фильтрации всегда будет вызывать процедуру Overlap-Save.
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64._delayLine">
            <summary>
            Внутренний буфер для линии задержки
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64._delayLineOffset">
            <summary>
            Текущее смещение в линии задержки
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.#ctor(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Конструктор, прием 64-битного ядра фильтра
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.#ctor(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction)">
            <summary>
            Конструктор, принимающий передаточную функцию
            </summary>
            <param name="tf">Передаточная функция</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.ApplyTo(System.Double[],AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Применить фильтр ко всему сигналу (оффлайн)
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.Process(System.Double)">
            <summary>
            КИХ-фильтрация (отсчет за отсчетом)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.ProcessAllSamples(System.Double[])">
            <summary>
            Обрабатывает все отсчеты сигнала в цикле. Код Process() встроен в цикл для повышения производительности (особенно для небольших ядер).
            </summary>
            <param name="samples">Отсчеты сигнала</param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.ChangeKernel(System.Double[])">
            <summary>
            Изменить ядро фильтра
            </summary>
            <param name="kernel">Новое ядро</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64.Reset">
            <summary>
            Перезапуск фильтра
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base64.IFilter64">
            <summary>
            Интерфейс для любого типа фильтра:
            фильтр может применяться к любому сигналу, преобразуя его в некоторый выходной сигнал.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IFilter64.ApplyTo(System.Double[],AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Фильтрация всего сигнала
            </summary>
            <param name="signal">Фильтруемый(исходный) сигнал</param>
            <param name="method">Общая стратегия фильтрации</param>
            <returns>Отфильтрованный сигнал</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64">
            <summary>
            64-х битный БИХ фильтр
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64._b">
            <summary>
            
            Числитель передаточной функции рекурсивного фильтра
            Этот массив создан из дублированного ядра фильтра:
            
             числитель                _b
            [1 2 3 4 5] -> [1 2 3 4 5 1 2 3 4 5]
            
            Такое расположение памяти приводит к значительному ускорению онлайн-фильтраци
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64._a">
            <summary>
            
            Знаменатель передаточной функции рекурсивного фильтра
            Этот массив создан из дублированного ядра фильтра:
            
             Знаменатель                _b
            [1 2 3 4 5] -> [1 2 3 4 5 1 2 3 4 5]
            
            Такое расположение памяти приводит к значительному ускорению онлайн-фильтраци
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64._numeratorSize">
            <summary>
            Количество коэффициентов числителя
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64._denominatorSize">
            <summary>
            Количество коэффициентов знаменателя (обратной связи)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64._tf">
            <summary>
            Передаточная функция (создается лениво или устанавливается специально, если нужно)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.Tf">
            <summary>
            Передаточная функция
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.DefaultImpulseResponseLength">
            <summary>
            Импульсная характеристика по умолчанию
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64._delayLineA">
            <summary>
            Буффер линии задержки коэф. А
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64._delayLineB">
            <summary>
            Буффер линии задержки коэф. B
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64._delayLineOffsetA">
            <summary>
            Смещение в линии задержки (А)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64._delayLineOffsetB">
            <summary>
            Смещение в линии задержки (B)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Параметризованный конструктор ( 32-битные коэффициенты)
            </summary>
            <param name="b">Коэф. в числителе передаточной функции</param>
            <param name="a">Коэф. в знаменателе передаточной функции</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.#ctor(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction)">
            <summary>
            Параметризованный конструктор (Передаточная функция).
            </summary>
            <param name="tf">Передаточная функция</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.ApplyTo(System.Double[],AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Применить фильтр ко всему сигналу (оффлайн)
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.Process(System.Double)">
            <summary>
            БИХ-фильтрация (отсчет за отсчетом)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.ChangeNumeratorCoeffs(System.Double[])">
            <summary>
            Изменить коэффициенты фильтра онлайн (числитель)
            </summary>
            <param name="b">Новые коэффициенты</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.ChangeDenominatorCoeffs(System.Double[])">
            <summary>
            Изменить коэффициенты фильтра онлайн (знаменатель / рекурсивная часть)
            </summary>
            <param name="a">Новые коэффициенты</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.Reset">
            <summary>
            Перезапуск фильтра
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IirFilter64.Normalize">
            <summary>
            Нормализует передаточную функцию (делит все коэффициенты на _a[0])
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base64.IOnlineFilter64">
            <summary>
            Интерфейс для всех объектов, поддерживающих онлайн-фильтрацию
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IOnlineFilter64.Process(System.Double)">
            <summary>
            Метод реализует онлайн фильтрацию (отсчет за отсчетом)
            </summary>
            <param name="input">Входной отсчет</param>
            <returns>Выходной отсчет</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.IOnlineFilter64.Reset">
            <summary>
            Сброс состояния
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64">
            <summary>
            64-х битный фильтр
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64._b">
            <summary>
            Числитель передаточной функции фильтра
            (Не рекусивная часть разностного фильтра)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64._a">
            <summary>
            Знаменатель передаточной функции фильтра 
            (Рекусивная часть разностного фильтра)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64._zi">
            <summary>
            Вектор состояний
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64.Zi">
            <summary>
            Вектор состояний линии задержки
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64._tf">
            <summary>
            Передаточная функция
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64.Tf">
            <summary>
            Передаточная функция
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Параметризованный конструктор (Массив 64х битных коэффициентов)
            </summary>
            <param name="b">Коэф. в числителе передаточной функции</param>
            <param name="a">Коэф. в знаменателе передаточной функции</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64.#ctor(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction)">
            <summary>
            Параметризованный конструктор (Передаточная функция).
            </summary>
            <param name="tf">Передаточная функция</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64.Init(System.Double[])">
            <summary>
            Инициализация фильтра
            </summary>
            <param name="zi"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64.ApplyTo(System.Double[],AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Применить фильтр ко всему сигналу (оффлайн)
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64.Process(System.Double)">
            <summary>
            Онлайн-фильтрация с начальными условиями
            </summary>
            <param name="input">Входной отсчет</param>
            <returns>Выходной отсчет</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64.ZeroPhase(System.Double[],System.Int32)">
            <summary>
            Нуль-фазовая фильтрация (аналог filtfilt() в MATLAB/sciPy)
            </summary>
            <param name="signal"></param>
            <param name="padLength"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base64.ZiFilter64.Reset">
            <summary>
            Перезапуск фильтра
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain">
            <summary>
            Сеть фильтров
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain._filters">
            <summary>
            Список фильтров в цепочке
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain.#ctor(System.Collections.Generic.IEnumerable{AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter})">
            <summary>
            Конструктор
            </summary>
            <param name="filters"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain.#ctor(System.Collections.Generic.IEnumerable{AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction})">
            <summary>
            Конструктор из набора передаточных функций (например, секций SOS).
            Этот конструктор создаст БИХ (!) фильтры.
            </summary>
            <param name="tfs"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain.Add(AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter)">
            <summary>
            Добавить фильтр в цепочку
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain.Insert(System.Int32,AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter)">
            <summary>
            Вставить фильтр в цепочку
            </summary>
            <param name="idx"></param>
            <param name="filter"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain.RemoveAt(System.Int32)">
            <summary>
            Удалить фильтр по индексу
            </summary>
            <param name="idx"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain.Process(System.Single)">
            <summary>
            Онлайн фильтрация
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain.Reset">
            <summary>
            Перезапуск всех фильтров
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterChain.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Фильтрация всего сигнала
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod">
            <summary>
            Общая стратегия фильтрации
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod.Auto">
            <summary>
            Стратегия фильтрации динамически определяется библиотекой NWaves.
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod.DifferenceEquation">
            <summary>
            Фильтрация во временной области на основе разностных уравнений
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod.OverlapAdd">
            <summary>
            Фильтрация в частотной области на основе алгоритма OLA
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod.OverlapSave">
            <summary>
            Фильтрация в частотной области на основе алгоритма OLS
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod.Custom">
            <summary>
            Кастомная фильтрация
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter">
            <summary>
            КИХ фильтр
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.Kernel">
            <summary>
            Ядро фильтра (импульсная характеристика)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter._b">
            <summary>
            
            Числитель передаточной функции нерекурсивного фильтра
            Этот массив создан из дублированного ядра фильтра:
            
              Ядро                _b
            [1 2 3 4 5] -> [1 2 3 4 5 1 2 3 4 5]
            
            Такое расположение памяти приводит к значительному ускорению онлайн-фильтраци
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter._kernelSize">
            <summary>
            Размер ядра
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter._tf">
            <summary>
            Передаточная функция
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.Tf">
            <summary>
            Передаточная функция КИХ-фильтра
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.KernelSizeForBlockConvolution">
            <summary>
            Если _kernelSize превышает это значение, код фильтрации всегда будет вызывать процедуру Overlap-Save.
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter._delayLine">
            <summary>
            Внутренний буфер для линии задержки
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter._delayLineOffset">
            <summary>
            Текущее смещение в линии задержки
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.#ctor(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Конструктор
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.#ctor(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Создание фильтра при помощи установки ядра.
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.#ctor(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction)">
            <summary>
            Конструктор, принимающий передаточную функцию
            </summary>
            <param name="tf">Передаточная функция</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Применить фильтр ко всему сигналу (оффлайн)
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.Process(System.Single)">
            <summary>
            КИХ-фильтрация (отсчет за отсчетом)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.ProcessAllSamples(System.Single[])">
            <summary>
            Обрабатывает все отсчеты сигнала в цикле. Код Process() встроен в цикл для повышения производительности (особенно для небольших ядер).
            </summary>
            <param name="samples">Отсчеты сигнала</param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.ApplyFilterDirectly(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Применить фильтр ко всему сигналу (оффлайн)
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.ChangeKernel(System.Single[])">
            <summary>
            Изменить ядро фильтра
            </summary>
            <param name="kernel">Новое ядро</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.Reset">
            <summary>
            Перезапуск фильтра
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.op_Multiply(AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter,AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter)">
            <summary>
            Sequential combination of two FIR filters (also an FIR filter)
            </summary>
            <param name="filter1"></param>
            <param name="filter2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.op_Multiply(AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter,AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter)">
            <summary>
            Sequential combination of an FIR and БИХ фильтр
            </summary>
            <param name="filter1"></param>
            <param name="filter2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.op_Addition(AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter,AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter)">
            <summary>
            Parallel combination of two FIR filters
            </summary>
            <param name="filter1"></param>
            <param name="filter2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter.op_Addition(AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter,AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter)">
            <summary>
            Parallel combination of an FIR and БИХ фильтр
            </summary>
            <param name="filter1"></param>
            <param name="filter2"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.IFilter">
            <summary>
            Интерфейс для любого типа фильтра:
            фильтр может применяться к любому сигналу, преобразуя его в некоторый выходной сигнал.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Метод реализует алгоритм фильтрации всего сигнала
            </summary>
            <param name="signal">Фильтруемый(исходный) сигнал</param>
            <param name="method">Общая стратегия фильтрации</param>
            <returns>Отфильтрованный сигнал</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.FilterExtensions">
            <summary>
            Методы расширения для фильтров
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterExtensions.Process(AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Метод реализует онлайн-фильтрацию для дискретного сигнала
            </summary>
            <param name="filter">Фильтр</param>
            <param name="input">Входной сигнал</param>
            <returns>Отфильтрованный сигнал</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterExtensions.Process(AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter,System.Single[],System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Метод реализует онлайн-фильтрацию (frame-by-frame)
            </summary>
            <param name="filter">Фильтр</param>
            <param name="input">Блок(фрейм) входного сигнала</param>
            <param name="output">Блок(фрейм) отфильтрованного сигнала</param>
            <param name="count">Количество образцов для фильтрации</param>
            <param name="inputPos">Введите начальную позицию</param>
            <param name="outputPos">Выходное исходное положение</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.FilterExtensions.ProcessChunks(AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32)">
            <summary>
            Реализация фильтра во временной области (Фильтрация блоками)
            
            </summary>
            <param name="signal"></param>
            <param name="frameSize"></param>
            <param name="filter"></param>
            <returns></returns>        
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter">
            <summary>
            32-х битный БИХ фильтр
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter._b">
            <summary>
            
            Числитель передаточной функции рекурсивного фильтра
            Этот массив создан из дублированного ядра фильтра:
            
             числитель                _b
            [1 2 3 4 5] -> [1 2 3 4 5 1 2 3 4 5]
            
            Такое расположение памяти приводит к значительному ускорению онлайн-фильтраци
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter._a">
            <summary>
            
            Знаменатель передаточной функции рекурсивного фильтра
            Этот массив создан из дублированного ядра фильтра:
            
             Знаменатель                _b
            [1 2 3 4 5] -> [1 2 3 4 5 1 2 3 4 5]
            
            Такое расположение памяти приводит к значительному ускорению онлайн-фильтраци
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter._numeratorSize">
            <summary>
            Количество коэффициентов числителя
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter._denominatorSize">
            <summary>
            Количество коэффициентов знаменателя (обратной связи)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter._tf">
            <summary>
            Передаточная функция (создается лениво или устанавливается специально, если нужно)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.Tf">
            <summary>
            Передаточная функция БИХ фильтра
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.DefaultImpulseResponseLength">
            <summary>
            Импульсная характеристика по умолчанию
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter._delayLineA">
            <summary>
            Внутренние буферы for Линия задержкиs
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter._delayLineB">
            <summary>
            Линия задержки для коэфициентов B
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter._delayLineOffsetA">
            <summary>
            Смещение в линии задержки (А)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter._delayLineOffsetB">
            <summary>
            Смещение в линии задержки (B)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.#ctor(System.Collections.Generic.IEnumerable{System.Single},System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Параметризованный конструктор ( 32-битные коэффициенты)
            </summary>
            <param name="b">Коэф. в числителе передаточной функции</param>
            <param name="a">Коэф. в знаменателе передаточной функции</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Параметризованный конструктор ( 32-битные коэффициенты)
            </summary>
            <param name="b">Коэф. в числителе передаточной функции</param>
            <param name="a">Коэф. в знамнателе передаточной функции</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.#ctor(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction)">
            <summary>
            Параметризованный конструктор (Передаточная функция).
            </summary>
            <param name="tf">Передаточная функция</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Применить фильтр ко всему сигналу (оффлайн)
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.Process(System.Single)">
            <summary>
            БИХ-фильтрация (отсчет за отсчетом)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.ApplyFilterDirectly(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Применить фильтр ко всему сигналу (оффлайн)
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.ChangeNumeratorCoeffs(System.Single[])">
            <summary>
            Изменить коэффициенты фильтра онлайн (числитель)
            </summary>
            <param name="b">Новые коэффициенты</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.ChangeDenominatorCoeffs(System.Single[])">
            <summary>
            Изменить коэффициенты фильтра онлайн (знаменатель / рекурсивная часть)
            </summary>
            <param name="a">Новые коэффициенты</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.Reset">
            <summary>
            Перезапуск фильтра
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.Normalize">
            <summary>
            Нормализует передаточную функцию (делит все коэффициенты на _a[0])
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.op_Multiply(AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter,AI.BackEnds.DSP.NWaves.Filters.Base.LtiFilter)">
            <summary>
            Sequential combination of an БИХ фильтр and any LTI filter.
            </summary>
            <param name="filter1"></param>
            <param name="filter2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter.op_Addition(AI.BackEnds.DSP.NWaves.Filters.Base.IirFilter,AI.BackEnds.DSP.NWaves.Filters.Base.LtiFilter)">
            <summary>
            Parallel combination of an IIR and any LTI filter.
            </summary>
            <param name="filter1"></param>
            <param name="filter2"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.IMixable">
            <summary>
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.IMixable.Wet">
            <summary>
            Влажная смесь
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.IMixable.Dry">
            <summary>
            Сухая смесь
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter">
            <summary>
            Интерфейс для всех объектов, поддерживающих онлайн-фильтрацию
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter.Process(System.Single)">
            <summary>
            Метод реализует онлайн фильтрацию (отсчет за отсчетом)
            </summary>
            <param name="input">Входной отсчет</param>
            <returns>Выходной отсчет</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter.Reset">
            <summary>
            Сброс состояния
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.LtiFilter">
            <summary>
            Base class for all kinds of LTI filters.
            
            Provides abstract TransferFunction property
            and leaves methods ApplyTo() and Process() abstract.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.LtiFilter.Tf">
            <summary>
            Передаточная функция.
            
            It's made abstract as of ver.0.9.2 to allow subclasses using memory more efficiently.
            It's supposed that subclasses will generate TransferFunction object on the fly from filter coeffs
            OR aggregate it in internal field (only if it was set specifically from outside).
            
            The example of the latter case is when we really need double precision for FDA
            or when TF was generated from precomputed poles and zeros.
            
            The general rule is:
            
            "Use LtiFilter subclasses for FILTERING;
             Use TransferFunction class for FILTER DESIGN AND ANALYSIS".
             
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.LtiFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            The Фильтрация всего сигнала algorithm that should be implemented by particular subclass
            </summary>
            <param name="signal">Фильтруемый(исходный) сигнал</param>
            <param name="method">Общая стратегия фильтрации</param>
            <returns>Отфильтрованный сигнал</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.LtiFilter.Process(System.Single)">
            <summary>
            The Онлайн-фильтрация algorithm should be implemented by particular subclass
            </summary>
            <param name="input">Входной отсчет</param>
            <returns>Выходной отсчет</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.LtiFilter.Reset">
            <summary>
            Перезапуск фильтра (clear all Внутренние буферы)
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter">
            <summary>
            The base class for all filters working by the STFT overlap-add scheme:
            
            - short-time frame analysis
            - short-time frame processing
            - short-time frame synthesis (overlap-add)
            
            Subclasses must implement ProcessSpectrum() method
            that corresponds to the second stage.
            
            Also, it implements IMixable interface,
            since audio effects can be built based on this class.
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter.Wet">
            <summary>
            Влажная смесь
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter.Dry">
            <summary>
            Сухая смесь
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._hopSize">
            <summary>
            Hop size
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._fftSize">
            <summary>
            Размер блока БПФ для анализа и синтеза
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._gain">
            <summary>
            Коэффициент нормализации ISTFT
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._overlapSize">
            <summary>
            Размер перекрытия (в отсчетах)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._fft">
            <summary>
            Внутренний алгоритм для выполнения БПФ
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._window">
            <summary>
            Весовое окно
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._dl">
            <summary>
            Линия задержки
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._inOffset">
            <summary>
            Смещение входа в линии задержки
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._outOffset">
            <summary>
            Смещение в выходном буфере
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter._re">
            <summary>
            Внутренние буферы
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter.#ctor(System.Int32,System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="hopSize"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter.Process(System.Single)">
            <summary>
            Онлайн-обработка
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter.ProcessFrame">
            <summary>
            Обработка одного БПФ блока
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter.ProcessSpectrum(System.Single[],System.Single[],System.Single[],System.Single[])">
            <summary>
            Обработка одного спектра на каждом шаге STFT
            </summary>
            <param name="re">Реальная часть спектра</param>
            <param name="im">Мнимая часть входного спектра</param>
            <param name="filteredRe">Реальная часть выходного спектра</param>
            <param name="filteredIm">Мнимая часть выходного спектра</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter.Reset">
            <summary>
            Перезапуск фильтра 
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.OverlapAddFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Оффлайн обработка
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.StateSpace">
            <summary>
            Пространство состояний
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.StateSpace.A">
            <summary>
            Матрица состояний
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.StateSpace.B">
            <summary>
            Входная матрица
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.StateSpace.C">
            <summary>
            Выходная матрица
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.StateSpace.D">
            <summary>
            Проходная матрица
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.StereoFilter">
            <summary>
            Фильтр для фильтрации данных в чередующихся стереофонических буферах
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.StereoFilter._filterLeft">
            <summary>
            Фильтр для левого канала
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.StereoFilter._filterRight">
            <summary>
            Фильтр для правого канала
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.StereoFilter._isRight">
            <summary>
            Внутренний флаг для переключения между левым и правым каналами
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.StereoFilter.#ctor(AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter,AI.BackEnds.DSP.NWaves.Filters.Base.IOnlineFilter)">
            <summary>
            Конструктор
            </summary>
            <param name="filterLeft"></param>
            <param name="filterRight"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.StereoFilter.Process(System.Single)">
            <summary>
            Онлайн-фильтрация
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.StereoFilter.Reset">
            <summary>
            Перезапуск фильтраs
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.StereoFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Фильтрация всего сигнала
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction">
            <summary>
            Класс, предоставляющий методы, связанные с передаточной функцией фильтра LTI
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.Numerator">
            <summary>
            Числитель передаточной функции
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.Denominator">
            <summary>
            Знаменатель передаточной функции
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.CalculateZpIterations">
            <summary>
            Максимальное количество итераций для вычисления нулей/полюсов (корней многочленов): 25000 по умолчанию
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction._zeros">
            <summary>
            Нули передаточной функции
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.Zeros">
            <summary>
            Нули передаточной функции
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction._poles">
            <summary>
            Полюса передаточной функции
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.Poles">
            <summary>
            Полюса передаточной функции
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.Gain">
            <summary>
            Коэффициент усиления ('k' в 'zpk' нотации)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.#ctor(System.Double[],System.Double[])">
            <summary>
            Передаточная функция вида numerator/denominator
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.#ctor(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Double)">
            <summary>
            Передаточная функция вида zeros/poles
            </summary>
            <param name="zeros">Zeros</param>
            <param name="poles">Poles</param>
            <param name="gain">Gain</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.#ctor(AI.BackEnds.DSP.NWaves.Filters.Base.StateSpace)">
            <summary>
            Передаточная функция из объекта StateSpace
            </summary>
            <param name="stateSpace"></param>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.StateSpace">
            <summary>
            Представление в виде StateSpace объекта
            </summary>
            <returns></returns>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.Zi">
            <summary>
            Initial state 'zi' for filtering that corresponds to the steady state of the step response
            </summary>
            <returns>Initial state</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.ImpulseResponse(System.Int32)">
            <summary>
            Evaluate Импульсивный ответ
            </summary>
            <param name="length">Ignored for FIR filters (where IR is full copy of numerator)</param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.FrequencyResponse(System.Int32)">
            <summary>
            Evaluate frequency response
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.GroupDelay(System.Int32)">
            <summary>
            Group delay calculated from TF coefficients
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.PhaseDelay(System.Int32)">
            <summary>
            Phase delay calculated from TF coefficients
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.NormalizeAt(System.Double)">
            <summary>
            Normalize frequency response at given frequency
            (normalize coefficients to map frequency response onto [0, 1])
            </summary>
            <param name="freq"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.Normalize">
            <summary>
            Normalize numerator and denominator by Denominator[0]
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.ZpToTf(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            Method for converting zeros(poles) to TF numerator(denominator)
            </summary>
            <param name="zp"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.ZpToTf(System.Double[],System.Double[])">
            <summary>
            Method for converting zeros(poles) to TF numerator(denominator).
            Zeros and poles are given as double arrays of real and imaginary parts of zeros(poles).
            </summary>
            <param name="re"></param>
            <param name="im"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.TfToZp(System.Double[],System.Int32)">
            <summary>
            Конвертирование передаточной функции в полюсно-нулевую
            </summary>
            <param name="tf">Передаточная функция</param>
            <param name="maxIterations">Максимальное число итераций</param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.op_Multiply(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction,AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction)">
            <summary>
            Sequential connection
            </summary>
            <param name="tf1"></param>
            <param name="tf2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.op_Addition(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction,AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction)">
            <summary>
            Parallel connection
            </summary>
            <param name="tf1"></param>
            <param name="tf2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.FromCsv(System.IO.Stream,System.Char)">
            <summary>
            Load TF numerator and denominator from csv file
            </summary>
            <param name="stream">Поток</param>
            <param name="delimiter"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction.ToCsv(System.IO.Stream,System.Char)">
            <summary>
            Serialize TF numerator and denominator to csv file
            </summary>
            <param name="stream">Поток</param>
            <param name="delimiter"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter">
            <summary>
            Фильтр LTI на основе представления пространства состояний
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter._b">
            <summary>
            Числитель передаточной функции фильтра
            (Не рекусивная часть разностного фильтра)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter._a">
            <summary>
            Знаменатель передаточной функции фильтра 
            (Рекусивная часть разностного фильтра)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter._zi">
            <summary>
            Вектор состояний
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.Zi">
            <summary>
            Данные линии задержки
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter._tf">
            <summary>
            Передаточная функция
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.Tf">
            <summary>
            Передаточная функция
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.#ctor(System.Collections.Generic.IEnumerable{System.Single},System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Параметризованный конструктор (На основе 32-битных коэффицентов)
            </summary>
            <param name="b">Коэф. в числителе передаточной функции</param>
            <param name="a">Коэф. в знаменателе передаточной функции</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Параметризованный конструктор (Массив 64х битных коэффициентов)
            </summary>
            <param name="b">Коэф. в числителе передаточной функции</param>
            <param name="a">Коэф. в знаменателе передаточной функции</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.#ctor(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction)">
            <summary>
            Параметризованный конструктор (Передаточная функция).
            </summary>
            <param name="tf">Передаточная функция</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.Init(System.Single[])">
            <summary>
            Инициализация фильтра
            </summary>
            <param name="zi"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.Init(System.Double[])">
            <summary>
            Инициализация фильтра (преобразует double в float)
            </summary>
            <param name="zi"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Применить фильтр ко всему сигналу (оффлайн)
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.FilterIc(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Фильтрация всего сигнала с начальным условием
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.Process(System.Single)">
            <summary>
            Онлайн-фильтрация с начальными условиями
            </summary>
            <param name="input">Входной отсчет</param>
            <returns>Выходной отсчет</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.ZeroPhase(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32)">
            <summary>
            Нуль-фазовая фильтрация (аналог filtfilt() в MATLAB/sciPy)
            </summary>
            <param name="signal"></param>
            <param name="padLength"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Base.ZiFilter.Reset">
            <summary>
            Перезапуск фильтра
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Bessel.BandPassFilter">
            <summary>
            Полосовой фильтр Бесселя
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.BandPassFilter.#ctor(System.Double,System.Double,System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.BandPassFilter.MakeTf(System.Double,System.Double,System.Int32)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Bessel.BandStopFilter">
            <summary>
            Полосно-заграждающий фильтр Бесселя
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.BandStopFilter.#ctor(System.Double,System.Double,System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.BandStopFilter.MakeTf(System.Double,System.Double,System.Int32)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Bessel.HighPassFilter">
            <summary>
            Фильтр верхних частот Бесселя
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.HighPassFilter.#ctor(System.Double,System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.HighPassFilter.MakeTf(System.Double,System.Int32)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Bessel.LowPassFilter">
            <summary>
            Фильтр нижних частот Бесселя
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.LowPassFilter.#ctor(System.Double,System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.LowPassFilter.MakeTf(System.Double,System.Int32)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Bessel.PrototypeBessel">
            <summary>
            Прототип фильтра Бесселя
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.PrototypeBessel.Reverse(System.Int32,System.Int32)">
            <summary>
            k-th coefficient of n-th order Bessel polynomial
            </summary>
            <param name="k"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Bessel.PrototypeBessel.Poles(System.Int32)">
            <summary>
            Полюсы аналогового фильтра Бесселя
            </summary>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.BiQuad.AllPassFilter">
            <summary>
            Биквадратный фильтр
            The coef "A"re calculated automatically according to 
            audio-eq-cookbook by R.Bristow-Johnson and WebAudio API.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.AllPassFilter.Freq">
            <summary>
            Частота
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.AllPassFilter.Q">
            <summary>
            Добротность
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.AllPassFilter.#ctor(System.Double,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.AllPassFilter.SetCoefficients(System.Double,System.Double)">
            <summary>
            Установить коэффициенты фильтра
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.AllPassFilter.Change(System.Double,System.Double)">
            <summary>
            Изменить параметры фильтра (с сохранением его состояния)
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BandPassFilter">
            <summary>
            Биквадратный полосовой фильтр.
            The coef "A"re calculated automatically according to 
            audio-eq-cookbook by R.Bristow-Johnson and WebAudio API.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BandPassFilter.Freq">
            <summary>
            Частота
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BandPassFilter.Q">
            <summary>
            Добротность
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BandPassFilter.#ctor(System.Double,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BandPassFilter.SetCoefficients(System.Double,System.Double)">
            <summary>
            Установить коэффициенты фильтра
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BandPassFilter.Change(System.Double,System.Double)">
            <summary>
            Изменить параметры фильтра (с сохранением его состояния)
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BiQuadFilter">
            <summary>
            BiQuad filter base class
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BiQuadFilter._in1">
            <summary>
            Линия задержки
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BiQuadFilter.#ctor">
            <summary>
            Конструктор
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BiQuadFilter.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Конструктор использующий коэффициенты передаточной функции
            </summary>
            <param name="b0"></param>
            <param name="b1"></param>
            <param name="b2"></param>
            <param name="a0"></param>
            <param name="a1"></param>
            <param name="a2"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BiQuadFilter.Process(System.Double)">
            <summary>
            Онлайн-фильтрация (отсчет за отсчетом)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.BiQuadFilter.Reset">
            <summary>
            Перезапуск фильтра
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighPassFilter">
            <summary>
            Биквадратный фильтр верхних частот
            The coef "A"re calculated automatically according to 
            audio-eq-cookbook by R.Bristow-Johnson and WebAudio API.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighPassFilter.Freq">
            <summary>
            Частота
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighPassFilter.Q">
            <summary>
            Добротность
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighPassFilter.#ctor(System.Double,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighPassFilter.SetCoefficients(System.Double,System.Double)">
            <summary>
            Установить коэффициенты фильтра
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighPassFilter.Change(System.Double,System.Double)">
            <summary>
            Изменить параметры фильтра (с сохранением его состояния)
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighShelfFilter">
            <summary>
            BiQuad high-shelving filter.
            The coef "A"re calculated automatically according to 
            audio-eq-cookbook by R.Bristow-Johnson and WebAudio API.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighShelfFilter.Freq">
            <summary>
            Частота
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighShelfFilter.Q">
            <summary>
            Добротность
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighShelfFilter.Gain">
            <summary>
            Усиление
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighShelfFilter.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
            <param name="gain"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighShelfFilter.SetCoefficients(System.Double,System.Double,System.Double)">
            <summary>
            Установить коэффициенты фильтра
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
            <param name="gain"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.HighShelfFilter.Change(System.Double,System.Double,System.Double)">
            <summary>
            Изменить параметры фильтра (с сохранением его состояния)
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
            <param name="gain"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowPassFilter">
            <summary>
            Биквадратный фильтр нижних частот
            The coef "A"re calculated automatically according to 
            audio-eq-cookbook by R.Bristow-Johnson and WebAudio API.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowPassFilter.Freq">
            <summary>
            Частота
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowPassFilter.Q">
            <summary>
            Добротность
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowPassFilter.#ctor(System.Double,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowPassFilter.SetCoefficients(System.Double,System.Double)">
            <summary>
            Установить коэффициенты фильтра
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowPassFilter.Change(System.Double,System.Double)">
            <summary>
            Изменить параметры фильтра (с сохранением его состояния)
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowShelfFilter">
            <summary>
            BiQuad low-shelving filter.
            The coef "A"re calculated automatically according to 
            audio-eq-cookbook by R.Bristow-Johnson and WebAudio API.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowShelfFilter.Freq">
            <summary>
            Частота
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowShelfFilter.Q">
            <summary>
            Добротность
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowShelfFilter.Gain">
            <summary>
            Усиление
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowShelfFilter.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
            <param name="gain"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowShelfFilter.SetCoefficients(System.Double,System.Double,System.Double)">
            <summary>
            Установить коэффициенты фильтра
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
            <param name="gain"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.LowShelfFilter.Change(System.Double,System.Double,System.Double)">
            <summary>
            Изменить параметры фильтра (с сохранением его состояния)
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
            <param name="gain"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.BiQuad.NotchFilter">
            <summary>
            Биквадратный режекторный фильтр
            The coef "A"re calculated automatically according to 
            audio-eq-cookbook by R.Bristow-Johnson and WebAudio API.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.NotchFilter.Freq">
            <summary>
            Частота
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.NotchFilter.Q">
            <summary>
            Добротность
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.NotchFilter.#ctor(System.Double,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.NotchFilter.SetCoefficients(System.Double,System.Double)">
            <summary>
            Установить коэффициенты фильтра
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.NotchFilter.Change(System.Double,System.Double)">
            <summary>
            Изменить параметры фильтра (с сохранением его состояния)
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.BiQuad.PeakFilter">
            <summary>
            Биквадратный пиковый фильтр эквалайзера
            
            The coef "A"re calculated automatically according to 
            audio-eq-cookbook by R.Bristow-Johnson and WebAudio API.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.PeakFilter.Freq">
            <summary>
            Частота
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.PeakFilter.Q">
            <summary>
            Добротность
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.BiQuad.PeakFilter.Gain">
            <summary>
            Усиление
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.PeakFilter.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
            <param name="gain"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.PeakFilter.SetCoefficients(System.Double,System.Double,System.Double)">
            <summary>
            Установить коэффициенты фильтра
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
            <param name="gain"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.BiQuad.PeakFilter.Change(System.Double,System.Double,System.Double)">
            <summary>
            Изменить параметры фильтра (с сохранением его состояния)
            </summary>
            <param name="freq"></param>
            <param name="q"></param>
            <param name="gain"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Butterworth.BandPassFilter">
            <summary>
            Полосовой фильтр Баттервордта.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Butterworth.BandPassFilter.#ctor(System.Double,System.Double,System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Butterworth.BandPassFilter.MakeTf(System.Double,System.Double,System.Int32)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Butterworth.BandStopFilter">
            <summary>
            Режекторный фильтр Баттервордта
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Butterworth.BandStopFilter.#ctor(System.Double,System.Double,System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Butterworth.BandStopFilter.MakeTf(System.Double,System.Double,System.Int32)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Butterworth.HighPassFilter">
            <summary>
            Фильтр Баттервордта верхних частот
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Butterworth.HighPassFilter.#ctor(System.Double,System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Butterworth.HighPassFilter.MakeTf(System.Double,System.Int32)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Butterworth.LowPassFilter">
            <summary>
            Фильтр Баттервордта нижних частот
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Butterworth.LowPassFilter.#ctor(System.Double,System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Butterworth.LowPassFilter.MakeTf(System.Double,System.Int32)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Butterworth.PrototypeButterworth">
            <summary>
            Прототип фильтра Баттервордта
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Butterworth.PrototypeButterworth.Poles(System.Int32)">
            <summary>
            Полюса передаточной функции
            </summary>
            <param name="order">Порядок фильтра</param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.BandPassFilter">
            <summary>
            Полосовой фильтр Чебышёва второго рода
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.BandPassFilter.#ctor(System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
            <param name="ripple">Коэф. пульсаций</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.BandPassFilter.MakeTf(System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="freq1"></param>
            <param name="freq2"></param>
            <param name="order"></param>
            <param name="ripple">Коэф. пульсаций</param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.BandStopFilter">
            <summary>
            Полосно заграждающий (режекторный) фильтр Чебышёва второго рода
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.BandStopFilter.#ctor(System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
            <param name="ripple">Коэф. пульсаций</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.BandStopFilter.MakeTf(System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="freq1"></param>
            <param name="freq2"></param>
            <param name="order"></param>
            <param name="ripple">Коэф. пульсаций</param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.HighPassFilter">
            <summary>
            Фильтр верхних частот Чебышёва второго рода
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.HighPassFilter.#ctor(System.Double,System.Int32,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <param name="ripple"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.HighPassFilter.MakeTf(System.Double,System.Int32,System.Double)">
            <summary>
            Создание передаточной функции
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.LowPassFilter">
            <summary>
            Фильтр нижних частот Чебышёва второго рода
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.LowPassFilter.#ctor(System.Double,System.Int32,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="freq">Частота среза</param>
            <param name="order">Порядок</param>
            <param name="ripple">Коэф. пульсаций</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.LowPassFilter.MakeTf(System.Double,System.Int32,System.Double)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="freq">Частота среза</param>
            <param name="order">Порядок</param>
            <param name="ripple">Коэф. пульсаций</param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.PrototypeChebyshevII">
            <summary>
            Прототип фильтра Чебышёва 2го рода
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.PrototypeChebyshevII.Poles(System.Int32,System.Double)">
            <summary>
            Полюсы передаточной функции
            </summary>
            <param name="order">Порядок</param>
            <param name="ripple">Коэф. пульсаций</param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevII.PrototypeChebyshevII.Zeros(System.Int32)">
            <summary>
            Нули передаточной функции
            </summary>
            <param name="order">Порядок фильтра</param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.BandPassFilter">
            <summary>
            Полосовой фильтр Чебышёва первого рода
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.BandPassFilter.#ctor(System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="f1">Нижняя частота среза</param>
            <param name="f2">Верхняя частота среза</param>
            <param name="order">Порядок фильтра</param>
            <param name="ripple">Коэф. пульсаций</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.BandPassFilter.MakeTf(System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order"></param>
            <param name="ripple">Коэф. пульсаций</param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.BandStopFilter">
            <summary>
            Полосно заграждающий (режекторный) фильтр Чебышёва первого рода
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.BandStopFilter.#ctor(System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order">Порядок</param>
            <param name="ripple">Коэф. пульсаций</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.BandStopFilter.MakeTf(System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="f1"></param>
            <param name="f2"></param>
            <param name="order">Порядок</param>
            <param name="ripple">Коэф. пульсаций</param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.HighPassFilter">
            <summary>
            Фильтр верхних частот Чебышёва первого рода
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.HighPassFilter.#ctor(System.Double,System.Int32,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <param name="ripple"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.HighPassFilter.MakeTf(System.Double,System.Int32,System.Double)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="freq"></param>
            <param name="order">Порядок</param>
            <param name="ripple">Коэф. пульсаций</param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.LowPassFilter">
            <summary>
            Фильтр нижних частот Чебышёва первого рода
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.LowPassFilter.#ctor(System.Double,System.Int32,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <param name="ripple"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.LowPassFilter.MakeTf(System.Double,System.Int32,System.Double)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="freq"></param>
            <param name="order">Порядок</param>
            <param name="ripple">Коэф. пульсаций</param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.PrototypeChebyshevI">
            <summary>
            Прототип фильтра Чебшёва первого рода
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ChebyshevI.PrototypeChebyshevI.Poles(System.Int32,System.Double)">
            <summary>
            Полюса передаточной функции
            </summary>
            <param name="order">Порядок</param>
            <param name="ripple">Коэф. пульсаций</param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.CombFeedbackFilter">
            <summary>
            Гребенчатый фильтр с обратной связью:
            
                y[n] = b0 * x[n] - am * y[n - m]
            
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.CombFeedbackFilter._delay">
            <summary>
            Задержка на m шагов
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.CombFeedbackFilter.#ctor(System.Int32,System.Double,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="m">Задержка</param>
            <param name="b0">Coefficient b0</param>
            <param name="am">Coefficient am</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.CombFeedbackFilter.Process(System.Single)">
            <summary>
            Онлайн-фильтрация (отсчет за отсчетом)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.CombFeedbackFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Применить фильтр
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.CombFeedbackFilter.Change(System.Double,System.Double)">
            <summary>
            Изменить состояние (сохранение состояния)
            </summary>
            <param name="b0"></param>
            <param name="am"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.CombFeedforwardFilter">
            <summary>
            Feedforward comb filter:
            
                y[n] = b0 * x[n] + bm * x[n - m]
            
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.CombFeedforwardFilter._delay">
            <summary>
            Задержка на m шагов
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.CombFeedforwardFilter.#ctor(System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Конструктор
            </summary>
            <param name="m">Задержка</param>
            <param name="b0">Coefficient b0</param>
            <param name="bm">Coefficient bm</param>
            <param name="normalize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.CombFeedforwardFilter.MakeKernel(System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Генератор ядра
            </summary>
            <param name="m">Задержка</param>
            <param name="b0">Coefficient b0</param>
            <param name="bm">Coefficient bm</param>
            <param name="normalize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.CombFeedforwardFilter.Process(System.Single)">
            <summary>
            Онлайн-фильтрация (отсчет за отсчетом)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.CombFeedforwardFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Применить фильтр
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.CombFeedforwardFilter.Change(System.Double,System.Double)">
            <summary>
            Изменить состояние (сохранение состояния)
            </summary>
            <param name="b0"></param>
            <param name="bm"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.DcRemovalFilter">
            <summary>
            DC removal БИХ фильтр
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.DcRemovalFilter._r">
            <summary>
            R parameter
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.DcRemovalFilter._in1">
            <summary>
            Линия задержки
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.DcRemovalFilter.#ctor(System.Double)">
            <summary>
            Конструктор creates simple 1st order recursive filter
            </summary>
            <param name="r">R coefficient (usually in [0.9, 1] range)</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.DcRemovalFilter.Process(System.Single)">
            <summary>
            Онлайн-фильтрация (отсчет за отсчетом)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.DcRemovalFilter.Reset">
            <summary>
            Reset
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.DeEmphasisFilter">
            <summary>
            Standard de-emphasis БИХ фильтр
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.DeEmphasisFilter.#ctor(System.Double,System.Boolean)">
            <summary>
            Конструктор
            </summary>
            <param name="a">De-emphasis coefficient</param>
            <param name="normalize">Normalize freq response to unit gain</param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Elliptic.BandPassFilter">
            <summary>
            Полосно пропускающий фильтр (полосовой)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.BandPassFilter.#ctor(System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="freq1"></param>
            <param name="freq2"></param>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.BandPassFilter.MakeTf(System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="freq1"></param>
            <param name="freq2"></param>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Elliptic.BandStopFilter">
            <summary>
            Полосно заграждающий фильтр (режекторный)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.BandStopFilter.#ctor(System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="freq1"></param>
            <param name="freq2"></param>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.BandStopFilter.MakeTf(System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="freq1"></param>
            <param name="freq2"></param>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Elliptic.HighPassFilter">
            <summary>
            Фильтр верхних частот
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.HighPassFilter.#ctor(System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.HighPassFilter.MakeTf(System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Elliptic.LowPassFilter">
            <summary>
            Фильтр нижних частот
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.LowPassFilter.#ctor(System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.LowPassFilter.MakeTf(System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="freq"></param>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Elliptic.PrototypeElliptic">
            <summary>
            Orfanidis, S. J. (2007). Lecture notes on elliptic filter design.
            URL: http://www.ece.rutgers.edu/~orfanidi/ece521/notes.pdf
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.PrototypeElliptic.Poles(System.Int32,System.Double,System.Double)">
            <summary>
            Poles 
            </summary>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.PrototypeElliptic.Zeros(System.Int32,System.Double,System.Double)">
            <summary>
            Нули передаточной функции
            </summary>
            <param name="order"></param>
            <param name="ripplePass"></param>
            <param name="rippleStop"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.PrototypeElliptic.Landen(System.Double,System.Int32)">
            <summary>
            Landen sequence
            </summary>
            <param name="k"></param>
            <param name="iterCount"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.PrototypeElliptic.Cde(System.Numerics.Complex,System.Double[])">
            <summary>
            cde function
            </summary>
            <param name="x"></param>
            <param name="landen"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.PrototypeElliptic.Sne(System.Numerics.Complex,System.Double[])">
            <summary>
            sne function
            </summary>
            <param name="x"></param>
            <param name="landen"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Elliptic.PrototypeElliptic.Asne(System.Numerics.Complex,System.Double,System.Int32)">
            <summary>
            Inverse sne function
            </summary>
            <param name="x"></param>
            <param name="k"></param>
            <param name="iterCount"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter">
            <summary>
            Статический класс, предоставляющий основные методы для анализа и проектирования фильтров.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirWinLp(System.Int32,System.Double,AI.BackEnds.DSP.NWaves.Windows.WindowTypes)">
            <summary>
            Метод создания идеального КИХ-фильтра нижних частот с использованием метода весового окна с функцией sin(x)/x
            </summary>
            <param name="order"></param>
            <param name="freq"></param>
            <param name="window"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirWinHp(System.Int32,System.Double,AI.BackEnds.DSP.NWaves.Windows.WindowTypes)">
            <summary>
            Метод создания идеального КИХ-фильтра верхних частот с использованием метода весового окна с функцией sin(x)/x
            </summary>
            <param name="order"></param>
            <param name="freq"></param>
            <param name="window"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirWinBp(System.Int32,System.Double,System.Double,AI.BackEnds.DSP.NWaves.Windows.WindowTypes)">
            <summary>
            Метод создания идеального полосового КИХ-фильтра с использованием метода весового окна с функцией sin(x)/x
            </summary>
            <param name="order"></param>
            <param name="freq1"></param>
            <param name="freq2"></param>
            <param name="window"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirWinBs(System.Int32,System.Double,System.Double,AI.BackEnds.DSP.NWaves.Windows.WindowTypes)">
            <summary>
            Метод создания идеального режекторного КИХ-фильтра с использованием метода весового окна с функцией sin(x)/x
            </summary>
            <param name="order"></param>
            <param name="freq1"></param>
            <param name="freq2"></param>
            <param name="window"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirEquirippleLp(System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Design equiripple LP FIR filter using Remez (Parks-McClellan) algorithm
            </summary>
            <param name="order">Order</param>
            <param name="fp">Passband edge frequency</param>
            <param name="fa">Stopband edge frequency</param>
            <param name="wp">Passband weight</param>
            <param name="wa">Stopband weight</param>
            <returns>Filter kernel</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirEquirippleHp(System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Design equiripple HP FIR filter using Remez (Parks-McClellan) algorithm
            </summary>
            <param name="order">Order</param>
            <param name="fa">Stopband edge frequency</param>
            <param name="fp">Passband edge frequency</param>
            <param name="wa">Stopband weight</param>
            <param name="wp">Passband weight</param>
            <returns>Filter kernel</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirEquirippleBp(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Design equiripple BP FIR filter using Remez (Parks-McClellan) algorithm
            </summary>
            <param name="order">Order</param>
            <param name="fa1">Left stopband edge frequency</param>
            <param name="fp1">Passband left edge frequency</param>
            <param name="fp2">Passband right edge frequency</param>
            <param name="fa2">Right stopband edge frequency</param>
            <param name="wa1">Left stopband weight</param>
            <param name="wp">Passband weight</param>
            <param name="wa2">Right stopband weight</param>
            <returns>Filter kernel</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirEquirippleBs(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Design equiripple BS FIR filter using Remez (Parks-McClellan) algorithm
            </summary>
            <param name="order">Order</param>
            <param name="fp1">Left passband edge frequency</param>
            <param name="fa1">Stopband left edge frequency</param>
            <param name="fa2">Stopband right edge frequency</param>
            <param name="fp2">Right passband edge frequency</param>
            <param name="wp1">Left passband weight</param>
            <param name="wa">Stopband weight</param>
            <param name="wp2">Right passband weight</param>
            <returns>Filter kernel</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.Fir(System.Int32,System.Double[],System.Double[],AI.BackEnds.DSP.NWaves.Windows.WindowTypes)">
            <summary>
            FIR filter design using frequency sampling method
            </summary>
            <param name="order">Filter order</param>
            <param name="magnitudeResponse">Magnitude response</param>
            <param name="phaseResponse">Phase response</param>
            <param name="window">Окно</param>
            <returns>FIR filter kernel</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.Fir(System.Int32,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Windows.WindowTypes)">
            <summary>
            FIR filter design using frequency sampling method
            </summary>
            <param name="order">Filter order</param>
            <param name="frequencyResponse">Complex frequency response</param>
            <param name="window">Окно</param>
            <returns>FIR filter kernel</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.Fir(System.Int32,System.Single[],System.Single[],AI.BackEnds.DSP.NWaves.Windows.WindowTypes)">
            <summary>
            FIR filter design using frequency sampling method (32-bit precision)
            </summary>
            <param name="order">Filter order</param>
            <param name="magnitudeResponse">Magnitude response</param>
            <param name="phaseResponse">Phase response</param>
            <param name="window">Окно</param>
            <returns>FIR filter kernel</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirLpToHp(System.Double[])">
            <summary>
            Method for making HP filter from the linear-phase LP filter
            </summary>
            <param name="kernel"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirHpToLp(System.Double[])">
            <summary>
            Method for making LP filter from the linear-phase HP filter
            (not different from FirLpToHp method)
            </summary>
            <param name="kernel"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirBpToBs(System.Double[])">
            <summary>
            Method for making BS filter from the linear-phase BP filter
            (not different from FirLpToHp method)
            </summary>
            <param name="kernel"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.FirBsToBp(System.Double[])">
            <summary>
            Method for making BP filter from the linear-phase BS filter
            (not different from FirLpToHp method)
            </summary>
            <param name="kernel"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.IirLpTf(System.Double,System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
            Design TF for Фильтр нижних частот pole filter
            </summary>
            <param name="freq">Cutoff frequency in range [0, 0.5]</param>
            <param name="poles">Analog prototype poles</param>
            <param name="zeros">Analog prototype zeros</param>
            <returns>Передаточная функция</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.IirHpTf(System.Double,System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
            Design TF for фильтр нижних частот pole filter
            </summary>
            <param name="freq">Cutoff frequency in range [0, 0.5]</param>
            <param name="poles">Analog prototype poles</param>
            <param name="zeros">Analog prototype zeros</param>
            <returns>Передаточная функция</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.IirBpTf(System.Double,System.Double,System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
            Design TF for Полосовой pole filter
            </summary>
            <param name="freq1">Left cutoff frequency in range [0, 0.5]</param>
            <param name="freq2">Right cutoff frequency in range [0, 0.5]</param>
            <param name="poles">Analog prototype poles</param>
            <param name="zeros">Analog prototype zeros</param>
            <returns>Передаточная функция</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.IirBsTf(System.Double,System.Double,System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
            Design TF for band-reject pole filter
            </summary>
            <param name="freq1">Left cutoff frequency in range [0, 0.5]</param>
            <param name="freq2">Right cutoff frequency in range [0, 0.5]</param>
            <param name="poles">Analog prototype poles</param>
            <param name="zeros">Analog prototype zeros</param>
            <returns>Передаточная функция</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.SosToTf(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction[])">
            <summary>
            Second-order sections to zpk.
            </summary>
            <param name="sos"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.TfToSos(AI.BackEnds.DSP.NWaves.Filters.Base.TransferFunction)">
            <summary>
            Zpk to second-order sections.
            </summary>
            <param name="tf">Передаточная функция</param>
            <returns>Array of SOS Передаточная функцияs</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.DesignFilter.RemoveConjugated(System.Collections.Generic.List{System.Numerics.Complex})">
            <summary>
            Leave only one of two conjugated numbers in the list of complex numbers
            </summary>
            <param name="c"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks">
            <summary>
            Static class with methods providing general shapes of filter banks:
            
                - triangular
                - rectangular
                - FIR bandpass (close to trapezoidal, slightly overlapping)
                - BiQuad bandpass
            
            ...and methods for obtaining the most widely used frequency bands:
            
                - Herz bands
                - Mel bands (HTK and Slaney)
                - Bark bands (uniform and Slaney)
                - Critical bands
                - ERB filterbank
                - Octaves (from MPEG-7)
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.Triangular(System.Int32,System.Int32,System.Tuple{System.Double,System.Double,System.Double}[],AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper,System.Func{System.Double,System.Double})">
            <summary>
            Method returns universal triangular filterbank weights based on given frequencies.
            </summary>
            <param name="fftSize">Assumed Размер блока БПФ</param>
            <param name="samplingRate">Assumed Частота дискретизации of a signal</param>
            <param name="frequencies">Array of frequency tuples (left, center, right) for each filter</param>
            <param name="vtln">VTLN frequency warper</param>
            <param name="mapper">Frequency scale mapper (e.g. herz-to-mel) used here only for proper weighting</param>
            <returns>Array of triangular filters</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.Rectangular(System.Int32,System.Int32,System.Tuple{System.Double,System.Double,System.Double}[],AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper,System.Func{System.Double,System.Double})">
            <summary>
            Method returns universal rectangular filterbank weights based on given frequencies.
            </summary>
            <param name="fftSize">Assumed Размер блока БПФ</param>
            <param name="samplingRate">Assumed Частота дискретизации of a signal</param>
            <param name="frequencies">Array of frequency tuples (left, center, right) for each filter</param>
            <param name="vtln">VTLN frequency warper</param>
            <param name="mapper">Frequency scale mapper (e.g. herz-to-mel)</param>
            <returns>Array of rectangular filters</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.Trapezoidal(System.Int32,System.Int32,System.Tuple{System.Double,System.Double,System.Double}[],AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper,System.Func{System.Double,System.Double})">
            <summary>
            Method returns FIR bandpass (close to trapezoidal) filterbank based on given frequencies.
            </summary>
            <param name="fftSize">Assumed Размер блока БПФ</param>
            <param name="samplingRate">Assumed Частота дискретизации of a signal</param>
            <param name="frequencies">Array of frequency tuples (left, center, right) for each filter</param>
            <param name="vtln">VTLN frequency warper</param>
            <param name="mapper">Frequency scale mapper (e.g. herz-to-mel)</param>
            <returns>Array of rectangular filters</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.BiQuad(System.Int32,System.Int32,System.Tuple{System.Double,System.Double,System.Double}[])">
            <summary>
            Method returns BiQuad bandpass overlapping filters based on given frequencies.
            </summary>
            <param name="fftSize">Assumed Размер блока БПФ</param>
            <param name="samplingRate">Assumed Частота дискретизации of a signal</param>
            <param name="frequencies">Array of frequency tuples (left, center, right) for each filter</param>
            <returns>Array of BiQuad bandpass filters</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.UniformBands(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            This general method returns frequency tuples for uniformly spaced frequency bands on any scale.
            </summary>
            <param name="scaleMapper">The function that converts Hz to other frequency scale</param>
            <param name="inverseMapper">The function that converts frequency from alternative scale back to Hz</param>
            <param name="filterCount">Число фильтров</param>
            <param name="samplingRate">Assumed Частота дискретизации of a signal</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <param name="overlap">Flag indicating that bands should overlap</param>
            <returns>Array of frequency tuples for each filter</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.HerzBands(System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Method returns frequency tuples for uniformly spaced frequency bands on Herz scale.
            </summary>
            <param name="combFilterCount">Число фильтров</param>
            <param name="samplingRate">Assumed Частота дискретизации of a signal</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <param name="overlap">Flag indicating that bands should overlap</param>
            <returns>Array of frequency tuples for each Herz filter</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.MelBands(System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Method returns frequency tuples for uniformly spaced frequency bands on Mel scale.
            </summary>
            <param name="melFilterCount">Number of mel filters to create</param>
            <param name="samplingRate">Assumed Частота дискретизации of a signal</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <param name="overlap">Flag indicating that bands should overlap</param>
            <returns>Array of frequency tuples for each Mel filter</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.MelBandsSlaney(System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Method returns frequency tuples for uniformly spaced frequency bands on Mel scale
            (according to M.Slaney's formula).
            </summary>
            <param name="melFilterCount">Number of mel filters to create</param>
            <param name="samplingRate">Assumed Частота дискретизации of a signal</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <param name="overlap">Flag indicating that bands should overlap</param>
            <returns>Array of frequency tuples for each Mel filter</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.BarkBands(System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Method returns frequency tuples for uniformly spaced frequency bands on Bark scale (Traunmueller, 1990).
            </summary>
            <param name="barkFilterCount">Number of bark filters to create</param>
            <param name="samplingRate">Assumed Частота дискретизации of a signal</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <param name="overlap">Flag indicating that bands should overlap</param>
            <returns>Array of frequency tuples for each Bark filter</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.BarkBandsSlaney(System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Method returns frequency tuples for uniformly spaced frequency bands on Bark scale (Wang, 1992).
            </summary>
            <param name="barkFilterCount">Number of bark filters to create</param>
            <param name="samplingRate">Assumed Частота дискретизации of a signal</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <param name="overlap">Flag indicating that bands should overlap</param>
            <returns>Array of frequency tuples for each Bark filter</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.CriticalBands(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Method returns frequency tuples for critical bands.
            </summary>
            <param name="filterCount">Число фильтров</param>
            <param name="samplingRate">Assumed Частота дискретизации of a signal</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <returns>Array of frequency tuples for each Critical Band filter</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.OctaveBands(System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Method returns frequency tuples for octave bands.
            </summary>
            <param name="octaveCount">Number of octave filters to create</param>
            <param name="samplingRate">Assumed Частота дискретизации of a signal</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <param name="overlap">Flag indicating that bands should overlap</param>
            <returns>Array of frequency tuples for each octave filter</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.MelBankSlaney(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Boolean,AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper)">
            <summary>
            Method creates overlapping triangular mel filters (as suggested by Malcolm Slaney).
            </summary>
            <param name="filterCount">Number of mel filters</param>
            <param name="fftSize">Assumed Размер блока БПФ</param>
            <param name="samplingRate">Assumed Частота дискретизации</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <param name="normalizeGain">True if gain should be normalized; false if all filters should have same height 1.0</param>
            <param name="vtln">VTLN frequency warper</param>
            <returns>Array of mel filters</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.BarkBankSlaney(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Method creates overlapping trapezoidal bark filters (as suggested by Malcolm Slaney).
            </summary>
            <param name="filterCount"></param>
            <param name="fftSize"></param>
            <param name="samplingRate"></param>
            <param name="lowFreq"></param>
            <param name="highFreq"></param>
            <param name="width">Constant width of each band in Bark</param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.Erb(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Method creates overlapping ERB filters (ported from Malcolm Slaney's MATLAB code).
            </summary>
            <param name="erbFilterCount">Number of ERB filters</param>
            <param name="fftSize">Assumed Размер блока БПФ</param>
            <param name="samplingRate">Assumed Частота дискретизации</param>
            <param name="lowFreq">Lower bound of the frequency range</param>
            <param name="highFreq">Upper bound of the frequency range</param>
            <param name="normalizeGain">True if gain should be normalized; false if all filters should have same height 1.0</param>
            <returns>Array of ERB filters</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.Normalize(System.Int32,System.Tuple{System.Double,System.Double,System.Double}[],System.Single[][])">
            <summary>
            Normalize weights (so that energies in each band are approx. equal)
            </summary>
            <param name="filterCount"></param>
            <param name="frequencies"></param>
            <param name="filterBank"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.Apply(System.Single[][],System.Single[],System.Single[])">
            <summary>
            Method applies filters to spectrum and fills resulting filtered spectrum.
            </summary>
            <param name="filterbank"></param>
            <param name="spectrum"></param>
            <param name="filtered"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.Apply(System.Single[][],System.Collections.Generic.IList{System.Single[]})">
            <summary>
            Method applies filters to sequence of spectra
            </summary>
            <param name="filterbank"></param>
            <param name="spectrogram"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.ApplyAndLog(System.Single[][],System.Single[],System.Single[],System.Single)">
            <summary>
            Method applies filters to spectrum and then does Ln() on resulting spectrum.
            </summary>
            <param name="filterbank"></param>
            <param name="spectrum"></param>
            <param name="filtered"></param>
            <param name="floor">log floor</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.ApplyAndLog10(System.Single[][],System.Single[],System.Single[],System.Single)">
            <summary>
            Method applies filters to spectrum and then does Log10() on resulting spectrum.
            </summary>
            <param name="filterbank"></param>
            <param name="spectrum"></param>
            <param name="filtered"></param>
            <param name="floor">log floor</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.ApplyAndToDecibel(System.Single[][],System.Single[],System.Single[],System.Single)">
            <summary>
            Method applies filters to spectrum and then does 10*Log10() on resulting spectrum
            (added to compare MFCC coefficients with librosa results)
            </summary>
            <param name="filterbank"></param>
            <param name="spectrum"></param>
            <param name="filtered"></param>
            <param name="minLevel"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.FilterBanks.ApplyAndPow(System.Single[][],System.Single[],System.Single[],System.Double)">
            <summary>
            Method applies filters to spectrum and then does Pow(x, power) on resulting spectrum.
            In PLP: power=1/3 (cubic root).
            </summary>
            <param name="filterbank"></param>
            <param name="spectrum"></param>
            <param name="filtered"></param>
            <param name="power"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez">
            <summary>
            Optimal equiripple filter designer based on Remez (Parks-McClellan) algorithm.
            
            Пример:
            
                var order = 57;
                var freqs = new double[] { 0, 0.15, 0.17, 0.5 };
                var response = new double[] { 1, 0 };
                var weights = new double[] { 0.01, 0.1 };
                
                var remez = new Remez(order, freqs, response, weights);
                
                var kernel = remez.Design();
                
                // We can monitor the following properties:
            
                remez.Iterations
                remez.ExtremalFrequencies
                remez.InterpolatedResponse
                remez.Error
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.Order">
            <summary>
            Filter order
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.Iterations">
            <summary>
            Number of iterations
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.K">
            <summary>
            Number of extremal frequencies (K = Order/2 + 2)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.InterpolatedResponse">
            <summary>
            Interpolated frequency response
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.Error">
            <summary>
            Array of errors
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.ExtremalFrequencies">
            <summary>
            Extremal frequencies
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.Tolerance">
            <summary>
            Tolerance (for computing denominators)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez._extrs">
            <summary>
            Indices of extremal frequencies in the grid
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez._grid">
            <summary>
            Grid
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez._freqs">
            <summary>
            Band edge frequencies
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez._desired">
            <summary>
            Desired frequency response on entire grid
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez._weights">
            <summary>
            Weights on entire grid
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez._points">
            <summary>
            Points for interpolation
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez._gammas">
            <summary>
            Gamma coefficients used in Lagrange interpolation
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez._cosTable">
            <summary>
            Precomputed cosines
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.#ctor(System.Int32,System.Double[],System.Double[],System.Double[],System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="order"></param>
            <param name="freqs"></param>
            <param name="desired"></param>
            <param name="weights"></param>
            <param name="gridDensity"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.MakeGrid(System.Double[],System.Double[],System.Int32)">
            <summary>
            Make grid (uniform in each band)
            </summary>
            <param name="gridDensity"></param>
            <param name="desired"></param>
            <param name="weights"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.InitExtrema">
            <summary>
            Uniform initialization of extremal frequencies
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.Design(System.Int32)">
            <summary>
            Design optimal equiripple filter
            </summary>
            <param name="maxIterations">Max number of iterations</param>
            <returns>Filter kernel</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.UpdateCoefficients">
            <summary>
            Update gamma coefficients, interpolation points and delta
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.ImpulseResponse">
            <summary>
            Reconstruct Импульсивный ответ from interpolated frequency response
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.Gamma(System.Int32)">
            <summary>
            Compute gamma coefficient
            </summary>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.Lagrange(System.Double)">
            <summary>
            Barycentric Lagrange interpolation
            </summary>
            <param name="freq"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.DbToPassbandWeight(System.Double)">
            <summary>
            Convert ripple decibel value to passband weight
            </summary>
            <param name="db"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.DbToStopbandWeight(System.Double)">
            <summary>
            Convert ripple decibel value to stopband weight
            </summary>
            <param name="db"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.EstimateOrder(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Estimate LP filter order according to [Herrman et al., 1973].
            Section 8.2.7 in Proakis Manolakis book.
            </summary>
            <param name="fp"></param>
            <param name="fa"></param>
            <param name="dp"></param>
            <param name="da"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.Remez.EstimateOrder(System.Double[],System.Double[])">
            <summary>
            Estimate order of a filter with custom bands.
            
            Parameters are give in conventional format. For example:
            
            freqs: { 0, 0.2, 0.22, 0.32, 0.33, 0.5 }
            deltas: { 0.01, 0.1, 0.06 }
            
            </summary>
            <param name="freqs"></param>
            <param name="deltas"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper">
            <summary>
            Vocal Tract Length Normalization (VTLN) similar to Kaldi implementation
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper._lowFreq">
            <summary>
            Lower frequency
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper._highFreq">
            <summary>
            Upper frequency
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper._lowVtln">
            <summary>
            Lower frequency for VTLN
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper._highVtln">
            <summary>
            Upper frequency for VTLN
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper._scale">
            <summary>
            Some intermediate parameters for calculations
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="alpha">Warping factor</param>
            <param name="lowFreq">Lower frequency</param>
            <param name="highFreq">Upper frequency</param>
            <param name="lowVtln">Lower frequency for VTLN</param>
            <param name="highVtln">Upper frequency for VTLN</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Fda.VtlnWarper.Warp(System.Double)">
            <summary>
            Warp frequency
            </summary>
            <param name="freq">Frequency</param>
            <returns>Warped frequency</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.HilbertFilter">
            <summary>
            Hilbert filter
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.HilbertFilter.Size">
            <summary>
            Размер фильтра
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.HilbertFilter.#ctor(System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="size">size of the filter</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.HilbertFilter.MakeKernel(System.Int32)">
            <summary>
            Генератор ядра
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.MedianFilter">
            <summary>
            Nonlinear median filter
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.MedianFilter.Size">
            <summary>
            The size of median filter
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MedianFilter.#ctor(System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MedianFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Method implements median filtering algorithm
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MedianFilter.Process(System.Single)">
            <summary>
            Онлайн-фильтрация (отсчет за отсчетом)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MedianFilter.Reset">
            <summary>
            Перезапуск фильтра
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.MovingAverageFilter">
            <summary>
            Class providing non-recursive implementation of N-sample MA filter.
            
            Actually MA filter belongs to FIR filters (so it's inherited from FirFilter);
            however it can be realized also (and more efficiently) as a recursive filter (see below).
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.MovingAverageFilter.Size">
            <summary>
            Размер фильтра: number of samples for averaging
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MovingAverageFilter.#ctor(System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="size">size of the filter</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MovingAverageFilter.MakeKernel(System.Int32)">
            <summary>
            Генератор ядра
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.MovingAverageRecursiveFilter">
            <summary>
            Class providing recursive implementation of N-sample MA filter:
            
                y[n] = x[n] / N - x[n - N] / N + y[n - 1]
            
            i.e. 
                B = [1/N, 0, 0, 0, 0, ... , 0, -1/N]
                A = [1, -1]
            
            </summary>
            
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.MovingAverageRecursiveFilter.Size">
            <summary>
            Размер фильтра: number of samples for averaging
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.MovingAverageRecursiveFilter._out1">
            <summary>
            Линия задержки
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MovingAverageRecursiveFilter.#ctor(System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="size">size of the filter</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MovingAverageRecursiveFilter.MakeNumerator(System.Int32)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MovingAverageRecursiveFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Применить фильтр by fast recursive strategy
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MovingAverageRecursiveFilter.Process(System.Single)">
            <summary>
            Онлайн-фильтрация (отсчет за отсчетом)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.MovingAverageRecursiveFilter.Reset">
            <summary>
            Перезапуск фильтра
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.OnePole.HighPassFilter">
            <summary>
            Класс для полюсно-нулевого фильтра верхних частот
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.OnePole.HighPassFilter.Freq">
            <summary>
            Частота
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.HighPassFilter.#ctor(System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.HighPassFilter.SetCoefficients(System.Double)">
            <summary>
            Установить коэффициенты фильтра
            </summary>
            <param name="freq"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.HighPassFilter.Change(System.Double)">
            <summary>
            Изменить параметры фильтра (с сохранением его состояния)
            </summary>
            <param name="freq"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.OnePole.LowPassFilter">
            <summary>
            Класс для полюсно-нулевого фильтра нижних частот
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.OnePole.LowPassFilter.Freq">
            <summary>
            Частота
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.LowPassFilter.#ctor(System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="freq"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.LowPassFilter.SetCoefficients(System.Double)">
            <summary>
            Установить коэффициенты фильтра
            </summary>
            <param name="freq"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.LowPassFilter.Change(System.Double)">
            <summary>
            Изменить параметры фильтра (с сохранением его состояния)
            </summary>
            <param name="freq"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.OnePole.OnePoleFilter">
            <summary>
            Базовый класс полюсно-нулевых фильтров
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.OnePole.OnePoleFilter._prev">
            <summary>
            Линия задержки
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.OnePoleFilter.#ctor">
            <summary>
            Конструктор
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.OnePoleFilter.#ctor(System.Double,System.Double)">
            <summary>
            Конструктор for user defined coefficients
            </summary>
            <param name="b"></param>
            <param name="a"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.OnePoleFilter.Process(System.Single)">
            <summary>
            Онлайн-фильтрация (отсчет за отсчетом)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.OnePole.OnePoleFilter.Reset">
            <summary>
            Перезапуск фильтра
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.Polyphase.PolyphaseSystem">
            <summary>
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Polyphase.PolyphaseSystem.Filters">
            <summary>
            Полифазный фильтр с передаточной функцией E(z^k).
            
            Пример:
            h = [1, 2, 3, 4, 3, 2, 1],  k = 3
            
            e0 = [1, 0, 0, 4, 0, 0, 1]
            e1 = [0, 2, 0, 0, 3, 0, 0]
            e2 = [0, 0, 3, 0, 0, 2, 0]
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.Polyphase.PolyphaseSystem.MultirateFilters">
            <summary>
            Полифазный фильтр с передаточной функцией E(z) используется для многоскоростной обработки.
            
            h = [1, 2, 3, 4, 3, 2, 1],  k = 3
            
            e0 = [1, 4, 1]
            e1 = [2, 3, 0]
            e2 = [3, 2, 0]
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Polyphase.PolyphaseSystem.#ctor(System.Double[],System.Int32,System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="kernel"></param>
            <param name="filterCount"></param>
            <param name="type">1 or 2</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Polyphase.PolyphaseSystem.Decimate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Полифазная (многоскоростная) децимация
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Polyphase.PolyphaseSystem.Interpolate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Polyphase interpolation (for type-II systems)
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Polyphase.PolyphaseSystem.Process(System.Single)">
            <summary>
            Online processing.
            Inefficient, but helps understanding how polyphase filters work
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Polyphase.PolyphaseSystem.Reset">
            <summary>
            Reset
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.Polyphase.PolyphaseSystem.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Оффлайн обработка
            </summary>
            <param name="signal"></param>
            <param name="method">Метод фильтрации</param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.PreEmphasisFilter">
            <summary>
            Standard pre-emphasis FIR filter
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.PreEmphasisFilter._prevSample">
            <summary>
            Линия задержки
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.PreEmphasisFilter.#ctor(System.Double,System.Boolean)">
            <summary>
            Конструктор computes simple 1st order kernel
            </summary>
            <param name="a">Pre-emphasis coefficient</param>
            <param name="normalize">Normalize freq response to unit gain</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.PreEmphasisFilter.Process(System.Single)">
            <summary>
            Онлайн-фильтрация (отсчет за отсчетом)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.PreEmphasisFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Фильтрация всего сигнала
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.PreEmphasisFilter.Reset">
            <summary>
            Reset
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.RastaFilter">
            <summary>
            RASTA filter (used for robust speech processing)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.RastaFilter.#ctor(System.Double)">
            <summary>
            Конструктор
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.SavitzkyGolayFilter">
            <summary>
            Savitzky-Golay filter
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Filters.SavitzkyGolayFilter.Size">
            <summary>
            Size
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.SavitzkyGolayFilter.#ctor(System.Int32,System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="size">Размер фильтра, window length (must be odd number)</param>
            <param name="deriv"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.SavitzkyGolayFilter.MakeKernel(System.Int32,System.Int32)">
            <summary>
            Генератор ядра.
            It simply gives coefficient from precomputed arrays
            </summary>
            <param name="size"></param>
            <param name="deriv"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.ThiranFilter">
            <summary>
            N-th order Thiran allpass interpolation filter for delay 'Delta' (samples)
            
            N = 13
            Delta = 13 + 0.4
            
            https://ccrma.stanford.edu/~jos/pasp/Thiran_Allpass_Interpolators.html
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ThiranFilter.#ctor(System.Int32,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="order"></param>
            <param name="delta"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ThiranFilter.MakeTf(System.Int32,System.Double)">
            <summary>
            Создание передаточной функции
            </summary>
            <param name="order"></param>
            <param name="delta"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.ThiranFilter.ThiranCoefficient(System.Int32,System.Int32,System.Double)">
            <summary>
            k-th coefficient in TF denominator
            </summary>
            <param name="k"></param>
            <param name="n"></param>
            <param name="delta"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Filters.WienerFilter">
            <summary>
            Фильтр Винера
            Реализация идентична scipy.signal.wiener().
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.WienerFilter._size">
            <summary>
            Размер фильтра Винера
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Filters.WienerFilter._noise">
            <summary>
            Расчетная мощность шума
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.WienerFilter.#ctor(System.Int32,System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="size"></param>
            <param name="noise"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.WienerFilter.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.WienerFilter.Process(System.Single)">
            <summary>
            
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Filters.WienerFilter.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Convolution.ComplexConvolver">
            <summary>
            Class responsible for complex-valued convolution.
            
            ComplexConvolver does not participate in heavy calculations,
            so it does not contain Внутренние буферы.
            
            Memory is allocated for each operation ad-hoc.
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.ComplexConvolver.Convolve(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Int32)">
            <summary>
            Fast convolution via FFT for general complex-valued case
            </summary>
            <param name="signal"></param>
            <param name="kernel"></param>
            <param name="fftSize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.ComplexConvolver.CrossCorrelate(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Int32)">
            <summary>
            Fast cross-correlation via FFT
            </summary>
            <param name="signal"></param>
            <param name="kernel"></param>
            <param name="fftSize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.ComplexConvolver.Deconvolve(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Int32)">
            <summary>
            Fast deconvolution via FFT for general complex-valued case.
             
            NOTE!
            
            Deconvolution is an experimental feature.
            It's problematic due to division by zero.
            
            </summary>
            <param name="signal"></param>
            <param name="kernel"></param>
            <param name="fftSize"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Convolution.Convolver">
            <summary>
            Class responsible for real-valued convolution
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.Convolver._fftSize">
            <summary>
            Размер блока (число отсчетов) для преобразования Фурье
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.Convolver._fft">
            <summary>
            Метод вычисления БПФ
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.Convolver.#ctor(System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="fftSize">FFT size</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.Convolver.PrepareMemory(System.Int32)">
            <summary>
            Prepare all necessary arrays for calculations
            </summary>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.Convolver.Convolve(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Свертка
            </summary>
            <param name="signal">Signal of length N</param>
            <param name="kernel">Kernel of length M</param>
            <returns>Convolution signal of length N + M - 1</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.Convolver.Convolve(System.Single[],System.Single[],System.Single[])">
            <summary>
            Fast convolution via FFT for arrays of samples (maximally in-place).
            This version is best suited for block processing when memory needs to be reused.
            Input arrays must have size equal to the Размер блока БПФ.
            Размер блока (число отсчетов) для преобразования Фурье MUST be set properly in constructor!
            </summary>
            <param name="input">Real parts of the 1st signal (zero-padded)</param>
            <param name="kernel">Real parts of the 2nd signal (zero-padded)</param>
            <param name="output">Real parts of resulting convolution (zero-padded)</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.Convolver.CrossCorrelate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Fast cross-correlation via FFT
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.Convolver.CrossCorrelate(System.Single[],System.Single[],System.Single[])">
            <summary>
            Fast cross-correlation via FFT for arrays of samples (maximally in-place).
            This version is best suited for block processing when memory needs to be reused.
            Input arrays must have size equal to the Размер блока БПФ.
            Размер блока (число отсчетов) для преобразования Фурье MUST be set properly in constructor!
            </summary>
            <param name="input1">Real parts of the 1st signal (zero-padded)</param>
            <param name="input2">Real parts of the 2nd signal (zero-padded)</param>
            <param name="output">Real parts of resulting cross-correlation (zero-padded if center == 0)</param>
            (if it is set then resulting array has length of CENTER
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver">
            <summary>
            Class responsible for OLA block convolution.
            It can be used as a filter (online filter as well).
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver._kernel">
            <summary>
            Ядро фильтра
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver._fftSize">
            <summary>
            Размер блока (число отсчетов) для преобразования Фурье
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver._fft">
            <summary>
            Метод вычисления БПФ
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver._bufferOffset">
            <summary>
            Смещение входа в линии задержки
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver._outputBufferOffset">
            <summary>
            Смещение в линии задержки
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver._kernelSpectrumRe">
            <summary>
            Внутренние буферы
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver.HopSize">
            <summary>
            Hop size
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver.#ctor(System.Collections.Generic.IEnumerable{System.Single},System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="kernel"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="kernel"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver.FromFilter(AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter,System.Int32)">
            <summary>
            Construct BlockConvolver from a specific FIR filter
            </summary>
            <param name="filter"></param>
            <param name="fftSize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver.Process(System.Single)">
            <summary>
            OLA Онлайн-фильтрация (отсчет за отсчетом)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver.ProcessFrame">
            <summary>
            Process one frame (block)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Offline OLA filtering
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver.Reset">
            <summary>
            Перезапуск фильтра internals
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64">
            <summary>
            Class responsible for OLA block convolution (double precision).
            It can be used as a filter (online filter as well).
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64._kernel">
            <summary>
            Ядро фильтра
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64._fftSize">
            <summary>
            Размер блока (число отсчетов) для преобразования Фурье
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64._fft">
            <summary>
            Метод вычисления БПФ
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64._bufferOffset">
            <summary>
            Смещение входа в линии задержки
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64._outputBufferOffset">
            <summary>
            Смещение в линии задержки
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64._kernelSpectrumRe">
            <summary>
            Внутренние буферы
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64.HopSize">
            <summary>
            Hop size
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="kernel"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64.FromFilter(AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64,System.Int32)">
            <summary>
            Construct BlockConvolver from a specific FIR filter
            </summary>
            <param name="filter"></param>
            <param name="fftSize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64.Process(System.Double)">
            <summary>
            OLA Онлайн-фильтрация (отсчет за отсчетом)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64.ProcessFrame">
            <summary>
            Process one frame (block)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64.ApplyTo(System.Double[],AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Offline OLA filtering
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlaBlockConvolver64.Reset">
            <summary>
            Перезапуск фильтра internals
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver">
            <summary>
            Class responsible for OLS block convolution.
            It can be used as a filter (online filter as well).
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver._kernel">
            <summary>
            Ядро фильтра
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver._fftSize">
            <summary>
            Размер блока (число отсчетов) для преобразования Фурье
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver._fft">
            <summary>
            Метод вычисления БПФ
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver._bufferOffset">
            <summary>
            Смещение в линии задержки
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver._outputBufferOffset">
            <summary>
            Смещение в линии задержки
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver._kernelSpectrumRe">
            <summary>
            Внутренние буферы
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver.HopSize">
            <summary>
            Hop size
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver.#ctor(System.Collections.Generic.IEnumerable{System.Single},System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="kernel"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="kernel"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver.FromFilter(AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter,System.Int32)">
            <summary>
            Construct BlockConvolver from a specific FIR filter
            </summary>
            <param name="filter"></param>
            <param name="fftSize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver.Process(System.Single)">
            <summary>
            OLS Онлайн-фильтрация (отсчет за отсчетом)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver.ProcessFrame">
            <summary>
            Process one frame (block)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Offline OLS filtering
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver.Reset">
            <summary>
            Перезапуск фильтра internals
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64">
            <summary>
            Class responsible for OLS block convolution (double precision).
            It can be used as a filter (online filter as well).
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64._kernel">
            <summary>
            Ядро фильтра
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64._fftSize">
            <summary>
            Размер блока (число отсчетов) для преобразования Фурье
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64._fft">
            <summary>
            Метод вычисления БПФ
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64._bufferOffset">
            <summary>
            Смещение в линии задержки
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64._outputBufferOffset">
            <summary>
            Смещение в линии задержки
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64._kernelSpectrumRe">
            <summary>
            Внутренние буферы
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64.HopSize">
            <summary>
            Hop size
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="kernel"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64.FromFilter(AI.BackEnds.DSP.NWaves.Filters.Base64.FirFilter64,System.Int32)">
            <summary>
            Construct BlockConvolver from a specific FIR filter
            </summary>
            <param name="filter"></param>
            <param name="fftSize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64.Process(System.Double)">
            <summary>
            OLS Онлайн-фильтрация (отсчет за отсчетом)
            </summary>
            <param name="sample"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64.ProcessFrame">
            <summary>
            Process one frame (block)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64.ApplyTo(System.Double[],AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Offline OLS filtering
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Convolution.OlsBlockConvolver64.Reset">
            <summary>
            Перезапуск фильтра internals
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower">
            <summary>
            Огибающая (detector)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower._attackTime">
            <summary>
            Время атаки
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower.AttackTime">
            <summary>
            
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower._releaseTime">
            <summary>
            Release time
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower.ReleaseTime">
            <summary>
            
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower._env">
            <summary>
            Current envelope sample
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower._ga">
            <summary>
            Attack coefficient
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower._gr">
            <summary>
            Release coefficient
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower._fs">
            <summary>
            Частота дискретизации
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower.#ctor(System.Int32,System.Single,System.Single)">
            <summary>
            Конструктор
            </summary>
            <param name="samplingRate"></param>
            <param name="attackTime"></param>
            <param name="releaseTime"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower.Process(System.Single)">
            <summary>
            Envelope following is essentialy a Фильтр нижних частот filtering
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.EnvelopeFollower.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.GriffinLimReconstructor">
            <summary>
            Class for reconstructing signal from a given power / magnitude spectrogram
            based on Griffin-Lim iterative algorithm.
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.GriffinLimReconstructor._stft">
            <summary>
            STFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.GriffinLimReconstructor._magnitudes">
            <summary>
            Magnitude part of the spectrogram
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.GriffinLimReconstructor.#ctor(System.Collections.Generic.List{System.Single[]},AI.BackEnds.DSP.NWaves.Transforms.Stft,System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="spectrogram"></param>
            <param name="stft"></param>
            <param name="power"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.GriffinLimReconstructor.Iterate(System.Single[])">
            <summary>
            One iteration of reconstruction
            </summary>
            <param name="signal">Signal reconstructed at previous iteration</param>
            <returns>Reconstructed signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.GriffinLimReconstructor.Reconstruct(System.Int32)">
            <summary>
            Reconstruct iteratively
            </summary>
            <param name="iterations"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.HarmonicPercussiveSeparator">
            <summary>
            HPS based on median filtering.
            
            D.Fitzgerald. Harmonic/percussive separation using median filtering.
            13th International Conference on Digital Audio Effects (DAFX10), Graz, Austria, 2010.
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.HarmonicPercussiveSeparator._stft">
            <summary>
            Internal STFT transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.HarmonicPercussiveSeparator._mask">
            <summary>
            Masking function
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.HarmonicPercussiveSeparator._medianHarmonic">
            <summary>
            Median filter for time axis
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.HarmonicPercussiveSeparator._medianPercussive">
            <summary>
            Median filter for frequency axis
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.HarmonicPercussiveSeparator.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,AI.BackEnds.DSP.NWaves.Operations.HpsMasking)">
            <summary>
            Конструктор
            </summary>
            <param name="fftSize"></param>
            <param name="hopSize"></param>
            <param name="harmonicWinSize"></param>
            <param name="percussiveWinSize"></param>
            <param name="masking"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.HarmonicPercussiveSeparator.EvaluateSpectrograms(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Evaluate harmonic and percussive mag-phase spectrograms from given signal.
            Both spectrogram objects share the same phase array.
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.HarmonicPercussiveSeparator.EvaluateSignals(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Evaluate harmonic and percussive signals from given signal
            </summary>
            <param name="signal"></param>
            <returns>Harmonic signal and percussive signal</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.HpsMasking">
            <summary>
            Masking mode for HPS algorithm
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.HpsMasking.Binary">
            <summary>
            
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.HpsMasking.WienerOrder1">
            <summary>
            
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.HpsMasking.WienerOrder2">
            <summary>
            
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Modulator">
            <summary>
             Class providing modulation methods:
            
                - ring
                - amplitude
                - frequency
                - phase
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Modulator.Ring(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Ring modulation (RM)
            </summary>
            <param name="carrier">Carrier signal</param>
            <param name="modulator">Modulator signal</param>
            <returns>RM signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Modulator.Amplitude(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single,System.Single)">
            <summary>
            Амплитудная модуляция (AM)
            </summary>
            <param name="carrier">Carrier signal</param>
            <param name="modulatorFrequency">Modulator frequency</param>
            <param name="modulationIndex">Modulation index (depth)</param>
            <returns>AM signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Modulator.Frequency(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single,System.Single,System.Single)">
            <summary>
            Частота modulation (FM)
            </summary>
            <param name="baseband">Baseband signal</param>
            <param name="carrierAmplitude">Carrier amplitude</param>
            <param name="carrierFrequency">Несущая частота</param>
            <param name="deviation">Frequency deviation</param>
            <returns>RM signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Modulator.FrequencySinusoidal(System.Single,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Sinusoidal frequency modulation (FM)
            </summary>
            <param name="carrierFrequency">Carrier signal frequency</param>
            <param name="carrierAmplitude">Carrier signal amplitude</param>
            <param name="modulatorFrequency">Modulator frequency</param>
            <param name="modulationIndex">Modulation index (depth)</param>
            <param name="length">Length of FM signal</param>
            <param name="samplingRate">Частота дискретизации</param>
            <returns>Sinusoidal FM signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Modulator.FrequencyLinear(System.Single,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Linear frequency modulation (FM)
            </summary>
            <param name="carrierFrequency">Carrier signal frequency</param>
            <param name="carrierAmplitude">Carrier signal amplitude</param>
            <param name="modulationIndex">Modulation index (depth)</param>
            <param name="length">Length of FM signal</param>
            <param name="samplingRate">Частота дискретизации</param>
            <returns>Sinusoidal FM signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Modulator.Phase(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single,System.Single,System.Single)">
            <summary>
            Phase modulation (PM)
            </summary>
            <param name="baseband">Baseband signal</param>
            <param name="carrierAmplitude">Carrier amplitude</param>
            <param name="carrierFrequency">Несущая частота</param>
            <param name="deviation">Frequency deviation</param>
            <returns>RM signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Modulator.DemodulateAmplitude(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Simple amplitude demodulation based on Hilbert transform
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Modulator.DemodulateFrequency(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Simple frequency demodulation based on Hilbert transform
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Operation">
            <summary>
            Main operations implemented:
            
                - convolution
                - cross-correlation
                - block convolution
                - deconvolution
                - resampling
                - time-stretching
                - rectification
                - envelope detection
                - spectral Вычитание
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.Convolve(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Fast convolution via FFT of real-valued signals.
            </summary>
            <param name="signal"></param>
            <param name="kernel"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.Convolve(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            Fast convolution via FFT for general complex-valued case
            </summary>
            <param name="signal"></param>
            <param name="kernel"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.Convolve(System.Double[],System.Double[])">
            <summary>
            Fast convolution for double arrays (used mainly in filter design)
            </summary>
            <param name="input"></param>
            <param name="kernel"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.CrossCorrelate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Fast cross-correlation via FFT
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.CrossCorrelate(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            Fast complex cross-correlation via FFT
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.BlockConvolve(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Method implements block convolution of signals (using either OLA or OLS алгоритм)
            </summary>
            <param name="signal"></param>
            <param name="kernel"></param>
            <param name="fftSize"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.Deconvolve(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            Deconvolution via FFT for general complex-valued case.
             
            NOTE!
            
            Deconvolution is an experimental feature.
            It's problematic due to division by zero.
            
            </summary>
            <param name="signal">Сигнал</param>
            <param name="kernel">Kernel</param>
            <returns>Deconvolved signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.Interpolate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter)">
            <summary>
            Interpolation followed by Фильтр нижних частот filtering
            </summary>
            <param name="signal"></param>
            <param name="factor"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.Decimate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter)">
            <summary>
            Decimation preceded by Фильтр нижних частот filtering
            </summary>
            <param name="signal"></param>
            <param name="factor"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.Resample(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter)">
            <summary>
            Band-limited resampling
            </summary>
            <param name="signal"></param>
            <param name="newSamplingRate"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.ResampleUpDown(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32)">
            <summary>
            Simple resampling (as the combination of interpolation and decimation)
            </summary>
            <param name="signal"></param>
            <param name="up"></param>
            <param name="down"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.TimeStretch(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Double,System.Int32,System.Int32,AI.BackEnds.DSP.NWaves.Operations.Tsm.TsmAlgorithm)">
            <summary>
            Time stretching with parameters set by user
            </summary>
            <param name="signal">Сигнал</param>
            <param name="stretch">Stretch factor (ratio)</param>
            <param name="windowSize">Window size (for vocoders - FFT size)</param>
            <param name="hopSize">Hop size</param>
            <param name="algorithm">Algorithm for TSM (optional)</param>
            <returns>Time stretched signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.TimeStretch(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Double,AI.BackEnds.DSP.NWaves.Operations.Tsm.TsmAlgorithm)">
            <summary>
            Time stretching with auto-derived parameters
            </summary>
            <param name="signal">Сигнал</param>
            <param name="stretch">Stretch factor (ratio)</param>
            <param name="algorithm">Algorithm for TSM (optional)</param>
            <returns>Time stretched signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.Envelope(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single,System.Single)">
            <summary>
            Method for extracting the envelope of a signal
            </summary>
            <param name="signal">Сигнал</param>
            <param name="attackTime"></param>
            <param name="releaseTime"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.FullRectify(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Full rectification
            </summary>
            <param name="signal">Сигнал</param>
            <returns>Fully rectified signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.HalfRectify(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Half rectification
            </summary>
            <param name="signal">Сигнал</param>
            <returns>Half rectified signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.SpectralSubtract(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32)">
            <summary>
            Spectral Вычитание
            </summary>
            <param name="signal"></param>
            <param name="noise"></param>
            <param name="fftSize"></param>
            <param name="hopSize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.ConvolveDirect(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Direct convolution by formula in time domain
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Operation.CrossCorrelateDirect(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Direct cross-correlation by formula in time domain
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Resampler">
            <summary>
            Class responsible for Частота дискретизации conversion
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Resampler.MinResamplingFilterOrder">
            <summary>
            The order of FIR LP resampling filter (minimally required).
            This constant should be used for simple up/down ratios.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Resampler.Interpolate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter)">
            <summary>
            Interpolation followed by Фильтр нижних частот filtering
            </summary>
            <param name="signal"></param>
            <param name="factor"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Resampler.Decimate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter)">
            <summary>
            Decimation preceded by Фильтр нижних частот filtering
            </summary>
            <param name="signal"></param>
            <param name="factor"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Resampler.Resample(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter,System.Int32)">
            <summary>
            Band-limited resampling
            </summary>
            <param name="signal"></param>
            <param name="newSamplingRate"></param>
            <param name="filter"></param>
            <param name="order"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Resampler.ResampleUpDown(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32,AI.BackEnds.DSP.NWaves.Filters.Base.FirFilter)">
            <summary>
            Simple resampling as the combination of interpolation and decimation.
            </summary>
            <param name="signal"></param>
            <param name="up"></param>
            <param name="down"></param>
            <param name="filter"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor">
            <summary>
            Class that implements Spectral Вычитание algorithm according to
            
            [1979] M. Berouti, R. Schwartz, J. Makhoul
            "Enhancement of Speech Corrupted by Acoustic Noise".
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor.Beta">
            <summary>
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor.AlphaMin">
            <summary>
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor.AlphaMax">
            <summary>
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor.SnrMin">
            <summary>
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor.SnrMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor._noiseEstimate">
            <summary>
            Noise estimate
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor.#ctor(System.Single[],System.Int32,System.Int32)">
            <summary>
            Конструктор from float[] noise
            </summary>
            <param name="noise"></param>
            <param name="fftSize"></param>
            <param name="hopSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor.#ctor(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32)">
            <summary>
            Конструктор from DiscreteSignal noise
            </summary>
            <param name="noise"></param>
            <param name="fftSize"></param>
            <param name="hopSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor.ProcessSpectrum(System.Single[],System.Single[],System.Single[],System.Single[])">
            <summary>
            Обработка одного спектра на каждом шаге STFT
            </summary>
            <param name="re">Реальная часть спектра</param>
            <param name="im">Мнимая часть входного спектра</param>
            <param name="filteredRe">Реальная часть выходного спектра</param>
            <param name="filteredIm">Мнимая часть выходного спектра</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor.EstimateNoise(System.Single[],System.Int32,System.Int32)">
            <summary>
            Estimate noise power spectrum
            </summary>
            <param name="noise"></param>
            <param name="startPos"></param>
            <param name="endPos"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.SpectralSubtractor.EstimateNoise(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32,System.Int32)">
            <summary>
            Estimate noise power spectrum
            </summary>
            <param name="noise"></param>
            <param name="startPos"></param>
            <param name="endPos"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Tsm.PaulStretch">
            <summary>
            TSM processor based on Paul stretch algorithm
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PaulStretch._rand">
            <summary>
            Рандомизатор для фаз
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.PaulStretch.#ctor(System.Double,System.Int32,System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="stretch"></param>
            <param name="hopAnalysis"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.PaulStretch.ProcessSpectrum">
            <summary>
            Process spectrum at each STFT step: simply randomize phases
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.PaulStretch.Reset">
            <summary>
            Reset (nothing to do here)
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseLockingVocoder">
            <summary>
            Фазовый вокодер с идентификацией фазы [Puckette].
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseLockingVocoder._mag">
            <summary>
            Массив значений спектра (на текущем шаге)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseLockingVocoder._phase">
            <summary>
            Массив фаз спектра (на текущем шаге)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseLockingVocoder._delta">
            <summary>
            Массив фазовых дельт
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseLockingVocoder._peaks">
            <summary>
            Массив пиковых позиций (индексов)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseLockingVocoder.#ctor(System.Double,System.Int32,System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="stretch"></param>
            <param name="hopAnalysis"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseLockingVocoder.ProcessSpectrum">
            <summary>
            Спектр процесса с фазовой синхронизацией на каждом шаге STFT
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder">
            <summary>
            Обычный фазовый вокодер
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._hopAnalysis">
            <summary>
            Размер прыжка на этапе анализа (разложение STFT)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._hopSynthesis">
            <summary>
            Размер прыжка на этапе анализа (объединение STFT)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._fftSize">
            <summary>
            Размер блока БПФ для анализа и синтеза
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._stretch">
            <summary>
            Коэффициент растяжения
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._fft">
            <summary>
            Внутренний алгоритм для выполнения БПФ
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._window">
             <summary>
            Весовое окно
             </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._gain">
            <summary>
            Коэффициент нормализации ISTFT
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._omega">
            <summary>
            Линейно разнесенные частоты
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._re">
            <summary>
            Внутренний буфер для реальных частей анализируемого блока
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._im">
            <summary>
            Внутренний буфер для мнимых частей анализируемого блока
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._prevPhase">
            <summary>
            Массив фаз, вычисленный на предыдущем шаге
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder._phaseTotal">
            <summary>
            Массив новых синтезированных фаз
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder.#ctor(System.Double,System.Int32,System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="stretch"></param>
            <param name="hopAnalysis"></param>
            <param name="fftSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            Алгоритм фазового вокодера
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder.ProcessSpectrum">
            <summary>
            Обработка одного спектра на каждом шаге STFT.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.PhaseVocoder.Reset">
            <summary>
            Перезапуск фазового вокодера
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Tsm.TsmAlgorithm">
            <summary>
            Algorithm for time scale modification
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.TsmAlgorithm.PhaseVocoder">
            <summary>
            Phase vocoder
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.TsmAlgorithm.PhaseVocoderPhaseLocking">
            <summary>
            Phase vocoder with phase-locking
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.TsmAlgorithm.Wsola">
            <summary>
            Waveform similarity-based Synchrnoized Overlap-Add
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.TsmAlgorithm.PaulStretch">
            <summary>
            Paul stretch
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola">
            <summary>
            Добавление синхронизированного перекрытия сигнала
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola._stretch">
            <summary>
            Коэффициент растяжения
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola._windowSize">
            <summary>
            Window size
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola._hopAnalysis">
            <summary>
            Размер прыжка на этапе анализа (разложение STFT)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola._hopSynthesis">
            <summary>
            Размер прыжка на этапе анализа (объединение STFT)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola._maxDelta">
            <summary>
            Максимальная длина фрагмента для поиска наиболее похожего сигнала
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola._userParameters">
            <summary>
            Истинно, если параметры были установлены пользователем (не по умолчанию)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola._convolver">
            <summary>
            Внутренний алгоритм свертки
            (будет использоваться для оценки автокорреляции слишком большого размера окна)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola._cc">
            <summary>
            Сигнал взаимной корреляции
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola.#ctor(System.Double,System.Int32,System.Int32,System.Int32)">
            <summary>
            Добавление синхронизированного перекрытия сигнала
            </summary>
            <param name="stretch">Коэффициент растяжения</param>
            <param name="windowSize"></param>
            <param name="hopAnalysis"></param>
            <param name="maxDelta"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola.#ctor(System.Double)">
            <summary>
            Добавление синхронизированного перекрытия сигнала
            </summary>
            <param name="stretch"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola.PrepareConvolver">
            <summary>
            Для больших размеров окна подготовливает внутренний алгоритм свертки
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola.ApplyTo(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Filters.Base.FilteringMethod)">
            <summary>
            WSOLA algorithm
            </summary>
            <param name="signal"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Operations.Tsm.Wsola.WaveformSimilarityPos(System.Single[],System.Single[],System.Int32)">
            <summary>
            Положение наилучшего найденного подобия сигнала
            </summary>
            <param name="current"></param>
            <param name="prev"></param>
            <param name="maxDelta"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal">
            <summary>
            Base class for finite complex-valued discrete-time signals.
            
            Any finite complex DT signal is stored as two arrays of data (real parts and imaginary parts)
            sampled at certain Частота дискретизации.
            
            See also ComplexDiscreteSignalExtensions for additional functionality of complex DT signals.
            
            Note.
            1) I intentionally do not implement reusable code mechanisms (like generics or inheritance) 
               for coding DiscreteSignals and ComplexDiscreteSignals. Also for better performance 
               I did not use Complex type (instead we just work with 2 plain arrays).
               The reason is that currently ComplexDiscreteSignal is more like a helper class used in DSP internals.
               For all tasks users will most likely use real-valued DiscreteSignal or simply an array of samples.
               However they can switch between complex and real-valued signals anytime.
            
            2) Method implementations are LINQ-less for better performance.
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.SamplingRate">
            <summary>
            Number of samples per unit of time (1 second)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.Real">
            <summary>
            Array or real parts of samples
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.Imag">
            <summary>
            Array or imaginary parts of samples
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.Length">
            <summary>
            Length of the signal
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.#ctor(System.Int32,System.Double[],System.Double[],System.Boolean)">
            <summary>
            The most efficient constructor for initializing complex signals
            </summary>
            <param name="samplingRate">Частота дискретизации of the signal</param>
            <param name="real">Array of real parts of the complex-valued signal</param>
            <param name="imag">Array of imaginary parts of the complex-valued signal</param>
            <param name="allocateNew">Set to true if new memory should be allocated for data</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Конструктор for initializing complex signals with any float enumerables
            </summary>
            <param name="samplingRate"></param>
            <param name="real"></param>
            <param name="imag"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.#ctor(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Конструктор creates the complex signal of specified length filled with specified values
            </summary>
            <param name="samplingRate"></param>
            <param name="length"></param>
            <param name="real"></param>
            <param name="imag"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Int32},System.Double)">
            <summary>
            Конструктор for initializing complex signals with any integer enumerables
            </summary>
            <param name="samplingRate"></param>
            <param name="samples"></param>
            <param name="normalizeFactor"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.Copy">
            <summary>
            Method for creating the deep copy of a complex signal
            </summary>
            <returns>New copied signal</returns>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.Item(System.Int32)">
            <summary>
            Indexer works only with array of real parts of samples. Use it with caution.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.Item(System.Int32,System.Int32)">
            <summary>
            Slice the signal (Python-style)
            
                var middle = signal[900, 1200];
            
            Implementaion is LINQ-less, since Skip() would be less efficient:
                            
                return new DiscreteSignal(SamplingRate, 
                                          Real.Skip(startPos).Take(endPos - startPos),
                                          Imag.Skip(startPos).Take(endPos - startPos));
            </summary>
            <param name="startPos">Position of the first sample</param>
            <param name="endPos">Position of the last sample (exclusive)</param>
            <returns>Slice of the signal</returns>
            <exception>Overflow possible if endPos is less than startPos</exception>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.Magnitude">
            <summary>
            Get real-valued signal containing magnitudes of complex-valued samples
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.Power">
            <summary>
            Get real-valued signal containing squared magnitudes of complex-valued samples
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.Phase">
            <summary>
            Get real-valued signal containing phases of complex-valued samples
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.PhaseUnwrapped">
            <summary>
            Get unwrapped phase
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.op_Addition(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            Overloaded + (superimpose signals)
            </summary>
            <param name="s1">Left signal</param>
            <param name="s2">Right signal</param>
            <returns>Superimposed signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.op_Addition(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Double)">
            <summary>
            Overloaded + (add constant)
            </summary>
            <param name="s">Сигнал</param>
            <param name="constant">Constant to add to each sample</param>
            <returns>Modified signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.op_Subtraction(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Double)">
            <summary>
            Overloaded - (subtract constant)
            </summary>
            <param name="s">Сигнал</param>
            <param name="constant">Constant to subtract from each sample</param>
            <returns>Modified signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal.op_Multiply(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Single)">
            <summary>
            Overloaded * (signal amplification)
            </summary>
            <param name="s">Сигнал</param>
            <param name="coeff">Amplification coefficient</param>
            <returns>Amplified signal</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions">
            <summary>
            Any finite complex DT signal is simply two arrays of data (real and imaginary parts)
            sampled at certain Частота дискретизации.
            
            This arrays of samples can be:
                - delayed (shifted) by positive or negative number of samples
                - superimposed with another arrays of samples (another signal)
                - concatenated with another arrays of samples (another signal)
                - repeated N times
            
            Note.
            Method implementations are LINQ-less and do Buffer.BlockCopy() for better performance.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Delay(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Int32)">
            Method delays the signal
                either by shifting it to the right (positive, e.g. Delay(1000))
                    or by shifting it to the left (negative, e.g. Delay(-1000))
            <param name="signal"></param>
            <param name="delay"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Superimpose(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            Method superimposes two signals.
            If sizes are different then the smaller signal is broadcasted 
            to fit the size of the larger signal.
            </summary>
            <param name="signal1">Object signal</param>
            <param name="signal2">Argument signal</param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Concatenate(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            Method concatenates two signals.
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Repeat(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Int32)">
            <summary>
            Method returns repeated n times copy of the signal
            </summary>
            <param name="signal"></param>
            <param name="times"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Amplify(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Double)">
            <summary>
            In-place signal amplification by coeff
            </summary>
            <param name="signal"></param>
            <param name="coeff"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Attenuate(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Double)">
            <summary>
            In-place signal attenuation by coeff
            </summary>
            <param name="signal"></param>
            <param name="coeff"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.First(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Int32)">
            <summary>
            
            </summary>
            <param name="signal"></param>
            <param name="sampleCount"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Last(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Int32)">
            <summary>
            More or less efficient LINQ-less version.
            </summary>
            <param name="signal"></param>
            <param name="sampleCount"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.ZeroPadded(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,System.Int32)">
            <summary>
            Method creates new zero-padded complex discrete signal from the current signal.
            </summary>
            <param name="signal">Сигнал</param>
            <param name="newLength">The length of a zero-padded signal.
            By default array is zero-padded to have length of next power of 2.</param>
            <returns>Zero padded complex discrete signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Multiply(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            Method performs the complex multiplication of two signals
            (with normalization by length)
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Divide(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            Method performs the complex division of two signals
            (with normalization by length)
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Unwrap(System.Double[],System.Double)">
            <summary>
            Just another way for calling Unwrap() function
            </summary>
            <param name="phase"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Magnitude(System.Tuple{System.Single[],System.Single[]})">
            <summary>
            Magnitude of complex numbers given in tuple of float arrays (re and im)
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.Phase(System.Tuple{System.Single[],System.Single[]})">
            <summary>
            Phase of complex numbers given in tuple of float arrays (re and im)
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignalExtensions.ToComplexNumbers(AI.BackEnds.DSP.NWaves.Signals.ComplexDiscreteSignal)">
            <summary>
            
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal">
            <summary>
            Base class for finite real-valued discrete-time signals.
            
            In general, any finite DT signal is simply an array of data sampled at certain Частота дискретизации.
            
            See also DiscreteSignalExtensions for additional functionality of DT signals.
            
            Note. 
            Method implementations are LINQ-less for better performance.
            
            In the earliest versions of NWaves there was also an ISignal interface, however it was refactored out.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.SamplingRate">
            <summary>
            Number of samples per unit of time (1 second)
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Samples">
            <summary>
            Real-valued array of samples
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Length">
            <summary>
            Length of the signal
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Duration">
            <summary>
            Duration of the signal (in sec)
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.#ctor(System.Int32,System.Single[],System.Boolean)">
            <summary>
            The most efficient constructor for initializing discrete signals
            </summary>
            <param name="samplingRate">Частота дискретизации</param>
            <param name="samples">Array of samples</param>
            <param name="allocateNew">Set to true if new memory should be allocated for data</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Конструктор for creating a signal from collection of samples
            </summary>
            <param name="samplingRate">Частота дискретизации</param>
            <param name="samples">Collection of samples</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.#ctor(System.Int32,System.Int32,System.Single)">
            <summary>
            Конструктор for creating a signal of specified length filled with specified values
            </summary>
            <param name="samplingRate">Частота дискретизации</param>
            <param name="length">Number of samples</param>
            <param name="value">Value of each sample</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Int32},System.Single)">
            <summary>
            Конструктор for creating a signal from collection of integer samples
            </summary>
            <param name="samplingRate">Частота дискретизации</param>
            <param name="samples">Collection of integer samples</param>
            <param name="normalizeFactor">Some normalization coefficient</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Copy">
            <summary>
            Method for creating deep copy of the signal
            </summary>
            <returns>Copy of the signal</returns>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Item(System.Int32)">
            <summary>
            Sample indexer
            </summary>
            <param name="index">Индекс</param>
            <returns>Sample by index</returns>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Item(System.Int32,System.Int32)">
            <summary>
            Slice the signal (Python-style)
            
                var middle = signal[900, 1200];
            
            Implementaion is LINQ-less, since Skip() would be less efficient:
                return new DiscreteSignal(SamplingRate, Samples.Skip(startPos).Take(endPos - startPos));
            
            </summary>
            <param name="startPos"></param>
            <param name="endPos"></param>
            <returns>Slice of the signal</returns>
            <exception>Overflow possible if endPos is less than startPos</exception>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.op_Addition(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Overloaded binary plus (superimpose signals)
            </summary>
            <param name="s1">Left signal</param>
            <param name="s2">Right signal</param>
            <returns>Superimposed signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.op_UnaryNegation(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Overloaded unary minus (negated signal)
            </summary>
            <param name="s">Сигнал</param>
            <returns>Negated signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.op_Subtraction(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Overloaded binary minus (difference signal)
            </summary>
            <param name="s1">Left signal</param>
            <param name="s2">Right signal</param>
            <returns>Difference signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.op_Addition(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single)">
            <summary>
            Overloaded + (add constant)
            </summary>
            <param name="s">Сигнал</param>
            <param name="constant">Constant to add to each sample</param>
            <returns>Modified signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.op_Subtraction(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single)">
            <summary>
            Overloaded - (subtract constant)
            </summary>
            <param name="s">Сигнал</param>
            <param name="constant">Constant to subtract from each sample</param>
            <returns>Modified signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.op_Multiply(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single)">
            <summary>
            Overloaded * (signal amplification/attenuation)
            </summary>
            <param name="s">Сигнал</param>
            <param name="coeff">Amplification coefficient</param>
            <returns>Amplified signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Energy(System.Int32,System.Int32)">
            <summary>
            Energy of a signal fragment
            </summary>
            <param name="startPos">Starting sample</param>
            <param name="endPos">Ending sample (exclusive)</param>
            <returns>Energy</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Energy">
            <summary>
            Energy of entire signal
            </summary>
            <returns>Energy</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Rms(System.Int32,System.Int32)">
            <summary>
            RMS of a signal fragment
            </summary>
            <param name="startPos">Starting sample</param>
            <param name="endPos">Ending sample (exclusive)</param>
            <returns>RMS</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Rms">
            <summary>
            RMS of entire signal
            </summary>
            <returns>RMS</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.ZeroCrossingRate(System.Int32,System.Int32)">
            <summary>
            Zero-crossing rate of a signal fragment
            </summary>
            <param name="startPos">Starting sample</param>
            <param name="endPos">Ending sample (exclusive)</param>
            <returns>Zero-crossing rate</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.ZeroCrossingRate">
            <summary>
            Zero-crossing rate of entire signal
            </summary>
            <returns>Zero-crossing rate</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Entropy(System.Int32,System.Int32,System.Int32)">
            <summary>
            Shannon entropy of a signal fragment
            (computed from bins distributed uniformly between the minimum and maximum values of samples)
            </summary>
            <param name="startPos">Starting sample</param>
            <param name="endPos">Ending sample (exclusive)</param>
            <param name="binCount"></param>
            <returns>Shannon entropy</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal.Entropy">
            <summary>
            Entropy of entire signal
            </summary>
            <returns>Entropy</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions">
             <summary>
             In general, any finite DT signal is simply an array of data sampled at certain Частота дискретизации.
             
             This array of samples can be:
                 - delayed (shifted) by positive or negative number of samples
                 - superimposed with another array of samples (another signal)
                 - concatenated with another array of samples (another signal)
                 - repeated N times
                 - amplified
            
             Note.
             Method implementations are LINQ-less and do Buffer.BlockCopy() for better performance.
             </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.Delay(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32)">
            <summary>
            Method delays the signal
                either by shifting it to the right (positive, e.g. Delay(1000))
                    or by shifting it to the left (negative, e.g. Delay(-1000))
            </summary>
            <param name="signal"></param>
            <param name="delay"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.Superimpose(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Method superimposes two signals.
            If sizes are different then the smaller signal is broadcasted 
            to fit the size of the larger signal.
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.SuperimposeMany(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32[])">
            <summary>
            Method superimposes two signals.
            If sizes are different then the smaller signal is broadcasted 
            to fit the size of the larger signal.
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.Subtract(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Method subtracts one signal from another.
            If sizes are different then the smaller signal is broadcasted 
            to fit the size of the larger signal.
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.Concatenate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Method concatenates two signals.
            </summary>
            <param name="signal1"></param>
            <param name="signal2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.Repeat(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32)">
            <summary>
            Method returns repeated n times copy of the signal
            </summary>
            <param name="signal"></param>
            <param name="times"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.Amplify(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single)">
            <summary>
            In-place signal amplification by coeff
            </summary>
            <param name="signal"></param>
            <param name="coeff"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.Attenuate(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single)">
            <summary>
            In-place signal attenuation by coeff
            </summary>
            <param name="signal"></param>
            <param name="coeff"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.First(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32)">
            <summary>
            Return copy of first N samples
            </summary>
            <param name="signal">Сигнал</param>
            <param name="sampleCount">Number of samples</param>
            <returns>Copy of the first samples of signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.Last(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32)">
            <summary>
            More or less efficient LINQ-less version.
            Skip() would require unnecessary enumeration.
            </summary>
            <param name="signal"></param>
            <param name="sampleCount"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.FullRectify(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Full rectification (in-place)
            </summary>
            <param name="signal">Сигнал</param>
            <returns>Fully rectified signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.HalfRectify(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Half rectification (in-place)
            </summary>
            <param name="signal">Сигнал</param>
            <returns>Half rectified signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Signals.DiscreteSignalExtensions.ToComplex(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Method copies discrete signal samples into complex signal
            </summary>
            <param name="signal">Real-valued signal</param>
            <returns>Corresponding complex-valued signal</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform">
            <summary>
            Class providing methods for various cepstrum transforms:
            
                1) Complex cepstrum (direct and inverse)
                2) Real cepstrum
                3) Power cepstrum
                4) Phase cepstrum
                
            1) and 2) are analogous to MATLAB cceps/icceps and rceps, respectively.
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform.Size">
            <summary>
            Size of cepstrum
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform._fft">
            <summary>
            Метод вычисления БПФ
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform._logBase">
            <summary>
            Logarithm base (E or 10)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform._realSpectrum">
            <summary>
            Intermediate buffer storing real parts of spectrum
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform._imagSpectrum">
            <summary>
            Intermediate buffer storing imaginary parts of spectrum
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform._unwrapped">
            <summary>
            Intermediate buffer storing unwrapped phase
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
            Конструктор with necessary parameters
            </summary>
            <param name="cepstrumSize"></param>
            <param name="fftSize"></param>
            <param name="logBase"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform.Direct(System.Single[],System.Single[])">
            <summary>
            Direct complex cepstral transform:
            
            Real{IFFT(log(abs(FFT(x)) + unwrapped_phase))}
            
            </summary>
            <param name="input"></param>
            <param name="cepstrum"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform.Direct(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Direct complex cepstral transform
            </summary>
            <param name="signal"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform.Inverse(System.Single[],System.Single[],System.Double)">
            <summary>
            Inverse complex cepstral transform
            </summary>
            <param name="cepstrum"></param>
            <param name="output"></param>
            <param name="delay"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform.Inverse(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Inverse complex cepstral transform
            </summary>
            <param name="cepstrum"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform.RealCepstrum(System.Single[],System.Single[])">
            <summary>
            Real cepstrum:
            
            real{IFFT(log(abs(FFT(x))))}
            
            </summary>
            <param name="input"></param>
            <param name="cepstrum"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform.PowerCepstrum(System.Single[],System.Single[])">
            <summary>
            Wiki:
            power_cepstrum = 4 * real_cepstrum ^ 2
            </summary>
            <param name="input"></param>
            <param name="cepstrum"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.CepstralTransform.PhaseCepstrum(System.Single[],System.Single[])">
            <summary>
            Wiki:
            phase_cepstrum = (complex_cepstrum - reversed_complex_cepstrum) ^ 2
            </summary>
            <param name="input"></param>
            <param name="cepstrum"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Dct1">
            <summary>
            Class providing methods for Discrete Cosine Transform of type-I.
            See https://en.wikipedia.org/wiki/Discrete_cosine_transform
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Dct1._dctMtx">
            <summary>
            DCT precalculated cosine matrix
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Dct1.Size">
            <summary>
            Size of DCT
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct1.#ctor(System.Int32)">
            <summary>
            Precalculate DCT matrices
            </summary>
            <param name="dctSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct1.Direct(System.Single[],System.Single[])">
            <summary>
            DCT-I (without normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct1.Inverse(System.Single[],System.Single[])">
            <summary>
            IDCT-I (without normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct1.DirectNorm(System.Single[],System.Single[])">
            <summary>
            DCT-I (with normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct1.InverseNorm(System.Single[],System.Single[])">
            <summary>
            Inverse DCT-I (with normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Dct2">
            <summary>
            Class providing methods for Discrete Cosine Transform of type-II.
            See https://en.wikipedia.org/wiki/Discrete_cosine_transform
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Dct2._dctMtx">
            <summary>
            DCT precalculated cosine matrix
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Dct2._dctMtxInv">
            <summary>
            IDCT precalculated cosine matrix
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Dct2.Size">
            <summary>
            Size of DCT
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct2.#ctor(System.Int32)">
            <summary>
            Precalculate DCT matrices
            </summary>
            <param name="dctSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct2.Direct(System.Single[],System.Single[])">
            <summary>
            DCT-II (without normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct2.DirectNorm(System.Single[],System.Single[])">
            <summary>
            DCT-II (with normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct2.Inverse(System.Single[],System.Single[])">
            <summary>
            IDCT-II (without normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct2.InverseNorm(System.Single[],System.Single[])">
            <summary>
            IDCT-II (with normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Dct3">
            <summary>
            Class providing methods for Discrete Cosine Transform of type-III.
            See https://en.wikipedia.org/wiki/Discrete_cosine_transform
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Dct3._dctMtx">
            <summary>
            DCT precalculated cosine matrix
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Dct3._dctMtxInv">
            <summary>
            IDCT precalculated cosine matrix
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Dct3.Size">
            <summary>
            Size of DCT
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct3.#ctor(System.Int32)">
            <summary>
            Precalculate DCT matrices
            </summary>
            <param name="dctSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct3.Direct(System.Single[],System.Single[])">
            <summary>
            DCT-III (without normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct3.DirectNorm(System.Single[],System.Single[])">
            <summary>
            DCT-III (with normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct3.Inverse(System.Single[],System.Single[])">
            <summary>
            IDCT-III (without normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct3.InverseNorm(System.Single[],System.Single[])">
            <summary>
            IDCT-III (with normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Dct4">
            <summary>
            Class providing methods for Discrete Cosine Transform of type-IV.
            See https://en.wikipedia.org/wiki/Discrete_cosine_transform
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Dct4._dctMtx">
            <summary>
            DCT precalculated cosine matrix
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Dct4.Size">
            <summary>
            Size of DCT
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct4.#ctor(System.Int32)">
            <summary>
            Precalculate DCT matrices
            </summary>
            <param name="dctSize"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct4.Direct(System.Single[],System.Single[])">
            <summary>
            DCT-IV (without normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct4.Inverse(System.Single[],System.Single[])">
            <summary>
            IDCT-IV (without normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct4.DirectNorm(System.Single[],System.Single[])">
            <summary>
            DCT-IV (with normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Dct4.InverseNorm(System.Single[],System.Single[])">
            <summary>
            IDCT-IV (with normalization)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.FastDct2">
            <summary>
            Быстрое дискретно-косинусное преобразование 2, через преобразование Фурье
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.FastDct2._fft">
            <summary>
            Внутренний алгоритм для выполнения БПФ
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.FastDct2._temp">
            <summary>
            Внутренний буффер памяти
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.FastDct2.Size">
            <summary>
            Size of DCT
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastDct2.#ctor(System.Int32)">
            <summary>
            Быстрое дискретно-косинусное преобразование 3, через преобразование Фурье
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastDct2.Direct(System.Single[],System.Single[])">
            <summary>
            Прямое преобразование
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastDct2.DirectNorm(System.Single[],System.Single[])">
            <summary>
            Прямое нормированное преобразование
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastDct2.Inverse(System.Single[],System.Single[])">
            <summary>
            Обратное преобразование
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastDct2.InverseNorm(System.Single[],System.Single[])">
            <summary>
            Обратное нормированное преобразование (нереализовано)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.FastDct3">
            <summary>
            Быстрое дискретно-косинусное преобразование 3, через преобразование Фурье
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.FastDct3._dct2">
            <summary>
            Internal DCT-II transformer
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.FastDct3.Size">
            <summary>
            Число отсчетов ДКП
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastDct3.#ctor(System.Int32)">
            <summary>
            Быстрое дискретно-косинусное преобразование 3, через преобразование Фурье
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastDct3.Direct(System.Single[],System.Single[])">
            <summary>
            Прямое преобразование
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastDct3.DirectNorm(System.Single[],System.Single[])">
            <summary>
            Прямое нормированное преобразование
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastDct3.Inverse(System.Single[],System.Single[])">
            <summary>
            Обратное преобразование
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastDct3.InverseNorm(System.Single[],System.Single[])">
            <summary>
            Обратное нормированное преобразование
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.FastDct4">
            <summary>
            Быстрое дискретно-косинусное преобразование 4, через преобразование Фурье
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.FastDct4._fft">
            <summary>
            Внутренний алгоритм для выполнения БПФ
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.FastDct4._temp">
            <summary>
            Внутренний буффер памяти
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.FastDct4.Size">
            <summary>
            Число отсчетов ДКП
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastDct4.#ctor(System.Int32)">
            <summary>
            Быстрое дискретно-косинусное преобразование 4, через преобразование Фурье
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastDct4.Direct(System.Single[],System.Single[])">
            <summary>
            Прямое преобразование
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastDct4.DirectNorm(System.Single[],System.Single[])">
            <summary>
            Прямое нормированное преобразование
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastDct4.Inverse(System.Single[],System.Single[])">
            <summary>
            Обратное преобразование
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastDct4.InverseNorm(System.Single[],System.Single[])">
            <summary>
            Обратное нормированное преобразование
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.FastMdct">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.FastMdct.#ctor(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.IDct">
            <summary>
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.IDct.Size">
            <summary>
            Число отсчетов ДКП
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.IDct.Direct(System.Single[],System.Single[])">
            <summary>
            Direct DCT
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.IDct.DirectNorm(System.Single[],System.Single[])">
            <summary>
            Direct normalized DCT
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.IDct.Inverse(System.Single[],System.Single[])">
            <summary>
            Inverse DCT
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.IDct.InverseNorm(System.Single[],System.Single[])">
            <summary>
            Inverse normalized DCT
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Mdct">
            <summary>
            Class providing methods for Modified Discrete Cosine Transform (MDCT).
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Mdct._dct">
            <summary>
            Internal DCT-IV transformer
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Mdct._temp">
            <summary>
            Внутренний буффер памяти
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Mdct.Size">
            <summary>
            Число отсчетов ДКП
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Mdct.#ctor(System.Int32,AI.BackEnds.DSP.NWaves.Transforms.IDct)">
            <summary>
            Class providing methods for Modified Discrete Cosine Transform (MDCT).
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Mdct.Direct(System.Single[],System.Single[])">
            <summary>
            Direct MDCT
            </summary>
            <param name="input">Input length must be equal to 2*DctSize</param>
            <param name="output">Output length must be equal to DctSize</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Mdct.Inverse(System.Single[],System.Single[])">
            <summary>
            Inverse MDCT
            </summary>
            <param name="input">Input length must be equal to DctSize</param>
            <param name="output">Output length must be equal to 2*DctSize</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Mdct.DirectNorm(System.Single[],System.Single[])">
            <summary>
            Direct MDCT (with normalization)
            </summary>
            <param name="input">Input length must be equal to 2*DctSize</param>
            <param name="output">Output length must be equal to DctSize</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Mdct.InverseNorm(System.Single[],System.Single[])">
            <summary>
            Inverse MDCT (with normalization)
            </summary>
            <param name="input">Input length must be equal to DctSize</param>
            <param name="output">Output length must be equal to 2*DctSize</param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Fft">
            <summary>
            Class providing methods for direct and inverse Fast Fourier Transforms
            and postprocessing: magnitude spectrum, power spectrum, logpower spectrum.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Fft.Size">
            <summary>
            The Размер блока БПФ
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Fft._cosTbl">
            <summary>
            Precomputed cosines
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Fft._sinTbl">
            <summary>
            Precomputed sines
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Fft._realSpectrum">
            <summary>
            Intermediate buffer storing real parts of spectrum
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Fft._imagSpectrum">
            <summary>
            Intermediate buffer storing imaginary parts of spectrum
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft.#ctor(System.Int32)">
            <summary>
            Конструктор accepting the Размер блока БПФ
            </summary>
            <param name="fftSize">Размер блока БПФ</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft.Direct(System.Single[],System.Single[])">
            <summary>
            Fast Fourier Transform algorithm
            </summary>
            <param name="re">Array of real parts</param>
            <param name="im">Array of imaginary parts</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft.Inverse(System.Single[],System.Single[])">
            <summary>
            Inverse Fast Fourier Transform algorithm
            </summary>
            <param name="re">Array of real parts</param>
            <param name="im">Array of imaginary parts</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft.InverseNorm(System.Single[],System.Single[])">
            <summary>
            Inverse Fast Fourier Transform algorithm (with normalization by FFT size)
            </summary>
            <param name="re">Array of real parts</param>
            <param name="im">Array of imaginary parts</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft.MagnitudeSpectrum(System.Single[],System.Single[],System.Boolean)">
            <summary>
            Magnitude spectrum:
            
                spectrum = sqrt(re * re + im * im)
            
            </summary>
            <param name="samples">Array of samples (samples parts)</param>
            <param name="spectrum">Magnitude spectrum (array MUST have size at least _fftSize / 2 + 1)</param>
            <param name="normalize">Normalization flag</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft.PowerSpectrum(System.Single[],System.Single[],System.Boolean)">
            <summary>
            Power spectrum (normalized by default):
            
                spectrum =   (re * re + im * im) / fftSize
            
            </summary>
            <param name="samples">Array of samples (samples parts)</param>
            <param name="spectrum">Power spectrum (array MUST have size at least _fftSize / 2 + 1)</param>
            <param name="normalize">Normalization flag</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft.MagnitudeSpectrum(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Boolean)">
            <summary>
            Overloaded method for DiscreteSignal as an input
            </summary>
            <param name="signal"></param>
            <param name="normalize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft.PowerSpectrum(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Boolean)">
            <summary>
            Overloaded method for DiscreteSignal as an input
            </summary>
            <param name="signal"></param>
            <param name="normalize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft.Shift(System.Single[])">
            <summary>
            FFT shift (in-place)
            </summary>
            <param name="samples"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Fft64">
            <summary>
            Class providing methods for direct and inverse Fast Fourier Transforms
            and postprocessing: magnitude spectrum, power spectrum, logpower spectrum.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Fft64.Size">
            <summary>
            Размер блока БПФ
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Fft64._cosTbl">
            <summary>
            Precomputed cosines
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Fft64._sinTbl">
            <summary>
            Precomputed sines
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft64.#ctor(System.Int32)">
            <summary>
            Конструктор accepting the Размер блока БПФ
            </summary>
            <param name="fftSize">Размер блока БПФ</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft64.Direct(System.Double[],System.Double[])">
            <summary>
            Fast Fourier Transform algorithm
            </summary>
            <param name="re">Array of real parts</param>
            <param name="im">Array of imaginary parts</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft64.Inverse(System.Double[],System.Double[])">
            <summary>
            Inverse Fast Fourier Transform algorithm
            </summary>
            <param name="re">Array of real parts</param>
            <param name="im">Array of imaginary parts</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Fft64.InverseNorm(System.Double[],System.Double[])">
            <summary>
            Inverse Fast Fourier Transform algorithm (with normalization by FFT size)
            </summary>
            <param name="re">Array of real parts</param>
            <param name="im">Array of imaginary parts</param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Goertzel">
            <summary>
            Class for Goertzel algorithm
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Goertzel._fftSize">
            <summary>
            Размер блока БПФ
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Goertzel.#ctor(System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="fftSize">Размер блока БПФ</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Goertzel.Direct(System.Single[],System.Int32)">
            <summary>
            Very simple implementation of Goertzel algorithm
            </summary>
            <param name="input">Input array</param>
            <param name="n">Number of the frequency component</param>
            <returns>nth component of a complex spectrum</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Goertzel.Direct(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Int32)">
            <summary>
            Overloaded method for DiscreteSignal
            </summary>
            <param name="input">Входной сигнал</param>
            <param name="n">Number of the frequency component</param>
            <returns>nth component of a complex spectrum</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.HartleyTransform">
            <summary>
            Преобразование Гильберта
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.HartleyTransform.Size">
            <summary>
            Size of transform
            </summary>
            
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.HartleyTransform._fft">
            <summary>
            Внутренний алгоритм для выполнения БПФ
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.HartleyTransform._im">
            <summary>
            Internal array for imaginary parts
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.HartleyTransform.#ctor(System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.HartleyTransform.Direct(System.Single[])">
            <summary>
            Direct transform
            </summary>
            <param name="re"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.HartleyTransform.Inverse(System.Single[])">
            <summary>
            Inverse transform
            </summary>
            <param name="re"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform">
            <summary>
            Hilbert Transform
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform.Size">
            <summary>
            Size (length) of Hilbert Transform
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform._fft32">
            <summary>
            Fft transformer, single precision
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform._fft64">
            <summary>
            Fft transformer, double precision
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform.#ctor(System.Int32,System.Boolean)">
            <summary>
            Конструктор
            </summary>
            <param name="size">Size of Hilbert Transform</param>
            <param name="doublePrecision"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform.AnalyticSignal(System.Double[],System.Boolean)">
            <summary>
            Compute complex analytic signal, double precision
            </summary>
            <param name="samples">Array of samples</param>
            <param name="norm">Normalize by fft size</param>
            <returns>Complex analytic signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform.AnalyticSignal(System.Single[],System.Boolean)">
            <summary>
            Compute complex analytic signal, single precision
            </summary>
            <param name="samples">Array of samples</param>
            <param name="norm">Normalize by fft size</param>
            <returns>Complex analytic signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform.Direct(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Direct Hilbert Transform
            </summary>
            <param name="signal">Входной сигнал</param>
            <returns>Hilbert Transform</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform.Direct(System.Double[],System.Double[])">
            <summary>
            Direct Hilbert Transform
            </summary>
            <param name="samples">Array of samples</param>
            <param name="output">Hilbert Transform array</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.HilbertTransform.Direct(System.Single[],System.Single[])">
            <summary>
            Direct Hilbert Transform
            </summary>
            <param name="samples">Array of samples</param>
            <param name="output">Hilbert Transform array</param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.MellinTransform">
            <summary>
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.MellinTransform.InputSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.MellinTransform.OutputSize">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.MellinTransform.#ctor(System.Int32,System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.MellinTransform.Direct(System.Single[],System.Single[],System.Single[],System.Boolean)">
            <summary>
            Direct Fast Mellin Transform
            </summary>
            <param name="input"></param>
            <param name="outputRe"></param>
            <param name="outputIm"></param>
            <param name="normalize"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.RealFft">
            <summary>
            Метод вычисления БПФ for real inputs
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.RealFft.Size">
            <summary>
            Размер блока БПФ
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft._fftSize">
            <summary>
            Half of FFT size (for calculations)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft._cosTbl">
            <summary>
            Precomputed cosines
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft._sinTbl">
            <summary>
            Precomputed sines
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft._ar">
            <summary>
            Precomputed coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft._br">
            <summary>
            Precomputed coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft._ai">
            <summary>
            Precomputed coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft._bi">
            <summary>
            Precomputed coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft._re">
            <summary>
            Внутренние буферы
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft.#ctor(System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft.Direct(System.Single[],System.Single[],System.Single[])">
            <summary>
            Direct transform
            </summary>
            <param name="input"></param>
            <param name="re"></param>
            <param name="im"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft.Inverse(System.Single[],System.Single[],System.Single[])">
            <summary>
            Inverse transform
            </summary>
            <param name="re"></param>
            <param name="im"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft.InverseNorm(System.Single[],System.Single[],System.Single[])">
            <summary>
            Inverse transform (with normalization by Fft size)
            </summary>
            <param name="re"></param>
            <param name="im"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft.MagnitudeSpectrum(System.Single[],System.Single[],System.Boolean)">
            <summary>
            Magnitude spectrum:
            
                spectrum = sqrt(re * re + im * im)
            
            Since for realFFT: im[0] = im[fftSize/2] = 0
            we don't process separately these elements (like in case of FFT)
            
            </summary>
            <param name="samples">Array of samples (samples parts)</param>
            <param name="spectrum">Magnitude spectrum</param>
            <param name="normalize">Normalization flag</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft.PowerSpectrum(System.Single[],System.Single[],System.Boolean)">
            <summary>
            Power spectrum (normalized by default):
            
                spectrum =   (re * re + im * im) / fftSize
            
            Since for realFFT: im[0] = im[fftSize/2] = 0
            we don't process separately these elements (like in case of FFT)
            
            </summary>
            <param name="samples">Array of samples (samples parts)</param>
            <param name="spectrum">Power spectrum</param>
            <param name="normalize">Normalization flag</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft.MagnitudeSpectrum(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Boolean)">
            <summary>
            Overloaded method for DiscreteSignal as an input
            </summary>
            <param name="signal"></param>
            <param name="normalize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft.PowerSpectrum(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Boolean)">
            <summary>
            Overloaded method for DiscreteSignal as an input
            </summary>
            <param name="signal"></param>
            <param name="normalize"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft.Shift(System.Single[])">
            <summary>
            FFT shift (in-place)
            </summary>
            <param name="samples"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.RealFft64">
            <summary>
            Бих фильтр 64-битные коэф.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.RealFft64.Size">
            <summary>
            Размер блока БПФ
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft64._fftSize">
            <summary>
            Half of FFT size (for calculations)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft64._cosTbl">
            <summary>
            Precomputed cosines
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft64._sinTbl">
            <summary>
            Precomputed sines
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft64._ar">
            <summary>
            Precomputed coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft64._br">
            <summary>
            Precomputed coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft64._ai">
            <summary>
            Precomputed coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft64._bi">
            <summary>
            Precomputed coefficients
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.RealFft64._re">
            <summary>
            Внутренние буферы
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft64.#ctor(System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft64.Direct(System.Double[],System.Double[],System.Double[])">
            <summary>
            Direct transform
            </summary>
            <param name="input"></param>
            <param name="re"></param>
            <param name="im"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft64.Inverse(System.Double[],System.Double[],System.Double[])">
            <summary>
            Inverse transform
            </summary>
            <param name="re"></param>
            <param name="im"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.RealFft64.InverseNorm(System.Double[],System.Double[],System.Double[])">
            <summary>
            Inverse transform
            </summary>
            <param name="re"></param>
            <param name="im"></param>
            <param name="output"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Stft">
            <summary>
            Class providing methods for direct and inverse Short-Time Fourier Transforms.
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Stft.Size">
            <summary>
            Размер блока БПФ (in samples)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Stft._fft">
            <summary>
            Внутренний алгоритм для выполнения БПФ
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Stft._hopSize">
            <summary>
            Overlap size (in samples)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Stft._windowSize">
            <summary>
            Size of the window (in samples)
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Stft._window">
            <summary>
            Window type
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Stft._windowSamples">
            <summary>
            Pre-computed samples of the Оконная функция
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Stft._gain">
            <summary>
            Коэффициент нормализации ISTFT
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Stft.#ctor(System.Int32,System.Int32,AI.BackEnds.DSP.NWaves.Windows.WindowTypes,System.Int32)">
            <summary>
            Конструктор with necessary parameters
            </summary>
            <param name="windowSize">Size of window</param>
            <param name="hopSize">Hop (overlap) size</param>
            <param name="window">Type of the Оконная функция to apply</param>
            <param name="fftSize">Размер блока БПФ</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Stft.Direct(System.Single[])">
            <summary>
            Method for computing direct STFT of a signal block.
            STFT (spectrogram) is essentially the list of spectra in time.
            </summary>
            <param name="samples">The samples of signal</param>
            <returns>STFT of the signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Stft.Inverse(System.Collections.Generic.List{System.Tuple{System.Single[],System.Single[]}})">
            <summary>
            Inverse STFT
            </summary>
            <param name="stft"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Stft.Direct(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Overloaded method for DiscreteSignal as an input
            </summary>
            <param name="signal">The signal under analysis</param>
            <returns>STFT of the signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Stft.Spectrogram(System.Single[])">
            <summary>
            Method for computing a spectrogram.
            The spectrogram is essentially a list of power spectra in time.
            </summary>
            <param name="samples">The samples of signal</param>
            <returns>Spectrogram of the signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Stft.Spectrogram(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Overloaded method for DiscreteSignal as an input
            </summary>
            <param name="signal">Сигнал</param>
            <returns>Spectrogram of the signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Stft.MagnitudePhaseSpectrogram(System.Single[])">
            <summary>
            Method for computing a spectrogram as arrays of Magnitude and Phase.
            </summary>
            <param name="samples">The samples of signal</param>
            <returns>Magnitude-Phase spectrogram of the signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Stft.MagnitudePhaseSpectrogram(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal)">
            <summary>
            Overloaded method for DiscreteSignal as an input
            </summary>
            <param name="signal">Сигнал</param>
            <returns>Magnitude-Phase spectrogram of the signal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Stft.ReconstructMagnitudePhase(AI.BackEnds.DSP.NWaves.Transforms.MagnitudePhaseList)">
            <summary>
            Reconstruct samples from magnitude-phase spectrogram
            </summary>
            <param name="spectrogram"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.MagnitudePhaseList">
            <summary>
            Список модулей и фаз
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.MagnitudePhaseList.Magnitudes">
            <summary>
            Модули
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.MagnitudePhaseList.Phases">
            <summary>
            Фазы
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt">
            <summary>
            Fast Wavelet Transform
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt.Size">
            <summary>
            Size of the transform
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt._waveletLength">
            <summary>
            The length of the mother wavelet
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt._loD">
            <summary>
            LP coefficients for decomposition
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt._hiD">
            <summary>
            HP coefficients for decomposition
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt._loR">
            <summary>
            LP coefficients for reconstruction
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt._hiR">
            <summary>
            HP coefficients for reconstruction
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt._temp">
            <summary>
            Temporary internal buffer
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt.#ctor(System.Int32,AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet)">
            <summary>
            Конструктор
            </summary>
            <param name="size"></param>
            <param name="wavelet"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt.Direct(System.Single[],System.Single[],System.Int32)">
            <summary>
            Direct FWT (decomposition)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
            <param name="level"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt.Inverse(System.Single[],System.Single[],System.Int32)">
            <summary>
            Inverse FWT (reconstruction)
            </summary>
            <param name="input"></param>
            <param name="output"></param>
            <param name="level"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Fwt.MaxLevel(System.Int32)">
            <summary>
            Maximum decomposition level
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet">
            <summary>
            Wavelet
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.Name">
            <summary>
            Name
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.Length">
            <summary>
            The length of the mother wavelet
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.LoD">
            <summary>
            LP coefficients for decomposition
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.HiD">
            <summary>
            HP coefficients for decomposition
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.LoR">
            <summary>
            LP coefficients for reconstruction
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.HiR">
            <summary>
            HP coefficients for reconstruction
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.#ctor(AI.BackEnds.DSP.NWaves.Transforms.Wavelets.WaveletFamily,System.Int32)">
            <summary>
            Конструктор from wavelet family and number of taps
            </summary>
            <param name="waveletFamily"></param>
            <param name="taps">Set for all wavelets</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.#ctor(System.String)">
            <summary>
            Конструктор from name
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.MakeWavelet(AI.BackEnds.DSP.NWaves.Transforms.Wavelets.WaveletFamily,System.Int32)">
            <summary>
            Fill wavelet fields: name, length and coefficients
            </summary>
            <param name="waveletFamily"></param>
            <param name="taps"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.ComputeOrthonormalCoeffs">
            <summary>
            Compute orthonormal coefficients from LoD coefficients only
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.MakeHaarWavelet">
            <summary>
            Haar wavelet
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.MakeDaubechiesWavelet(System.Int32)">
            <summary>
            Daubechies wavelet
            </summary>
            <param name="taps"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.MakeSymletWavelet(System.Int32)">
            <summary>
            Symlet wavelet
            </summary>
            <param name="taps"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.Wavelet.MakeCoifletWavelet(System.Int32)">
            <summary>
            Coiflet wavelet
            </summary>
            <param name="taps"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.WaveletFamily">
            <summary>
            Wavelet family type
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.WaveletFamily.Haar">
            <summary>
            Haar wavelet
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.WaveletFamily.Daubechies">
            <summary>
            Daubechies wavelet
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.WaveletFamily.Coiflet">
            <summary>
            Coiflet wavelet
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Transforms.Wavelets.WaveletFamily.Symlet">
            <summary>
            Symlet wavelet
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Utils.Guard">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Guard.AgainstNonPositive(System.Double,System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Guard.AgainstInequality(System.Double,System.Double,System.String,System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Guard.AgainstInvalidRange(System.Double,System.Double,System.String,System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Guard.AgainstExceedance(System.Double,System.Double,System.String,System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Guard.AgainstNotPowerOfTwo(System.Int32,System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Guard.AgainstEvenNumber(System.Int32,System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Guard.AgainstIncorrectFilterParams(System.Double[],System.Double[],System.Double[])">
            <summary>
            
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Utils.Lpc">
            <summary>
            Functions related to Linear Predictive Coding
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Lpc.LevinsonDurbin(System.Single[],System.Single[],System.Int32,System.Int32)">
            <summary>
            Levinson-Durbin algorithm for solving main LPC task
            </summary>
            <param name="input">Auto-correlation vector</param>
            <param name="a">LP coefficients</param>
            <param name="order">Order of LPC</param>
            <param name="offset">Смещение</param>
            <returns>Prediction error</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Lpc.ToCepstrum(System.Single[],System.Single,System.Single[])">
            <summary>
            Convert LPC coefficients to cepstrum (LPCC)
            </summary>
            <param name="lpc"></param>
            <param name="gain"></param>
            <param name="lpcc"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Lpc.FromCepstrum(System.Single[],System.Single[])">
            <summary>
            Convert LPCC coefficients to LPC and gain
            
            Formulae: https://www.mathworks.com/help/dsp/ref/lpctofromcepstralcoefficients.html
            
            </summary>
            <param name="lpcc"></param>
            <param name="lpc"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Lpc.EstimateOrder(System.Int32)">
            <summary>
            Method returns LPC order for a given Частота дискретизации 
            according to the best practices.
            </summary>
            <param name="samplingRate">Частота дискретизации</param>
            <returns>LPC order</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Lpc.ToLsf(System.Single[],System.Single[])">
            <summary>
            Convert LPC coefficients to Line Spectral Frequencies
            </summary>
            <param name="lpc"></param>
            <param name="lsf">The length must be equal to lpc length. Last element will be PI</param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Lpc.FromLsf(System.Single[],System.Single[])">
            <summary>
            Convert Line Spectral Frequencies to LPC coefficients
            </summary>
            <param name="lsf">The length must be equal to lpc length. Last element must be PI</param>
            <param name="lpc"></param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP">
            <summary>
            Static class providing some helpful math functions
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.Sinc(System.Double)">
            <summary>
            Sinc-function
            </summary>
            <param name="x">Argument</param>
            <returns>sinc(x)</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.NextPowerOfTwo(System.Int32)">
            <summary>
            Method for computing next power of 2 (closest to the given number)
            </summary>
            <param name="n">Число</param>
            <returns>Next power of 2 closest to the number</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.Gcd(System.Int32,System.Int32)">
            <summary>
            Greatest Common Divisor
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.Mod(System.Double,System.Double)">
            <summary>
            Modulo function that works correctly with negative numbers (as np.mod)
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.Asinh(System.Double)">
            <summary>
            Inverse sinh
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.Factorial(System.Int32)">
            <summary>
            Factorial
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.BinomialCoefficient(System.Int32,System.Int32)">
            <summary>
            Binomial coefficient
            </summary>
            <param name="k"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.Diff(System.Single[],System.Single[])">
            <summary>
            Diff signal (1st order derivative)
            </summary>
            <param name="samples"></param>
            <param name="diff"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.InterpolateLinear(System.Single[],System.Single[],System.Single[],System.Single[])">
            <summary>
            Linear interpolation (as numpy.interp)
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="arg"></param>
            <param name="interp"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.BilinearTransform(System.Double[],System.Double[])">
            <summary>
            Bilinear transform (in-place)
            </summary>
            <param name="re"></param>
            <param name="im"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.Unwrap(System.Double[],System.Double)">
            <summary>
            Unwrap (phase)
            </summary>
            <param name="phase"></param>
            <param name="tolerance">Jump size</param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.Wrap(System.Double[],System.Double)">
            <summary>
            Wrap (phase)
            </summary>
            <param name="phase"></param>
            <param name="tolerance">Jump size</param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.FindNth(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Nth order statistics
            </summary>
            <param name="a"></param>
            <param name="n"></param>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.I0(System.Double)">
            <summary>
            Modified Bessel function of the 1st kind (Taylor series, not very precise method)
            </summary>
            <param name="x">x</param>
            <returns>I0(x)</returns>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.PolyRootsIterations">
            <summary>
            Максимальное число итераций для расчета полюсно-нулевой функции используемое по-умолчанию
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.PolynomialRoots(System.Double[],System.Int32)">
            <summary>
            Method implementing Durand-Kerner algorithm for finding complex roots of polynomials.
            Works for polynomials of order up to approx. 50. 
            </summary>
            <param name="a">Polynomial coefficients</param>
            <param name="maxIterations">Максимальное число итераций</param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.ArraysAreEqual(System.Numerics.Complex[],System.Numerics.Complex[],System.Double)">
            <summary>
            Method checks if two arrays of complex numbers are essentially identical
            </summary>
            <param name="a">First array</param>
            <param name="b">Second array</param>
            <param name="tolerance">Tolerance level</param>
            <returns>true if arrays are equal</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.EvaluatePolynomial(System.Double[],System.Numerics.Complex)">
            <summary>
            Evaluate polynomial according to Horner scheme
            </summary>
            <param name="a">Polynomial coefficients</param>
            <param name="x">x</param>
            <returns>The value of polynomial</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.MultiplyPolynomials(System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
            Multiply polynomials
            </summary>
            <param name="poly1"></param>
            <param name="poly2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MathUtilsDSP.DividePolynomial(System.Numerics.Complex[],System.Numerics.Complex[])">
            <summary>
            Divide polynomials
            </summary>
            <param name="dividend">Dividend</param>
            <param name="divisor">Divisor</param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves">
            <summary>
            Class representing 2d matrix
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves.Rows">
            <summary>
            Число строк
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves.Columns">
            <summary>
            Число столбцов
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves.#ctor(System.Int32,System.Int32)">
            <summary>
            Конструктор
            </summary>
            <param name="rows"></param>
            <param name="columns"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves.As2dArray">
            <summary>
            Get 2d array reference
            </summary>
            <returns></returns>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves.T">
            <summary>
            Transposed matrix
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves.Companion(System.Double[])">
            <summary>
            Companion matrix
            </summary>
            <param name="a">Input array</param>
            <returns>Companion matrix</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves.Eye(System.Int32)">
            <summary>
            Identity matrix
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves.op_Addition(AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves,AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves)">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves.op_Subtraction(AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves,AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves)">
            <summary>
            
            </summary>
        </member>
        <member name="P:AI.BackEnds.DSP.NWaves.Utils.MatrixNWaves.Item(System.Int32)">
            <summary>
            Значение по индексу
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions">
            <summary>
            Расширение для работы с памятью
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.ToFloats(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Convert array of doubles to array of floats
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.ToDoubles(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Convert array of floats to array of doubles
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.FastCopy(System.Single[])">
            <summary>
            Method simply copies source array to desination
            </summary>
            <param name="source">Source array</param>
            <returns>Source array copy</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.FastCopyTo(System.Single[],System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Method copies an array (or its fragment) to existing array (or its part)
            </summary>
            <param name="source"></param>
            <param name="destination"></param>
            <param name="size"></param>
            <param name="sourceOffset"></param>
            <param name="destinationOffset"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.FastCopyFragment(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Method copies some fragment of the source array starting at specified offset
            </summary>
            <param name="source"></param>
            <param name="size"></param>
            <param name="sourceOffset"></param>
            <param name="destinationOffset"></param>
            <returns>The copy of source array part</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.MergeWithArray(System.Single[],System.Single[])">
            <summary>
            Method does fast in-memory merge of two arrays
            </summary>
            <param name="source1">The first array for merging</param>
            <param name="source2">The second array for merging</param>
            <returns>Merged array</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.RepeatArray(System.Single[],System.Int32)">
            <summary>
            Method repeats given array N times
            </summary>
            <param name="source">Source array</param>
            <param name="times">Number of times to repeat array</param>
            <returns>Array repeated N times</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.PadZeros(System.Single[],System.Int32)">
            <summary>
            Method creates new zero-padded array from source array.
            </summary>
            <param name="source">Source array</param>
            <param name="size">The size of a zero-padded array</param>
            <returns>Zero-padded array</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.FastCopy(System.Double[])">
            <summary>
            Method simply copies source array to desination
            </summary>
            <param name="source">Source array</param>
            <returns>Source array copy</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.FastCopyTo(System.Double[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Method copies an array (or its fragment) to existing array (or its part)
            </summary>
            <param name="source"></param>
            <param name="destination"></param>
            <param name="size"></param>
            <param name="sourceOffset"></param>
            <param name="destinationOffset"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.FastCopyFragment(System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Method copies some fragment of the source array starting at specified offset
            </summary>
            <param name="source"></param>
            <param name="size"></param>
            <param name="sourceOffset"></param>
            <param name="destinationOffset"></param>
            <returns>The copy of source array part</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.MergeWithArray(System.Double[],System.Double[])">
            <summary>
            Method does fast in-memory merge of two arrays
            </summary>
            <param name="source1">The first array for merging</param>
            <param name="source2">The second array for merging</param>
            <returns>Merged array</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.RepeatArray(System.Double[],System.Int32)">
            <summary>
            Method repeats given array N times
            </summary>
            <param name="source">Source array</param>
            <param name="times">Number of times to repeat array</param>
            <returns>Array repeated N times</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.MemoryOperationExtensions.PadZeros(System.Double[],System.Int32)">
            <summary>
            Method creates new zero-padded array from source array.
            </summary>
            <param name="source">Source array</param>
            <param name="size">The size of a zero-padded array</param>
            <returns>Zero-padded array</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Utils.Scale">
            <summary>
            Static class providing methods for 
            
            1) converting between different scales:
                - decibel
                - MIDI pitch
                - mel (HTK)
                - mel (Slaney)
                - bark1 (Traunmueller)
                - bark2 (Wang)
                - ERB
            
            2) loudness weighting:
                - A-weighting
                - B-weighting
                - C-weighting
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.ToDecibel(System.Double,System.Double)">
            <summary>
            Method converts magnitude value to dB level
            </summary>
            <param name="value">Magnitude</param>
            <param name="valueReference">Reference magnitude</param>
            <returns>Decibel level</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.ToDecibelPower(System.Double,System.Double)">
            <summary>
            Method converts power to dB level
            </summary>
            <param name="value">Power</param>
            <param name="valueReference">Reference power</param>
            <returns>Decibel level</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.FromDecibel(System.Double,System.Double)">
            <summary>
            Method converts dB level to magnitude value
            </summary>
            <param name="level">dB level</param>
            <param name="valueReference">Reference magnitude</param>
            <returns>Magnitude value</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.FromDecibelPower(System.Double,System.Double)">
            <summary>
            Method converts dB level to power
            </summary>
            <param name="level">dB level</param>
            <param name="valueReference">Reference power</param>
            <returns>Power</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.PitchToFreq(System.Int32)">
            <summary>
            Method converts MIDI pitch to frequency
            </summary>
            <param name="pitch"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.FreqToPitch(System.Double)">
            <summary>
            Method converts frequency to MIDI pitch
            </summary>
            <param name="freq"></param>
            <returns></returns>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Utils.Scale.Notes">
            <summary>
            Array of notes
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.NoteToFreq(System.String,System.Int32)">
            <summary>
            Method converts note (in format ("G", 3), ("E", 5), etc.) to frequency in Hz
            </summary>
            <param name="note">Note (A-G#)</param>
            <param name="octave">Octave (0-8)</param>
            <returns>Frequency in Hz</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.FreqToNote(System.Double)">
            <summary>
            Method converts frequency in Hz to note (in format ("G", 3), ("E", 5), etc.)
            </summary>
            <param name="freq">Frequency in Hz</param>
            <returns>Tuple (note, octave)</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.HerzToMel(System.Double)">
            <summary>
            Method converts herz frequency to corresponding mel frequency
            </summary>
            <param name="herz">Herz frequency</param>
            <returns>Mel frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.MelToHerz(System.Double)">
            <summary>
            Method converts mel frequency to corresponding herz frequency
            </summary>
            <param name="mel">Mel frequency</param>
            <returns>Herz frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.HerzToMelSlaney(System.Double)">
            <summary>
            Method converts herz frequency to mel frequency (suggested by M.Slaney)
            </summary>
            <param name="herz">Herz frequency</param>
            <returns>Mel frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.MelToHerzSlaney(System.Double)">
            <summary>
            Method converts mel frequency to herz frequency (suggested by M.Slaney)
            </summary>
            <param name="mel">Mel frequency</param>
            <returns>Herz frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.HerzToBark(System.Double)">
            <summary>
            Method #1 converts herz frequency to corresponding bark frequency
            (according to Traunmüller (1990))
            </summary>
            <param name="herz">Herz frequency</param>
            <returns>Bark frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.BarkToHerz(System.Double)">
            <summary>
            Method #1 converts bark frequency to corresponding herz frequency
            (according to Traunmüller (1990))
            </summary>
            <param name="bark">Bark frequency</param>
            <returns>Herz frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.HerzToBarkSlaney(System.Double)">
            <summary>
            Method #2 converts herz frequency to corresponding bark frequency
            (according to Wang (1992)); used in M.Slaney's auditory toolbox
            </summary>
            <param name="herz">Herz frequency</param>
            <returns>Bark frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.BarkToHerzSlaney(System.Double)">
            <summary>
            Method #2 converts bark frequency to corresponding herz frequency
            (according to Wang (1992)); used in M.Slaney's auditory toolbox
            </summary>
            <param name="bark">Bark frequency</param>
            <returns>Herz frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.HerzToErb(System.Double)">
            <summary>
            Method converts herz frequency to corresponding ERB frequency
            </summary>
            <param name="herz">Herz frequency</param>
            <returns>ERB frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.ErbToHerz(System.Double)">
            <summary>
            Method converts ERB frequency to corresponding herz frequency
            </summary>
            <param name="erb">ERB frequency</param>
            <returns>Herz frequency</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Utils.Scale.LoudnessWeighting(System.Double,System.String)">
            <summary>
            Method for obtaining a perceptual loudness weight
            </summary>
            <param name="freq">Frequency</param>
            <param name="weightingType">Weighting type (A, B, C)</param>
            <returns>Weight value in dB</returns>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Windows.Window">
            <summary>
            Factory class generating various types of Оконная функцияs
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.OfType(AI.BackEnds.DSP.NWaves.Windows.WindowTypes,System.Int32,System.Object[])">
            <summary>
            Main factory method
            </summary>
            <param name="type">Window type</param>
            <param name="length">Window length</param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Rectangular(System.Int32)">
            <summary>
            Rectangular window
            </summary>
            <param name="length">Length of the window</param>
            <returns>Rectangular window</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Triangular(System.Int32)">
            <summary>
            Triangular window
            </summary>
            <param name="length">Length of the window</param>
            <returns>Triangular window</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Hamming(System.Int32)">
            <summary>
            Hamming window
            </summary>
            <param name="length">Length of the window</param>
            <returns>Hamming window</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Blackman(System.Int32)">
            <summary>
            Blackman window
            </summary>
            <param name="length">Length of the window</param>
            <returns>Blackman window</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Hann(System.Int32)">
            <summary>
            Hann window
            </summary>
            <param name="length">Length of the window</param>
            <returns>Hann window</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Gaussian(System.Int32)">
            <summary>
            Gaussian window
            </summary>
            <param name="length">Length of the window</param>
            <returns>Gaussian window</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Kaiser(System.Int32,System.Double)">
            <summary>
            Kaiser window
            </summary>
            <param name="length">Length of the window</param>
            <param name="alpha"></param>
            <returns>Kaiser window</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Kbd(System.Int32,System.Double)">
            <summary>
            Kaiser-Bessel Derived window
            </summary>
            <param name="length">Length of the window</param>
            <param name="alpha"></param>
            <returns>KBD window</returns>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.BartlettHann(System.Int32)">
            <summary>
            Bartlett-Hann window
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Lanczos(System.Int32)">
            <summary>
            Lanczos window
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.PowerOfSine(System.Int32,System.Double)">
            <summary>
            Sin-beta window
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Flattop(System.Int32)">
            <summary>
            Flat-top window
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.Window.Liftering(System.Int32,System.Int32)">
            <summary>
            Cepstrum liftering.
            </summary>
            <param name="length">Length of the window</param>
            <param name="l">Denominator in liftering formula</param>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Windows.WindowExtensions">
            <summary>
            A few helper functions for applying windows to signals and arrays of samples
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.WindowExtensions.ApplyWindow(System.Single[],System.Single[])">
            <summary>
            Mutable function that applies window array to array of float samples
            </summary>
            <param name="samples"></param>
            <param name="windowSamples"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.WindowExtensions.ApplyWindow(System.Double[],System.Double[])">
            <summary>
            Mutable function that applies window array to array of double samples
            </summary>
            <param name="samples"></param>
            <param name="windowSamples"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.WindowExtensions.ApplyWindow(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,System.Single[])">
            <summary>
            
            </summary>
            <param name="signal"></param>
            <param name="windowSamples"></param>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.WindowExtensions.ApplyWindow(System.Single[],AI.BackEnds.DSP.NWaves.Windows.WindowTypes,System.Object[])">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.WindowExtensions.ApplyWindow(System.Double[],AI.BackEnds.DSP.NWaves.Windows.WindowTypes,System.Object[])">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.BackEnds.DSP.NWaves.Windows.WindowExtensions.ApplyWindow(AI.BackEnds.DSP.NWaves.Signals.DiscreteSignal,AI.BackEnds.DSP.NWaves.Windows.WindowTypes,System.Object[])">
            <summary>
            
            </summary>
        </member>
        <member name="T:AI.BackEnds.DSP.NWaves.Windows.WindowTypes">
            <summary>
            Most commonly used Оконная функцияs
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Rectangular">
            <summary>
            Reactangular window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Triangular">
            <summary>
            Triangular window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Hamming">
            <summary>
            Hamming window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Blackman">
            <summary>
            Blackman window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Hann">
            <summary>
            Hann window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Gaussian">
            <summary>
            Gaussian window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Kaiser">
            <summary>
            Kaiser window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Kbd">
            <summary>
            Kaiser-Bessel Derived window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.BartlettHann">
            <summary>
            Bartlett-Hann window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Lanczos">
            <summary>
            Lanczos window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.PowerOfSine">
            <summary>
            Power-of-sine window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Flattop">
            <summary>
            Flat-top window
            </summary>
        </member>
        <member name="F:AI.BackEnds.DSP.NWaves.Windows.WindowTypes.Liftering">
            <summary>
            Window for cepstral liftering
            </summary>
        </member>
        <member name="T:AI.Correlation">
            <summary>
            Класс реализует авто- и взаимо- кореляционные функции
            Для действительных и комплексных векторов
            </summary>
        </member>
        <member name="M:AI.Correlation.CrossCorrelation(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            ВКФ для двух векторов из действительных чисел
            </summary>
            <param name="A">Первый вектор</param>
            <param name="B">Второй вектор</param>
        </member>
        <member name="M:AI.Correlation.CrossCorrelation(AI.DataStructs.WithComplexElements.ComplexVector,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            ВКФ для двух векторов из комплексных чисел
            </summary>
            <param name="A">Первый вектор</param>
            <param name="B">Второй вектор</param>
        </member>
        <member name="M:AI.Correlation.AutoCorrelation(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Автокорелляция действительного векторов
            </summary>
            <param name="A">Вектор</param>
            <returns>Возвращает осчеты АКФ</returns>
        </member>
        <member name="M:AI.Correlation.AutoCorrelation(AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Автокорелляция комплексного векторов
            </summary>
            <param name="A">Вектор</param>
            <returns>Возвращает осчеты АКФ</returns>	
        </member>
        <member name="T:AI.DataStructs.Algebraic.IAlgebraicStructure`1">
            <summary>
            Интерфейс алгебраической структуры
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.IAlgebraicStructure`1.Data">
            <summary>
            Представление данных структуры как одномерного массива
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.IAlgebraicStructure`1.Shape">
            <summary>
            Форма структуры
            </summary>
        </member>
        <member name="T:AI.DataStructs.Algebraic.Matrix">
            <summary>
            Класс представляющий матрицы и операции с ними
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.Data">
            <summary>
            Данные(компоненты) матрицы
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.DataType">
            <summary>
            Тип матрицы
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.Height">
            <summary>
            Высота
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.Width">
            <summary>
            Ширина
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.Shape">
            <summary>
            Форма матрицы
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.Item(System.Int32,System.Int32)">
            <summary>
            Выдает элемент по индексу
            </summary>
            <param name="i">Индекс высоты</param>
            <param name="j">Индекс ширины</param>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.Item(System.Int32)">
            <summary>
            Выдает элемент по индексу
            </summary>
            <param name="i">Индекс</param>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.Determinant">
            <summary>
            Определитель матрицы
            </summary>
            <returns></returns>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.IsZero">
            <summary>
            Все ли элементы матрицы равны нулю
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.IsSquared">
            <summary>
            Квадратная ли матрица
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.IsDiagonal">
            <summary>
            Является ли матрица диагональной
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Matrix.IsTriangle">
            <summary>
            Является ли матрица треугольной
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.#ctor">
            <summary>
            Создает матрицу со всеми нулями размерности 3х3
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.#ctor(System.Double[0:,0:])">
            <summary>
            Создает матрицу на основе двумерного массива
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.#ctor(AI.DataStructs.Shapes.Shape)">
            <summary>
            Создает матрицу заданной формы инициализированную нулями 
            </summary>
            <param name="shape"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Создает матрицу со всеми нулями размерности MxN
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Addition(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Поэлементная сумма
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Subtraction(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Поэлементная разность
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Addition(AI.DataStructs.Algebraic.Matrix,System.Double)">
            <summary>
            Addition 
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Addition(System.Double,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Addition
            </summary>
            <param name="k"></param>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Subtraction(AI.DataStructs.Algebraic.Matrix,System.Double)">
            <summary>
            вычитание
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Subtraction(System.Double,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Вычитание
            </summary>
            <param name="k"></param>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Multiply(AI.DataStructs.Algebraic.Matrix,System.Double)">
            <summary>
            Умножение
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Division(AI.DataStructs.Algebraic.Matrix,System.Double)">
            <summary>
            Деление
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Division(System.Double,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Деление
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Multiply(System.Double,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Умножение
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Multiply(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Умножение вектора на матрицу
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Multiply(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Умножение вектора на матрицу
            </summary>
            <param name="B"></param>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Multiply(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Матричное умножение
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Equality(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Проверка равенства
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.op_Inequality(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.NanToMean">
            <summary>
            Замена неопределенности(nan) на среднее значение
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.NanToValue(System.Double)">
            <summary>
             Замена неопределенности(nan) на заданное значение
            </summary>
            <param name="value">Число</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GetMinor(System.Int32,System.Int32)">
            <summary>
            Получение минора
            </summary>
            <param name="h">Без какой строки</param>
            <param name="w">Без какого столбца</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GetInvertMatrix">
            <summary>
            Вычисление обратной матрицы
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Min">
            <summary>
            Минимальное значение матрицы
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Max">
            <summary>
             Максимальное значение(Matrix)
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Mean">
            <summary>
            Среднее арифметическое матрицы 
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Sum">
            <summary>
            Сумма 
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Dispersion">
            <summary>
            Дисперсия
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Std">
            <summary>
            Среднеквадратичное отклонение
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.AdamarProduct(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Адамарово произведение(поэлементное)
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.MaxPool(System.Int32,System.Int32,System.Int32[0:,0:]@)">
            <summary>
            Макс пулинг
            </summary>
            <param name="poolH">Шаг по высоте</param>
            <param name="poolW">Шаг по ширине</param>
            <param name="indexPool">Максимальные индексы в исходной матрице</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.MulMatrOnVectColumn(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Умножение матрицы на вектор столбец
            </summary>
            <param name="vectCol">Вектор столбец</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Minimax(System.Double,System.Double)">
            <summary>
            Минимакс нормализация
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.LikeVector">
            <summary>
             Представление матрицы как вектора
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GradientMatrixConvDelts(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Градиент свертки
            </summary>
            <param name="core"></param>
            <param name="delts"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Region(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Выделение региона
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="dx"></param>
            <param name="dy"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Transpose">
            <summary>
            Транспонирование матрицы
            </summary>
            <returns>Возвращает транспонированную матрицу</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Transform(System.Func{System.Double,System.Double})">
            <summary>
            Трансформирование матрицы
            </summary>
            <param name="transformFunc">Функция трансформации</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Copy">
            <summary>
            Копирование матрицы
            </summary>
            <returns>Возвращает копию</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Round(System.Int32)">
            <summary>
            Окугление значений
            </summary>
            <param name="n">До какого знака</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.ToTriangularMatr">
            <summary>
            Переводит произвольную матрицу в треугольную
            </summary>
            <returns>Диагональная матрица</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GetVector(System.Int32,System.Int32)">
            <summary>
            Возвращает вектор с нужного среза, нужный индекс
            </summary>
            <param name="index">Индекс</param>
            <param name="dimension">Срез/размерность</param>
            <returns>Вектор</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Swap(System.Int32,System.Int32,System.Int32)">
            <summary>
            Перегруппировка матрицы (Замена индексов)
            </summary>
            <param name="i">На какой индекс заменить</param>
            <param name="j">Какой индекс заменить</param>
            <param name="dimension">Размерность среза 0 или 1</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.NanToMeanOfFeatures(AI.DataStructs.Algebraic.Matrix[])">
            <summary>
            Замена неопределенности средним значением
            </summary>
            <param name="matrices"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Mul2VecFast(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Умножение вектора-столбца на вектор строку, возвращается матрица результата
            </summary>
            <param name="ABinaryBip">Бинарный вектор</param>
            <param name="B">строка</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Mul2Vec(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Умножение вектора-столбца на вектор строку, возвращается матрица результата
            </summary>
            <param name="A">столбец</param>
            <param name="B">строка</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Sum2Vec(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Сложение вектора-столбца на вектор строку по следующему правилу "matr[i, j] = B[j] + A[i];" возвращается матрица результата
            </summary>
            <param name="A">столбец</param>
            <param name="B">строка</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Norm2Vec(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисление нормы по след. правилу  matr[i, j] = Math.Sqrt(B[j]*B[j]+ A[i]*A[i]);, возвращается матрица результата
            </summary>
            <param name="A">столбец</param>
            <param name="B">строка</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Pow(AI.DataStructs.Algebraic.Matrix,System.Int32)">
            <summary>
            Возведение матрицы в степень 
            путем матричного умножения на саму себя
            </summary>
            <param name="A">Входная матрица</param>
            <param name="exponent">Степень</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GetColumns(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Разложение матрицы на столбцы
            </summary>
            <param name="matr">Матрица</param>
            <returns>Массив векторов</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GetRows(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Разложение матрицы на строки
            </summary>
            <param name="matr">Матрица</param>
            <returns>Массив векторов</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.AlternativMatrix(System.Func{System.Double,System.Double}[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Альтернативная матрица
            </summary>
            <param name="functions">Функции</param>
            <param name="values">Значения</param>
            <returns>Возвращает альтернативную матрицу</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.OrtogonalMatrix(System.Func{System.Int32,System.Double,System.Double},AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Ортогональная матрица
            </summary>
            <param name="functions">Порождающая функция</param>
            <param name="values">Значения</param>
            <param name="count">Число выходов</param>
            <returns>Возвращает ортогональную матрицу</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GetCorrelationMatrixNorm(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Метод создает матрицу с коэффициентами попарной корреляции векторов
            </summary>
            <param name="vectors">Вектора</param>
            <returns>Корреляционная матрица</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GetCovMatrix(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Метод создает матрицу с коэффициентами попарной ковариции векторов
            </summary>
            <param name="vectors">Вектора</param>
            <returns>Ковариационнай матрица</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GetCovMatrixFromColumns(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Метод создает матрицу с коэффициентами попарной ковариции векторов
            </summary>
            <param name="matrix">Матрица</param>
            <returns>Ковариационнай матрица</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.MeanMatrix(AI.DataStructs.Algebraic.Matrix[])">
            <summary>
            Матрица средних 
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.DispersionMatrix(AI.DataStructs.Algebraic.Matrix[])">
            <summary>
            Матрица дисперсий 
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.StdMatrix(AI.DataStructs.Algebraic.Matrix[])">
            <summary>
            Матрица среднеквадратичных отклонений
            </summary>
            <param name="matrices">Массив матриц</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Parse(System.String)">
            <summary>
            Инициализация матрицы с помощью строки
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Parse(System.String,System.Globalization.NumberFormatInfo)">
            <summary>
            Инициализация матрицы с помощью строки
            </summary>
            <param name="str"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.TryParse(System.String,AI.DataStructs.Algebraic.Matrix@)">
            <summary>
            Инициализация матрицы с помощью строки
            </summary>
            <param name="str"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.TryParse(System.String,AI.DataStructs.Algebraic.Matrix@,System.Globalization.NumberFormatInfo)">
            <summary>
            Инициализация матрицы с помощью строки
            </summary>
            <param name="str"></param>
            <param name="result"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.FromVectorsAsRows(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Vector})">
            <summary>
            Инициализация матрицы с помощью векторов-строк
            </summary>
            <param name="rows">Строки</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.FromVectorsAsColumns(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Vector})">
            <summary>
            Инициализация матрицы с помощью векторов-столбцов
            </summary>
            <param name="colums">Столбцы матрицы</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.FromStrings(System.String[0:,0:])">
            <summary>
            Инициализация матрицы с помощью двухмерного массива строк
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.FromStrings(System.String[0:,0:],System.Globalization.NumberFormatInfo)">
            <summary>
            Инициализация матрицы с помощью двухмерного массива строк
            </summary>
            <param name="arr"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.ToString">
            <summary>
            Преобразование матрицы в строку
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.ToString(System.Globalization.NumberFormatInfo)">
            <summary>
            Преобразование матрицы в строку
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Equals(System.Object)">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Equals(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GetHashCode">
            <summary>
            Получение хэша
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Save(System.String)">
            <summary>
            Сохранение матрицы в файл
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Save(System.IO.Stream)">
            <summary>
            Сохранение матрицы в поток
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.SaveAsText(System.String)">
            <summary>
            Сохранение матрицы в файл в текстовом формате
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.GetBytes">
            <summary>
            Представление массивом байт
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Load(System.String)">
            <summary>
            Загрузка матрицы
            </summary>
            <param name="path">Путь до файла</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.Load(System.IO.Stream)">
            <summary>
            Загрузка матрицы
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.LoadAsText(System.String)">
            <summary>
            Загрузка матрицы
            </summary>
            <param name="path">Путь до файла</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.FromBytes(System.Byte[])">
            <summary>
            Загрузка матрицы
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Matrix.FromDataStream(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Загрузка матрицы
            </summary>
            <param name="dataStream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.DataStructs.Algebraic.MatrixType">
            <summary>
            Тип матрицы
            </summary>
        </member>
        <member name="F:AI.DataStructs.Algebraic.MatrixType.Image">
            <summary>
            Изображение
            </summary>
        </member>
        <member name="F:AI.DataStructs.Algebraic.MatrixType.MatStruct">
            <summary>
            Математическая структура
            </summary>
        </member>
        <member name="T:AI.DataStructs.Algebraic.NDTensor">
            <summary>
            Многомерный тензор
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.NDTensor.Data">
            <summary>
            Данные тензора
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.NDTensor.Shape">
            <summary>
            Размерность тензора
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.NDTensor.Item(System.Int32[])">
            <summary>
            Обращение к элементам через индексы
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.#ctor(AI.DataStructs.Shapes.Shape)">
            <summary>
            Многомерный тензор
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.#ctor(System.Int32[])">
            <summary>
            Многомерный тензор
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.op_Equality(AI.DataStructs.Algebraic.NDTensor,AI.DataStructs.Algebraic.NDTensor)">
            <summary>
            Оператор "равно"
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.op_Inequality(AI.DataStructs.Algebraic.NDTensor,AI.DataStructs.Algebraic.NDTensor)">
            <summary>
            Оператор "неравно"
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.op_Addition(AI.DataStructs.Algebraic.NDTensor,AI.DataStructs.Algebraic.NDTensor)">
            <summary>
            Сложение
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.op_Addition(System.Double,AI.DataStructs.Algebraic.NDTensor)">
            <summary>
            Сложение
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.op_Addition(AI.DataStructs.Algebraic.NDTensor,System.Double)">
            <summary>
            Сложение
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.op_Multiply(AI.DataStructs.Algebraic.NDTensor,AI.DataStructs.Algebraic.NDTensor)">
            <summary>
            Умножение
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.op_Multiply(System.Double,AI.DataStructs.Algebraic.NDTensor)">
            <summary>
            Умножение
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.op_Multiply(AI.DataStructs.Algebraic.NDTensor,System.Double)">
            <summary>
            Умножение
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.op_Subtraction(AI.DataStructs.Algebraic.NDTensor,AI.DataStructs.Algebraic.NDTensor)">
            <summary>
            Разность
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.op_Subtraction(System.Double,AI.DataStructs.Algebraic.NDTensor)">
            <summary>
            Разность
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.op_Subtraction(AI.DataStructs.Algebraic.NDTensor,System.Double)">
            <summary>
            Разность
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.op_Division(AI.DataStructs.Algebraic.NDTensor,AI.DataStructs.Algebraic.NDTensor)">
            <summary>
            Отношение
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.op_Division(System.Double,AI.DataStructs.Algebraic.NDTensor)">
            <summary>
            Отношение
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.op_Division(AI.DataStructs.Algebraic.NDTensor,System.Double)">
            <summary>
            Отношение
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.op_Modulus(AI.DataStructs.Algebraic.NDTensor,AI.DataStructs.Algebraic.NDTensor)">
            <summary>
            Остаток от деления
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.op_Modulus(System.Double,AI.DataStructs.Algebraic.NDTensor)">
            <summary>
            Остаток от деления
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.op_Modulus(AI.DataStructs.Algebraic.NDTensor,System.Double)">
            <summary>
            Остаток от деления
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.ToVector">
            <summary>
            Преобразование в вектор
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.ToNNTensor">
            <summary>
            Перевод в переменную нейросети
            </summary>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.ToTensor">
            <summary>
            Перевод в тензор
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.ToMatrix">
            <summary>
            Переводит в матрицу
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.Reshape(AI.DataStructs.Shapes.Shape)">
            <summary>
            Изменение формы
            </summary>
            <param name="new_shape">Новая форма</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.FromIAlgStruct(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Создание тензора из алгебраической структуры
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.FromNNValue(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Создание тензора из данных нейросети
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.Equals(System.Object)">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.Equals(AI.DataStructs.Algebraic.NDTensor)">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.GetHashCode">
            <summary>
            Получение хэшкода тензора
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.Save(System.String)">
            <summary>
            Сохранениеs NDTensor to file
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.Save(System.IO.Stream)">
            <summary>
            Сохранениеs NDTensor to stream
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.GetBytes">
            <summary>
            Represents NDTensor as an array of bytes
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.Load(System.String)">
            <summary>
            Loads NDTensor from file
            </summary>
            <param name="path">Путь до файла</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.Load(System.IO.Stream)">
            <summary>
            Loads NDTensor from stream
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.FromBytes(System.Byte[])">
            <summary>
            Initialize NDTensor form an array of bytes
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.NDTensor.FromDataStream(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Initialize NDTensor form a data stream
            </summary>
            <param name="dataStream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.DataStructs.Algebraic.Tensor">
            <summary>
            Тензор 3-го ранга
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Tensor.Height">
            <summary>
            Высота
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Tensor.Width">
            <summary>
            Ширина
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Tensor.Depth">
            <summary>
            Глубина
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Tensor.Shape">
            <summary>
            Форма тензора
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Tensor.Data">
            <summary>
            Данные
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Tensor.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Доступ к элементу по индексу
            </summary>
            <param name="i">Высота</param>
            <param name="j">Ширина</param>
            <param name="k">Глубина</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.#ctor(System.Double[0:,0:,0:])">
            <summary>
            Инициализация 3х-мерным массивом
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.#ctor(AI.DataStructs.Shapes.Shape3D)">
            <summary>
            Создает тензор заполненный нулями
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Создать тензор инициализированный нулями
            </summary>
            <param name="height">Высота</param>
            <param name="width">Ширина</param>
            <param name="depth">Глубина</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.#ctor(System.Double[])">
            <summary>
            Инициализация массивом
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Addition(AI.DataStructs.Algebraic.Tensor,System.Double)">
            <summary>
            Сложение
            </summary>
            <param name="A"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Addition(AI.DataStructs.Algebraic.Tensor,AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Сложение
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Addition(System.Double,AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Сложение
            </summary>
            <param name="A"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Multiply(AI.DataStructs.Algebraic.Tensor,System.Double)">
            <summary>
            Умножение
            </summary>
            <param name="A"></param>
            <param name="K"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Multiply(System.Double,AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Умножение
            </summary>
            <param name="A"></param>
            <param name="K"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Multiply(AI.DataStructs.Algebraic.Tensor,AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Умножение
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Division(AI.DataStructs.Algebraic.Tensor,System.Double)">
            <summary>
            Деление
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Division(System.Double,AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Деление
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Division(AI.DataStructs.Algebraic.Tensor,AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Деление
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Subtraction(AI.DataStructs.Algebraic.Tensor,System.Double)">
            <summary>
            Вычитание
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Subtraction(System.Double,AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Вычитание
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Subtraction(AI.DataStructs.Algebraic.Tensor,AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Вычитание
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Equality(AI.DataStructs.Algebraic.Tensor,AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.op_Inequality(AI.DataStructs.Algebraic.Tensor,AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Copy">
            <summary>
            Копирование
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Transform(System.Func{System.Double,System.Double})">
            <summary>
            Поэлементное преобразование тензора
            </summary>
            <param name="transform">Функция преобразования</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.ToMatrices">
            <summary>
            Конвертация тензор в массив матриц
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.FromMatrices(AI.DataStructs.Algebraic.Matrix[])">
            <summary>
            Конвертация массива матриц в тензор
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.VectorToTensor(AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32)">
            <summary>
            Конвертация вектора в тензор
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.SubtractingDepth(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Поэлементное вычитание из тензора по глубине TNew[i,j,k] = T[i,j,k] - V[k]
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.PlusD(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Поэлементное прибавление к тензору по глубине TNew[i,j,k] = T[i,j,k] + V[k]
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Sum">
            <summary>
            Сумма всех элементов тензора
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Mean">
            <summary>
            Среднее всех элементов тензора
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Dispersion(System.Double)">
            <summary>
            Дисперсия
            </summary>
            <param name="mean">Рассчитанное среднее</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Dispersion">
            <summary>
            Дисперсия
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Std(System.Double)">
            <summary>
            Среднеквадратичное отклонение
            </summary>
            <param name="mean">Рассчитанное среднее</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Std">
            <summary>
            Среднеквадратичное отклонение
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.ToString">
            <summary>
            Перевод тензора в строку
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.ToString(System.Globalization.NumberFormatInfo)">
            <summary>
            Перевод тензора в строку
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Equals(System.Object)">
            <summary>
            Сравнение с объектом
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Equals(AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Сравнение с другим тензором
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.GetHashCode">
            <summary>
            Вернуть хэш-код
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Save(System.String)">
            <summary>
            Сохранить в файл
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Save(System.IO.Stream)">
            <summary>
            Сохранить в  поток
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.GetBytes">
            <summary>
            Представить в виде массива байт
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Load(System.String)">
            <summary>
            Загрузить из файла
            </summary>
            <param name="path">Путь до файла</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.Load(System.IO.Stream)">
            <summary>
            Загрузить из потока
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.FromBytes(System.Byte[])">
            <summary>
            Загрузить из массива байт
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Tensor.FromDataStream(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Загрузить из массива объекта  InMemoryDataStream
            </summary>
            <param name="dataStream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.DataStructs.Algebraic.Vector">
            <summary>
            Класс, реализующий вектор и операции над ним
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Vector.AI#DataStructs#Algebraic#IAlgebraicStructure{System#Double}#Data">
            <summary>
            Данные вектора
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Vector.Shape">
            <summary>
            Форма (размерность вектора)
            </summary>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Vector.Item(System.Int32)">
            <summary>
            Получение значения по индексу, аналогично как Python(поддержка отрицательных индексов)
            </summary>
            <param name="i">Индекс</param>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Vector.Item(System.Boolean[])">
            <summary>
            Получение или установка значений по маске, аналогично как Python
            </summary>
            <param name="mask">Маска (true - позиции для вставки или извлечения)</param>
            <exception cref="T:System.Exception">Возникает исключение при несоответствии числа позиций для вставки и размерности вектора для вставки</exception>
        </member>
        <member name="P:AI.DataStructs.Algebraic.Vector.Item(System.Nullable{System.Int32},System.Nullable{System.Int32},System.Int32)">
            <summary>
            Получение среза, аналогично как Python(поддержка отрицательных индексов и шагов)
            </summary>
            <param name="start">Начало</param>
            <param name="end">Конец</param>
            <param name="step">Шаг (если отрицательный, то последовательность переворачивается)</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.#ctor">
            <summary>
            Создает вектор емкости 0
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.#ctor(System.Int32)">
            <summary>
            Создает вектор емкости n
            </summary>
            <param name="n"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.#ctor(System.Double)">
            <summary>
            Создает вектор размерности 1 с заданным значением
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.#ctor(System.Double[])">
            <summary>
            Создает вектор из массива чисел типа double
            </summary>
            <param name="vector"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.#ctor(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Создает вектор из интерфейса IEnumerable double
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.#ctor(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Создает вектор из интерфейса IEnumerable float
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Addition(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Addition
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Addition(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Addition
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Addition(System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Addition
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Subtraction(System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычитание
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Subtraction(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Вычитание
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Subtraction(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычитание
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_UnaryNegation(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Negation
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Multiply(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Multiplication
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Multiply(System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Multiplication
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Multiply(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Multiplication
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Division(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Division
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Division(System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Division
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Division(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Division
            </summary>
            <param name="A"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Modulus(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Remainder of the division
            </summary>
            <param name="k"></param>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Modulus(System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Remainder of the division
            </summary>
            <param name="k"></param>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Modulus(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Remainder of the division for each element
            </summary>
            <param name="A"></param>
            <param name="B"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Equality(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Inequality(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Equality(AI.DataStructs.Algebraic.Vector,System.Collections.Generic.IList{System.Double})">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Inequality(AI.DataStructs.Algebraic.Vector,System.Collections.Generic.IList{System.Double})">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Equality(System.Collections.Generic.List{System.Double},AI.DataStructs.Algebraic.Vector)">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Inequality(System.Collections.Generic.List{System.Double},AI.DataStructs.Algebraic.Vector)">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Implicit(AI.DataStructs.Algebraic.Vector)~System.Double[]">
            <summary>
            Преобразование типа
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Implicit(System.Double[])~AI.DataStructs.Algebraic.Vector">
            <summary>
            Преобразование типа
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Implicit(System.Int32[])~AI.DataStructs.Algebraic.Vector">
            <summary>
            Преобразование типа
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Implicit(System.Single[])~AI.DataStructs.Algebraic.Vector">
            <summary>
            Преобразование типа
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Explicit(AI.DataStructs.Algebraic.Vector)~System.Single[]">
            <summary>
            Преобразование типа
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.op_Explicit(AI.DataStructs.Algebraic.Vector)~System.Int32[]">
            <summary>
            Преобразование типа
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Decomposition">
            <summary>
            Декомпозиция вектора, где каждая компонента представляется отдельным вектором
            [a, b, c, d] -> [[a], [b], [c], [d]]
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.AddCB(System.Double)">
            <summary>
            Добавление числа в циклический буфер
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.AddCBE(System.Double)">
            <summary>
            Добавление в конец циклического буфера
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.NanToValue(System.Double)">
            <summary>
            Замена неопределенности на указанное число
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.NanToMean">
            <summary>
            Замена неопределенности на среднее
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Repeat(System.Int32)">
            <summary>
            Повтор вектора
            </summary>
            <param name="count">Число повторов</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Cos(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Косинусное расстояние между векторами
            </summary>
            <param name="vect"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.MaxOutVector(System.Double,System.Double)">
            <summary>
            Получение вектора с единицей в позиции индекса с максимальным значением и -1 в остальных
            </summary>
            <param name="max">Значение в максимуме</param>
            <param name="rest">Значение в на остальных позициях</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.GetUnitVector">
            <summary>
            Вектор направления (с единичной длинной) 
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Round(System.Int32)">
            <summary>
            Окугление
            </summary>
            <param name="num"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.ElementsDel(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Удаление выбранных элементов
            </summary>
            <param name="elements"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.ElementsDel(System.Double[])">
            <summary>
            Удаление выбранных элементов
            </summary>
            <param name="elements"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.ElementsDel(System.Collections.Generic.List{System.Double})">
            <summary>
            Удаление выбранных элементов
            </summary>
            <param name="elements"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.GetIntervalDouble(System.Int32,System.Int32,System.Double[])">
            <summary>
            Вернуть регион [a; b)
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.GetInterval(System.Int32,System.Int32)">
            <summary>
            Вернуть регион [a; b)
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Clone">
            <summary>
            Клонирование(копирование) вектора
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.AddSimmetr">
            <summary>
            Добавление зеркально отраженного вектора к текущему
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Revers">
            <summary>
            Изменение порядка следования компонент вектора {1,2,3} -> {3,2,1}
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.CutAndZero(System.Int32)">
            <summary>
            Обрезка или заполнение нулями вектора до нужного размера 
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Shift(System.Int32)">
            <summary>
            Сдвиг на несколько единиц {1,0, 2, 3} -3-> {0, 0, 0, 1, 0, 2, 3}
            </summary>
            <param name="valueShift"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.ToMatrix">
            <summary>
            Перевод вектора в матрицу
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Downsampling(System.Int32)">
            <summary>
            Прореживание (без фильтра)
            </summary>
            <param name="n"></param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Decimation(System.Int32)">
            <summary>
            Децимация, с использование филтра, обертка под NWave
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.UnPooling(System.Int32)">
            <summary>
            Увеличение размерности (аналог Up Sampling) 
            </summary>
            <param name="kUnPool">Восколько раз увеличить размерность</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.InterpolayrZero(System.Int32)">
            <summary>
            Ступенчатая интерполяция
            </summary>
            <param name="kInterp"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.AddOne">
            <summary>
            Добавить единицу в начало
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.IsFilledWithZeros">
            <summary>
            Является ли вектор нулевым
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.IsFilledWithZeros(System.Int32)">
            <summary>
            Проверяет, содержит ли вектор более n нулевых элементов
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Transform(System.Func{System.Double,System.Double})">
            <summary>
            Поэлементное изменение вектора с помощью функции transformFunc
            </summary>
            <param name="transformFunc"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.TransformByIndex(System.Func{System.Int32,System.Double})">
            <summary>
            Преобразование вектора
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.TransformFromIndexAndValue(System.Func{System.Int32,System.Double,System.Double})">
            <summary>
            Преобразование вектора
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.TransformWithArguments(AI.DataStructs.Algebraic.Vector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Преобразование вектора с использование вектора параметра(аргумента)
            output[i] = transformFunc(x[i], this[i]);
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Minimax">
            <summary>
            Нормализация вектора от 0 до 1
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Min">
            <summary>
            Минимальное значение
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Max">
            <summary>
             Максимальное значение
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.MaxAbs">
            <summary>
            Максимальное(по модулю) значение
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.MinAbs">
            <summary>
            Минимальное(по модулю) значение
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Mean">
            <summary>
            Среднее арифметическое
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Sum">
            <summary>
            Сумма компонент вектора
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.ContainsNan">
            <summary>
            Содержит ли вектор Nan
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Dispersion">
            <summary>
            Дисперсия
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Std">
            <summary>
             Среднеквадратичное отклонение
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.NormL2">
            <summary>
            L2 норма вектора
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.ZNormalise">
            <summary>
            Нормализация (ско = 1, среднее = 0)
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Normalise(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Нормализация (ско = 1, среднее = 0)
            </summary>
            <param name="mean"></param>
            <param name="std"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.MaxElementIndex">
            <summary>
            Индекс элемента с максимальным значением
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.AbsoluteMaxElementIndex">
            <summary>
            Индекс элемента с максимальным по модулю значением
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.MinElementIndex">
            <summary>
            Индекс элемента с минимальным значением
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.AbsoluteMinElementIndex">
            <summary>
            Индекс элемента с минимальным по модулю значением
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.MaxElementIndexInRegion(System.Int32,System.Int32)">
            <summary>
            Индекс элемента с максимальным значением
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.AbsoluteMaxElementIndexInRegion(System.Int32,System.Int32)">
            <summary>
            Индекс элемента с максимальным по модулю значением
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.MinElementIndexInRegion(System.Int32,System.Int32)">
            <summary>
            Индекс элемента с минимальным значением
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.AbsoluteMinElementIndexInRegion(System.Int32,System.Int32)">
            <summary>
            Индекс элемента с минимальным по модулю значением
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.IndexValueNeighborhoodMin(System.Double)">
            <summary>
            Индекс элемента с ближайшим минимальным значением
            </summary>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Crosser(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Смешивает два вектора, используя функцию смешивания
            </summary>
            <param name="x">Первый вектор</param>
            <param name="y">Второй вектор</param>
            <param name="cross">Функция смешивания</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.SummWithCollision(AI.DataStructs.Algebraic.Vector[],System.Int32)">
            <summary>
            Соединение векторов с перекрытием, суммированием в области перекрытия
            </summary>
            <param name="data">Векторы</param>
            <param name="col">Область перекрытия (коллизии)</param>
            <returns/>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.OneHotPol(System.Int32,System.Int32)">
            <summary>
            Преобразование индекса в one-hot вектор, на позиции индекса 1, на остальных 0
            </summary>
            <param name="index">Индекс</param>
            <param name="maxInd">Максимально возможный индекс</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.OneHotBePol(System.Int32,System.Int32)">
            <summary>
             Преобразование индекса в one-hot вектор, на позиции индекса 1, на остальных -1
            </summary>
            <param name="index">Индекс</param>
            <param name="maxInd">Максимально возможный индекс</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Concat(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Конкатенация (последовательное соединение) векторов
            </summary>
            <param name="vectors">Векторы</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.SeqBeginsWithZero(System.Double,System.Double)">
            <summary>
            Последовательность, начинающаяся с нуля
            </summary>
            <param name="step">Шаг</param>
            <param name="end">Последнее значение</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Seq(System.Double,System.Double,System.Double)">
            <summary>
            Последовательность
            </summary>
            <param name="step">Шаг</param>
            <param name="end">Последнее значение</param>
            <param name="start">Первое значение</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Time0(System.Double,System.Double)">
            <summary>
            Вектор отсчетов времени
            </summary>
            <param name="fd">Частота дискретизации</param>
            <param name="t">Время в секундах</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.GetWindows(AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32)">
            <summary>
            Разделить на окна (участки)
            </summary>
            <param name="inp">Вход</param>
            <param name="w">Размер окна</param>
            <param name="step">Шаг</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.GetWindowsWithFunc(System.Func{AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector},AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32)">
            <summary>
            Разделить на окна (участки)
            </summary>
            <param name="transformer">Функция преобразования</param>
            <param name="inp">Вход</param>
            <param name="w">Размер окна</param>
            <param name="step">Шаг</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.GetWindowsWithFuncVect(System.Func{AI.DataStructs.Algebraic.Vector,System.Double},AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32)">
            <summary>
            Разделить на окна (участки)
            </summary>
            <param name="transformer">Функция преобразования</param>
            <param name="inp">Вход</param>
            <param name="w">Размер окна</param>
            <param name="step">Шаг</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.ScaleData(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Масштабирование векторов (z-нормализация)
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Mean(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Усреднение по ансамблю
            </summary>
            <param name="vectors">Ансамбль векторов</param>
            <returns>Avarage vector</returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Std(AI.DataStructs.Algebraic.Vector[])">
            <summary>
             Среднеквадратичное отклонение в ансамбле
            </summary>
            <param name="vectors">Ансамбль векторов</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Parse(System.String)">
            <summary>
            Инициализация вектора с помощью строки
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Parse(System.String,System.Globalization.NumberFormatInfo)">
            <summary>
            Инициализация вектора с помощью строки
            </summary>
            <param name="str"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.TryParse(System.String,AI.DataStructs.Algebraic.Vector@)">
            <summary>
            Инициализация вектора с помощью строки
            </summary>
            <param name="str"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.TryParse(System.String,AI.DataStructs.Algebraic.Vector@,System.Globalization.NumberFormatInfo)">
            <summary>
            Инициализация вектора с помощью строки
            </summary>
            <param name="str"></param>
            <param name="result"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.FromStrings(System.String[])">
            <summary>
            Инициализация вектора с помощью массива строк
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.FromStrings(System.String[],System.Globalization.NumberFormatInfo)">
            <summary>
            Инициализация вектора с помощью массива строк
            </summary>
            <param name="arr"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.FromList(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Создание вектора с помощью перечисления
            </summary>
            <param name="dbs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.ToString">
            <summary>
            Перевод вектора в строку
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.ToString(System.Globalization.NumberFormatInfo)">
            <summary>
            Перевод вектора в строку
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Equals(System.Object)">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Equals(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Equals(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Equals(System.Collections.Generic.List{System.Double})">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.GetHashCode">
            <summary>
            Получение хэш кода
            </summary>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Save(System.String)">
            <summary>
            Сохранить в файл
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Save(System.IO.Stream)">
            <summary>
            Сохранениеs vector to stream
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.SaveAsText(System.String)">
            <summary>
            Сохранить в текстовый файл
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.GetBytes">
            <summary>
            Представить в виде массива байт
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Load(System.String)">
            <summary>
            Загрузить из файла
            </summary>
            <param name="path">Путь до файла</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.LoadAsBinary(System.String)">
            <summary>
            Загрузка вектора из массива double
            </summary>
            <param name="path">Путь</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.SaveAsBinary(System.String,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Сохранение в массив double
            </summary>
            <param name="path">Путь до файла</param>
            <param name="vect">Вектор</param>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.Load(System.IO.Stream)">
            <summary>
            Загрузить из потока
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.LoadAsText(System.String)">
             <summary>
            Загрузить из текстового файла
             </summary>
             <param name="path">Путь до файла</param>
             <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.FromBytes(System.Byte[])">
            <summary>
            Инициализировать массивом байт
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Algebraic.Vector.FromDataStream(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Инициализировать потоком данных
            </summary>
            <param name="dataStream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.DataStructs.BinarySerializer">
            <summary>
            Вспомогательный класс для бинарной сериализации
            </summary>
        </member>
        <member name="M:AI.DataStructs.BinarySerializer.Load``1(System.String)">
            <summary>
            Загрузка из потока
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.BinarySerializer.Load``1(System.IO.Stream)">
            <summary>
            Загрузка из потока
            </summary>
            <typeparam name="T"></typeparam>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.BinarySerializer.Save``1(System.String,``0)">
            <summary>
            Сохранение в бинарный файл
            </summary>
            <param name="filePath"></param>
            <param name="data"></param>
        </member>
        <member name="M:AI.DataStructs.BinarySerializer.Save``1(System.IO.Stream,``0)">
            <summary>
            Сохранение в поток
            </summary>
            <param name="stream">Поток</param>
            <param name="data"></param>
        </member>
        <member name="T:AI.DataStructs.Data.IntArrayEqualityComparer">
            <summary>
            Класс для сравнения и генерации хэшей массива целых чисел
            </summary>
        </member>
        <member name="M:AI.DataStructs.Data.IntArrayEqualityComparer.Equals(System.Int32[],System.Int32[])">
            <summary>
            Проверка равенства
            </summary>
            <param name="left">Левая часть равенства</param>
            <param name="right">Правая часть равенства</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Data.IntArrayEqualityComparer.GetHashCode(System.Int32[])">
            <summary>
            Генерация хэша
            </summary>
            <param name="array">Массив int</param>
            <returns></returns>
        </member>
        <member name="T:AI.DataStructs.Data.RingBuffer`1">
            <summary>
            Циклический буфер
            </summary>
        </member>
        <member name="P:AI.DataStructs.Data.RingBuffer`1.Data">
            <summary>
            Данные буфера
            </summary>
        </member>
        <member name="P:AI.DataStructs.Data.RingBuffer`1.Item(System.Int32)">
            <summary>
            Доступ по индексу
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:AI.DataStructs.Data.RingBuffer`1.Length">
            <summary>
            Число элементов буфера
            </summary>
        </member>
        <member name="M:AI.DataStructs.Data.RingBuffer`1.#ctor(System.Int32)">
            <summary>
            Создание буфера нужной длинны
            </summary>
            <param name="length">Длинна</param>
        </member>
        <member name="M:AI.DataStructs.Data.RingBuffer`1.#ctor(System.Int32,`0)">
            <summary>
            Создание буфера нужной длинны
            </summary>
            <param name="length">Длинна</param>
            <param name="defoultElement">Элемент поумолчанию, до заполнения</param>
        </member>
        <member name="M:AI.DataStructs.Data.RingBuffer`1.op_Implicit(AI.DataStructs.Data.RingBuffer{`0})~`0[]">
            <summary>
            Преобразование циклического буфера в массив
            </summary>
            <param name="buffer">Буффер</param>
        </member>
        <member name="M:AI.DataStructs.Data.RingBuffer`1.op_Explicit(`0[])~AI.DataStructs.Data.RingBuffer{`0}">
            <summary>
            Преобразование в циклический буффер
            </summary>
            <param name="elements"></param>
        </member>
        <member name="M:AI.DataStructs.Data.RingBuffer`1.AddElement(`0)">
            <summary>
            Добавление элемента в буфер(в конец)
            </summary>
        </member>
        <member name="T:AI.DataStructs.IByteConvertable">
            <summary>
            Объект с поддержкой бинарной сериализации
            </summary>
        </member>
        <member name="M:AI.DataStructs.IByteConvertable.GetBytes">
            <summary>
            Преобразование объекта в массив байт
            </summary>
        </member>
        <member name="T:AI.DataStructs.InMemoryDataStream">
            <summary>
            Class for simple IO operations
            </summary>
        </member>
        <member name="P:AI.DataStructs.InMemoryDataStream.IsZipped">
            <summary>
            Tells if data in the stream is zipped
            </summary>
        </member>
        <member name="P:AI.DataStructs.InMemoryDataStream.IsEncrypted">
            <summary>
            Tells if data in the stream is encrypted
            </summary>
        </member>
        <member name="P:AI.DataStructs.InMemoryDataStream.IsForReading">
            <summary>
            Tells if stream is opened for reading
            </summary>
        </member>
        <member name="P:AI.DataStructs.InMemoryDataStream.IsForWriting">
            <summary>
            Tells if stream is opened for writing
            </summary>
        </member>
        <member name="P:AI.DataStructs.InMemoryDataStream.IV">
            <summary>
            AES algorithm initialization vector
            </summary>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.#ctor">
            <summary>
            Creates DataStream for writing data
            </summary>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.#ctor(System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates DataStream for reading data from file
            </summary>
            <param name="path">Путь до файла</param>
            <param name="isEncrypted"></param>
            <param name="isZipped"></param>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.#ctor(System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            Creates DataStream for reading data from byte array
            </summary>
            <param name="data"></param>
            <param name="isEncrypted"></param>
            <param name="isZipped"></param>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.#ctor(System.IO.Stream,System.Boolean,System.Boolean)">
            <summary>
            Creates DataStream for reading data from System.IO.Stream
            </summary>
            <param name="stream">Поток</param>
            <param name="isEncrypted"></param>
            <param name="isZipped"></param>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Int32)">
            <summary>
            Writes int to the stream
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Int16)">
            <summary>
            Writes short to the stream
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Byte)">
            <summary>
            Writes byte to the stream
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Double)">
            <summary>
            Writes double to the stream
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Single)">
            <summary>
            Writes float to the stream
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Int64)">
            <summary>
            Writes long to the stream
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.String)">
            <summary>
            Writes string in utf-8 encoding to the stream
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.WriteOnlyContent(System.String)">
            <summary>
            Writes string in utf-8 encoding to the stream
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.String,System.Text.Encoding)">
            <summary>
            Writes string in custom encoding to the stream
            </summary>
            <param name="str"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.WriteOnlyContent(System.String,System.Text.Encoding)">
            <summary>
            Writes string in custom encoding to the stream
            </summary>
            <param name="str"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Byte[])">
            <summary>
            Writes byte array to the stream
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Double[])">
            <summary>
            Writes double array to the stream
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Single[])">
            <summary>
            Writes float array to the stream
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Int32[])">
            <summary>
            Writes int array to the stream
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Int16[])">
            <summary>
            Writes short array to the stream
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Int64[])">
            <summary>
            Writes long array to the stream
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Char[])">
            <summary>
            Writes char array to the stream
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.WriteOnlyContent(System.Double[])">
            <summary>
            Writes double array content to the stream
            </summary>
            <param name="dat"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.WriteOnlyContent(System.Single[])">
            <summary>
            Writes float array content to the stream
            </summary>
            <param name="dat"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.WriteOnlyContent(System.Int32[])">
            <summary>
            Writes int array content to the stream
            </summary>
            <param name="dat"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.WriteOnlyContent(System.Int64[])">
            <summary>
            Writes long array content to the stream
            </summary>
            <param name="dat"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.WriteOnlyContent(System.Int16[])">
            <summary>
            Writes short array content to the stream
            </summary>
            <param name="dat"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.WriteOnlyContent(System.Char[])">
            <summary>
            Writes char array content to the stream
            </summary>
            <param name="dat"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Write(System.Char)">
            <summary>
            Writes char to the stream
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadInt">
            <summary>
            Reads int from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadInt(System.Int32@)">
            <summary>
            Reads int from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadLong">
            <summary>
            Reads long from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadLong(System.Int64@)">
            <summary>
            Reads long from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadShort">
            <summary>
            Reads short from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadShort(System.Int16@)">
            <summary>
            Reads short from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadByte">
            <summary>
            Reads byte from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadByte(System.Byte@)">
            <summary>
            Reads byte from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadDouble">
            <summary>
            Reads double from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadDouble(System.Double@)">
            <summary>
            Reads double from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadFloat">
            <summary>
            Reads float from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadFloat(System.Single@)">
            <summary>
            Reads float from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadString">
            <summary>
            Reads string in utf-8 encoding from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadString(System.String@)">
            <summary>
            Reads string in utf-8 encoding from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadString(System.Text.Encoding)">
            <summary>
            Reads string in custom encoding from the stream
            </summary>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadString(System.String@,System.Text.Encoding)">
            <summary>
            Reads string in custom encoding from the stream
            </summary>
            <param name="result"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadBytes">
            <summary>
            Reads byte array from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadBytes(System.Byte[]@)">
            <summary>
            Reads byte array from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadDoubles">
            <summary>
            Reads double array from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadDoubles(System.Double[]@)">
            <summary>
            Reads double array from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadFloats">
            <summary>
            Reads float array from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadFloats(System.Single[]@)">
            <summary>
            Reads float array from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadInts">
            <summary>
            Reads int array from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadInts(System.Int32[]@)">
            <summary>
            Reads int array from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadShorts">
            <summary>
            Reads short array from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadShorts(System.Int16[]@)">
            <summary>
            Reads short array from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadLongs">
            <summary>
            Reads long array from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadLongs(System.Int64[]@)">
            <summary>
            Reads long array from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadChars">
            <summary>
            Reads char array from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadChars(System.Char[]@)">
            <summary>
            Reads char array from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadDoubles(System.Int32)">
            <summary>
            Reads double array of a given length from the stream
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadDoubles(System.Int32,System.Double[]@)">
            <summary>
            Reads double array of a given length from the stream
            </summary>
            <param name="length"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadFloats(System.Int32)">
            <summary>
            Reads float array of a given length from the stream
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadFloats(System.Int32,System.Single[]@)">
            <summary>
            Reads double array of a given length from the stream
            </summary>
            <param name="length"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadInts(System.Int32)">
            <summary>
            Reads int array of a given length from the stream
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadInts(System.Int32,System.Int32[]@)">
            <summary>
            Reads int array of a given length from the stream
            </summary>
            <param name="length"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadLongs(System.Int32)">
            <summary>
            Reads long array of a given length from the stream
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadLongs(System.Int32,System.Int64[]@)">
            <summary>
            Reads long array of a given length from the stream
            </summary>
            <param name="length"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadShorts(System.Int32)">
            <summary>
            Reads short array of a given length from the stream
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadShorts(System.Int32,System.Int16[]@)">
            <summary>
            Reads short array of a given length from the stream
            </summary>
            <param name="length"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadChars(System.Int32)">
            <summary>
            Reads char array of a given length from the stream
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadChars(System.Int32,System.Char[]@)">
            <summary>
            Reads char array of a given length from the stream
            </summary>
            <param name="length"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadChar">
            <summary>
            Reads char from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ReadChar(System.Char@)">
            <summary>
            Reads char from the stream
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadInt(System.Int32@)">
            <summary>
            Tries to read int from the stream. Returns if operation succeeded
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadInt(System.Int32@,System.Boolean@)">
            <summary>
            Tries to read int from the stream
            </summary>
            <param name="result"></param>
            <param name="succeeded"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadLong(System.Int64@)">
            <summary>
            Tries to read long from the stream. Returns if operation succeeded
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadLong(System.Int64@,System.Boolean@)">
            <summary>
            Tries to read long from the stream
            </summary>
            <param name="result"></param>
            <param name="succeeded"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadShort(System.Int16@)">
            <summary>
            Tries to read short from the stream. Returns if operation succeeded
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadShort(System.Int16@,System.Boolean@)">
            <summary>
            Tries to read short from the stream
            </summary>
            <param name="result"></param>
            <param name="succeeded"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadByte(System.Byte@)">
            <summary>
            Tries to read byte from the stream. Returns if operation succeeded
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadByte(System.Byte@,System.Boolean@)">
            <summary>
            Tries to read byte from the stream
            </summary>
            <param name="result"></param>
            <param name="succeeded"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadDouble(System.Double@)">
            <summary>
            Tries to read double from the stream. Returns if operation succeeded
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadDouble(System.Double@,System.Boolean@)">
            <summary>
            Tries to read double from the stream
            </summary>
            <param name="result"></param>
            <param name="succeeded"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadFloat(System.Single@)">
            <summary>
            Tries to read float from the stream. Returns if operation succeeded
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadFloat(System.Single@,System.Boolean@)">
            <summary>
            Tries to read float from the stream
            </summary>
            <param name="result"></param>
            <param name="succeeded"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadString(System.String@)">
            <summary>
            Tries to read string in utf-8 encoding from the stream. Returns if operation succeeded
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadString(System.String@,System.Boolean@)">
            <summary>
            Tries to read string in utf-8 encoding from the stream
            </summary>
            <param name="result"></param>
            <param name="succeeded"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadString(System.String@,System.Text.Encoding)">
            <summary>
            Tries to read string in custom encoding from the stream. Returns if operation succeeded
            </summary>
            <param name="result"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadString(System.String@,System.Text.Encoding,System.Boolean@)">
            <summary>
            Tries to read string custom encoding from the stream
            </summary>
            <param name="result"></param>
            <param name="encoding"></param>
            <param name="succeeded"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadChar(System.Char@)">
            <summary>
            Tries to read char from the stream. Returns if operation succeeded
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.TryReadChar(System.Char@,System.Boolean@)">
            <summary>
            Tries to read char from the stream
            </summary>
            <param name="result"></param>
            <param name="succeeded"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Skip">
            <summary>
            Skip bytes of count equal to next int in the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Skip(System.Int32)">
            <summary>
            Skip given count of bytes
            </summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.SkipIfEqual(System.Int32)">
            <summary>
            Skips next int in the stream if the value is equal to given
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.SkipIfEqual(System.Int64)">
            <summary>
            Skips next long in the stream if the value is equal to given
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.SkipIfEqual(System.Int16)">
            <summary>
            Skips next short in the stream if the value is equal to given
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.SkipIfEqual(System.Double)">
            <summary>
            Skips next double in the stream if the value is equal to given
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.SkipIfEqual(System.Single)">
            <summary>
            Skips next float in the stream if the value is equal to given
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.SkipIfEqual(System.Char)">
            <summary>
            Skips next char in the stream if the value is equal to given
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.SkipIfEqual(System.String)">
            <summary>
            Skips next string in utf-8 encoding in the stream if the value is equal to given
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.SkipIfEqual(System.String,System.Text.Encoding)">
            <summary>
            Skips next string in custom encoding in the stream if the value is equal to given
            </summary>
            <param name="value"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Int32)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Int32,System.Boolean@)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Int64)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Int64,System.Boolean@)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Int16)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Int16,System.Boolean@)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Byte)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Byte,System.Boolean@)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Double)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Double,System.Boolean@)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Single)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Single,System.Boolean@)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="n"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.String)">
            <summary>
            Checks if the next string in utf-8 encoding in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.String,System.Boolean@)">
            <summary>
            Checks if the next string in utf-8 encoding in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="str"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.String,System.Text.Encoding)">
            <summary>
            Checks if the next string in custom encoding in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="str"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.String,System.Text.Encoding,System.Boolean@)">
            <summary>
            Checks if the next string in custom encoding in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="str"></param>
            <param name="encoding"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Char)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.CheckIfEqual(System.Char,System.Boolean@)">
            <summary>
            Checks if the next value in the stream is equal to given. Position in the stream is not changed
            </summary>
            <param name="ch"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.NullIfEqual(System.Int32)">
            <summary>
            Returns null if the next value in the stream is equal to the given. If not, position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.NullIfEqual(System.Int64)">
            <summary>
            Returns null if the next value in the stream is equal to the given. If not, position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.NullIfEqual(System.Int16)">
            <summary>
            Returns null if the next value in the stream is equal to the given. If not, position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.NullIfEqual(System.Byte)">
            <summary>
            Returns null if the next value in the stream is equal to the given. If not, position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.NullIfEqual(System.Double)">
            <summary>
            Returns null if the next value in the stream is equal to the given. If not, position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.NullIfEqual(System.Single)">
            <summary>
            Returns null if the next value in the stream is equal to the given. If not, position in the stream is not changed
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.NullIfEqual(System.String)">
            <summary>
            Returns null if the next value in the stream is equal to the given. If not, position in the stream is not changed
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.NullIfEqual(System.String,System.Text.Encoding)">
            <summary>
            Returns null if the next value in the stream is equal to the given. If not, position in the stream is not changed
            </summary>
            <param name="str"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.NullIfEqual(System.Char)">
            <summary>
            Returns null if the next value in the stream is equal to the given. If not, position in the stream is not changed
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Zip">
            <summary>
            Zips data in the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.UnZip">
            <summary>
            Unzips data in the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Encrypt(System.String,System.String)">
            <summary>
            Encrypts data in the stream
            </summary>
            <param name="password"></param>
            <param name="salt"></param>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Decrypt(System.String,System.String)">
            <summary>
            Decrypts data in the stream
            </summary>
            <param name="password"></param>
            <param name="salt"></param>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.AsByteArray">
            <summary>
            Returns data as a byte array
            </summary>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ToMemoryStream">
            <summary>
            Returns data as a memory stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Save(System.String)">
            <summary>
            Сохранениеs data to the file
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Save(System.IO.Stream)">
            <summary>
            Сохранениеs data to the System.IO.Stream
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.ToString">
            <summary>
            Returns data as base64 string
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.Create">
            <summary>
            Initialize empty DataStream for writing data
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.FromFile(System.String,System.Boolean,System.Boolean)">
            <summary>
            Inintialize DataStream for reading data from file
            </summary>
            <param name="path">Путь до файла</param>
            <param name="isEncrypted"></param>
            <param name="isZipped"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.FromSystemStream(System.IO.Stream,System.Boolean,System.Boolean)">
            <summary>
            Inintialize DataStream for reading data from System.IO.Stream
            </summary>
            <param name="stream">Поток</param>
            <param name="isEncrypted"></param>
            <param name="isZipped"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.FromByteArray(System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            Inintialize DataStream for reading data from byte array
            </summary>
            <param name="data"></param>
            <param name="isEncrypted"></param>
            <param name="isZipped"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.InMemoryDataStream.FromBase64String(System.String,System.Boolean,System.Boolean)">
            <summary>
            Initialize DataStream from base64 string for reading data
            </summary>
            <param name="strBase64"></param>
            <param name="isEncrypted"></param>
            <param name="isZipped"></param>
            <returns></returns>
        </member>
        <member name="T:AI.DataStructs.ISavable">
            <summary>
            Объект, который может быть сохранен
            </summary>
        </member>
        <member name="M:AI.DataStructs.ISavable.Save(System.String)">
            <summary>
            Сохранение в файл
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.DataStructs.ISavable.Save(System.IO.Stream)">
            <summary>
            Сохранение в поток
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="T:AI.DataStructs.ITextSavable">
            <summary>
            Объект который может быть сохранен в текстовом виде
            </summary>
        </member>
        <member name="M:AI.DataStructs.ITextSavable.SaveAsText(System.String)">
            <summary>
            Сохранение в файл
            </summary>
            <param name="path">Путь</param>
        </member>
        <member name="T:AI.DataStructs.Shapes.Shape">
            <summary>
            Представляет собой многомерную форму
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape.Item(System.Int32)">
            <summary>
            Получить длину в определенном измерении
            </summary>
            <param name="dimension"></param>
            <returns></returns>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape.Rank">
            <summary>
            Ранг тензора (количество его измерений)
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape.Count">
            <summary>
            Количество элементов в форме (произведение длин всех измерений)
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape.#ctor(System.Int32[])">
             <summary>
            Создает многомерную форму
             </summary>
             <param name="values"></param>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape.op_Equality(AI.DataStructs.Shapes.Shape,AI.DataStructs.Shapes.Shape)">
            <summary>
            Сравнение форм
            </summary>
            <param name="shape1"></param>
            <param name="shape2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape.op_Inequality(AI.DataStructs.Shapes.Shape,AI.DataStructs.Shapes.Shape)">
            <summary>
            Сравнение форм
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape.Shrink">
            <summary>
            Уменьшение размерности на 1
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape.Expand(System.Int32)">
            <summary>
            Увеличение размерности на 1
            </summary>
            <param name="newDimensionLength"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape.FuzzyEquals(AI.DataStructs.Shapes.Shape)">
            <summary>
            Returns true if shapes has equal element count and only differs by dimenson count 
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape.GetDataCopy">
            <summary>
            Returns current object data copy as an array
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape.ToString">
            <summary>
            Перевод формы в строку
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape.Equals(System.Object)">
            <summary>
            Сравнение
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape.Equals(AI.DataStructs.Shapes.Shape)">
            <summary>
            Сравнение
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape.GetHashCode">
            <summary>
            Хэш-код
            </summary>
        </member>
        <member name="T:AI.DataStructs.Shapes.Shape1D">
            <summary>
            Одномерная форма
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape1D.Width">
            <summary>
            Ширина
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape1D.#ctor(System.Int32)">
            <summary>
            Одномерная форма
            </summary>
            <param name="width"></param>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape1D.op_Implicit(AI.DataStructs.Shapes.Shape1D)~AI.DataStructs.Shapes.Shape2D">
            <summary>
            Присвоение 2х мерной формы одномерной
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape1D.op_Implicit(AI.DataStructs.Shapes.Shape1D)~AI.DataStructs.Shapes.Shape3D">
            <summary>
            Присвоение 3х мерной формы одномерной
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape1D.op_Implicit(AI.DataStructs.Shapes.Shape1D)~AI.DataStructs.Shapes.Shape4D">
            <summary>
            Присвоение 4х мерной формы одномерной
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape1D.Expand(System.Int32)">
            <summary>
            Расширение формы
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape1D.ToString">
            <summary>
            Перевод в строку
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape1D.Equals(System.Object)">
            <summary>
            Сравнение
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape1D.Equals(AI.DataStructs.Shapes.Shape1D)">
            <summary>
            Сравнение
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape1D.GetHashCode">
            <summary>
            Получение хэш кода
            </summary>
        </member>
        <member name="T:AI.DataStructs.Shapes.Shape2D">
            <summary>
            Двумерная форма
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape2D.Height">
            <summary>
            Высота in 2D
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape2D.Width">
            <summary>
            Ширина in 2D
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape2D.Area">
            <summary>
            Product of Height and Width
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape2D.#ctor(System.Int32,System.Int32)">
            <summary>
            Создать двумерную форму
            </summary>
            <param name="height"></param>
            <param name="width"></param>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape2D.op_Implicit(AI.DataStructs.Shapes.Shape2D)~AI.DataStructs.Shapes.Shape3D">
            <summary>
            Создание 3х мерной формы
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape2D.op_Implicit(AI.DataStructs.Shapes.Shape2D)~AI.DataStructs.Shapes.Shape4D">
            <summary>
            Создание 4х мерной формы
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape2D.Shrink">
            <summary>
            Уменьшение размерности формы
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape2D.Expand(System.Int32)">
            <summary>
            Увеличение размерности формы
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape2D.ToString">
            <summary>
            Перевод в строку
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape2D.Equals(System.Object)">
            <summary>
            Сравнение
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape2D.Equals(AI.DataStructs.Shapes.Shape2D)">
            <summary>
            Сравнение
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape2D.GetHashCode">
            <summary>
            Хэш-код
            </summary>
        </member>
        <member name="T:AI.DataStructs.Shapes.Shape3D">
            <summary>
            Трехмерная форма
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape3D.Height">
            <summary>
            Высота тензора
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape3D.Width">
            <summary>
            Ширина тензора
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape3D.Depth">
            <summary>
            Глубина тензора
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape3D.Area">
            <summary>
            Площадь (Произведение ширины на глубину)
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape3D.Volume">
            <summary>
            Объем (произведение ширины, высоты и глубины) 
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape3D.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Трехмерная форма
            </summary>
            <param name="height">Высота</param>
            <param name="width">Ширина</param>
            <param name="depth">Глубина</param>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape3D.op_Implicit(AI.DataStructs.Shapes.Shape3D)~AI.DataStructs.Shapes.Shape4D">
            <summary>
            Преобразование трехмерной формы в четырех мерную
            </summary>
            <param name="shape"></param>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape3D.Shrink">
            <summary>
            Сжатие формы
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape3D.Expand(System.Int32)">
            <summary>
            Расширение формы
            </summary>
            <param name="newDimensionLength"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape3D.ToString">
            <summary>
            Преобразование формы в строку
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape3D.Equals(System.Object)">
            <summary>
            Проверка равенства
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape3D.Equals(AI.DataStructs.Shapes.Shape3D)">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape3D.GetHashCode">
            <summary>
            Проверка равенства
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape3D.FromeShape(AI.DataStructs.Shapes.Shape)">
            <summary>
            Создание 3х мерной из многомерной
            </summary>
        </member>
        <member name="T:AI.DataStructs.Shapes.Shape4D">
            <summary>
            Четырехмерная форма
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape4D.Height">
            <summary>
            Высота in 4D
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape4D.Width">
            <summary>
            Ширина in 4D
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape4D.Depth">
            <summary>
            Глубина in 4D
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape4D.X">
            <summary>
            Fourth dimension length
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape4D.Area">
            <summary>
            Product of Height and Width
            </summary>
        </member>
        <member name="P:AI.DataStructs.Shapes.Shape4D.Volume">
            <summary>
            Product of Height, Width and Depth
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape4D.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Четырехмерная форма
            </summary>
            <param name="height">Высота</param>
            <param name="width">Ширина</param>
            <param name="depth">Глубина</param>
            <param name="x">четвертая размерность</param>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape4D.Shrink">
            <summary>
            Сжатие формы
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape4D.ToString">
            <summary>
            Перевод в строку
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape4D.Equals(System.Object)">
            <summary>
            Сравнение
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape4D.Equals(AI.DataStructs.Shapes.Shape4D)">
            <summary>
            Сравнение
            </summary>
        </member>
        <member name="M:AI.DataStructs.Shapes.Shape4D.GetHashCode">
            <summary>
            Хэш-код
            </summary>
        </member>
        <member name="T:AI.DataStructs.TableOfContentsOfTheSortedVector">
            <summary>
            Оглавление сортированного вектора
            </summary>
        </member>
        <member name="M:AI.DataStructs.TableOfContentsOfTheSortedVector.#ctor(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Оглавление сортированного вектора
            </summary>
            <param name="vect">Сортированный вектор</param>
            <param name="numCh">Число глав</param>
        </member>
        <member name="M:AI.DataStructs.TableOfContentsOfTheSortedVector.IndexValueNeighborhoodMin(System.Double)">
            <summary>
            Ближайший минимальный индекс
            </summary>
            <param name="value">Значение</param>
        </member>
        <member name="T:AI.DataStructs.WithComplexElements.ComplexMatrix">
            <summary>
            Матрица с комплексными числами
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexMatrix.Data">
            <summary>
            Matrix data
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexMatrix.Height">
            <summary>
            Matrix height
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexMatrix.Width">
            <summary>
            Matrix width
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexMatrix.Shape">
            <summary>
            Matrix shape
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Get element by indexes
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexMatrix.RealMatrix">
            <summary>
            Real parts of all matrix components represented as algebraic matrix
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexMatrix.ImaginaryMatrix">
            <summary>
            Imaginary parts of all matrix components represented as algebraic matrix
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexMatrix.MagnitudeMatrix">
            <summary>
            Magnitude parts of all matrix components represented as algebraic matrix
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexMatrix.PhaseMatrix">
            <summary>
            Phase parts of all matrix components represented as algebraic matrix
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.#ctor">
            <summary>
            Creates matrix of 3x3 size
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates matrix of the given size
            </summary>
            <param name="height">Matrix Высота</param>
            <param name="width">Matrix Ширина</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.#ctor(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Creates matrix with real and imaginary element's parts represented as algebraic matrices
            </summary>
            <param name="real">Real element's part</param>
            <param name="imaginary">Imaginary element's part</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.#ctor(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Creates matrix with real element's parts represented as algebraic matrix and zero imaginary parts
            </summary>
            <param name="real">Реальная часть</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.op_Multiply(AI.DataStructs.WithComplexElements.ComplexMatrix,AI.DataStructs.WithComplexElements.ComplexMatrix)">
            <summary>
            Перемножение матриц
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.Transform(System.Func{System.Numerics.Complex,System.Numerics.Complex})">
            <summary>
            Поэлементное преобразование матриц
            </summary>
            <param name="func">Функция преобразования</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.TransformSelf(System.Func{System.Numerics.Complex,System.Numerics.Complex})">
            <summary>
            Матрица изменяет саму себя
            </summary>
            <param name="func">Функция преобразования</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.MatrixFFT(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Двумерное преобразование Фурье
            </summary>
            <param name="input">Вход</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.MatrixIFFT(AI.DataStructs.WithComplexElements.ComplexMatrix)">
            <summary>
            Обратное двумерное преобразование Фурье
            </summary>
            <param name="input">Входная матрица</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.MatrixFFT(AI.DataStructs.WithComplexElements.ComplexMatrix)">
            <summary>
            Двумерное преобразование Фурье
            </summary>
            <param name="input">Вход</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.GetColumns(AI.DataStructs.WithComplexElements.ComplexMatrix)">
            <summary>
            Разложение матрицы на столбцы
            </summary>
            <param name="matr">Матрица</param>
            <returns>Массив векторов</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.ConjugateMatr">
            <summary>
            Сопряженная матрица
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.AdamarProduct(AI.DataStructs.WithComplexElements.ComplexMatrix)">
            <summary>
            Адамарово произведение матриц (поэлементное)
            </summary>
            <param name="complexMatrix">Матрица на которую происходит умножение</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.AdamarProduct(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Адамарово произведение матриц (поэлементное)
            </summary>
            <param name="matrix">Матрица на которую происходит умножение</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.Save(System.String)">
            <summary>
            Сохранениеs matrix to file
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.Save(System.IO.Stream)">
            <summary>
            Сохранениеs matrix to stream
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.GetBytes">
            <summary>
            Представить в виде массива байт
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.Load(System.String)">
            <summary>
            Loads matrix from file
            </summary>
            <param name="path">Путь до файла</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.Load(System.IO.Stream)">
            <summary>
            Loads matrix from stream
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.FromBytes(System.Byte[])">
            <summary>
            Initializes matrix from byte array
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexMatrix.FromDataStream(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Initilizes matrix from data stream
            </summary>
            <param name="dataStream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.DataStructs.WithComplexElements.ComplexVector">
            <summary>
            Представляет вектор комплексных чисел
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexVector.AI#DataStructs#WithComplexElements#IComplexStructure#Data">
            <summary>
            Массив комплексных чисел
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexVector.Shape">
            <summary>
            Форма вектора
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexVector.RealVector">
            <summary>
            Реальная (действительная) часть комплексного вектора 
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexVector.ImaginaryVector">
            <summary>
            Мнимая часть комплексного вектора
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexVector.MagnitudeVector">
            <summary>
            Модуль комплексного вектора
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.ComplexVector.PhaseVector">
            <summary>
            Фаза комплексного вектора
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.#ctor">
            <summary>
            Creates a vector with zeros (0 + 0j) of capacity 3
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.#ctor(System.Int32)">
            <summary>
            Creates a vector with zeros (0 + 0j) of dimension n
            </summary>
            <param name="n"></param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.#ctor(System.Numerics.Complex)">
            <summary>
            Creates a vector of dimension 1 with the given value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.#ctor(System.Collections.Generic.IEnumerable{System.Numerics.Complex})">
            <summary>
            Creates a vector from the IEnumerable interface of Complex
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.#ctor(System.Double[],System.Double[])">
            <summary>
            Creates a vector based on arrays of real and imaginary parts
            </summary>
            <param name="vectorReal">Real part</param>
            <param name="vectorImg">Imaginary part</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.#ctor(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Creates a vector based on arrays of real and imaginary parts
            </summary>
            <param name="vectorReal">Real part</param>
            <param name="vectorImg">Imaginary part</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.#ctor(System.Double[])">
            <summary>
            Creates a vector based on array of real part, imaginary filled with zeros
            </summary>
            <param name="vectorReal">Real part</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.#ctor(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Creates a vector based on vectors of real part, imaginary filled with zeros
            </summary>
            <param name="vectorReal">Real part</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Addition(AI.DataStructs.WithComplexElements.ComplexVector,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Поэлементное сложение
            </summary>
            <param name="left">Первый вектор</param>
            <param name="right">Второй</param>
            <returns>Результат</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Addition(System.Numerics.Complex,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Сложение
            </summary>
            <param name="k">Число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Addition(AI.DataStructs.WithComplexElements.ComplexVector,System.Numerics.Complex)">
            <summary>
            Сложение
            </summary>
            <param name="k">Число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Addition(System.Double,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Сложение
            </summary>
            <param name="k">Число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Addition(AI.DataStructs.WithComplexElements.ComplexVector,System.Double)">
            <summary>
            Сложение
            </summary>
            <param name="k">Число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_UnaryNegation(AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Отрицание
            </summary>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Subtraction(AI.DataStructs.WithComplexElements.ComplexVector,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Поэлементное вычитание
            </summary>
            <param name="left">Первый вектор</param>
            <param name="right">Второй</param>
            <returns>Результат</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Subtraction(System.Numerics.Complex,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Вычитание из числа
            </summary>
            <param name="k">комплексное число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Subtraction(AI.DataStructs.WithComplexElements.ComplexVector,System.Numerics.Complex)">
            <summary>
            Вычитание числа
            </summary>
            <param name="k">комплексное число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Subtraction(System.Double,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Вычитание из числа
            </summary>
            <param name="k">реальное число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Subtraction(AI.DataStructs.WithComplexElements.ComplexVector,System.Double)">
            <summary>
            Вычитание числа
            </summary>
            <param name="k"> число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Multiply(AI.DataStructs.WithComplexElements.ComplexVector,System.Numerics.Complex)">
            <summary>
            Умножение
            </summary>
            <param name="k">Число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Multiply(AI.DataStructs.WithComplexElements.ComplexVector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Поэлементное умножение на реальный вектор
            </summary>
            <param name="left">Первый вектор</param>
            <param name="right">Второй</param>
            <returns>Результат</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Multiply(AI.DataStructs.Algebraic.Vector,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Поэлементное умножение на реальный вектор
            </summary>
            <param name="right">Первый вектор</param>
            <param name="left">Второй</param>
            <returns>Результат</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Multiply(System.Numerics.Complex,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Умножение на число
            </summary>
            <param name="k">комплексное число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Multiply(AI.DataStructs.WithComplexElements.ComplexVector,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Поэлементное умножение
            </summary>
            <param name="left">Первый вектор</param>
            <param name="right">Второй</param>
            <returns>Результат</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Division(System.Numerics.Complex,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Деление
            </summary>
            <param name="k">Число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Division(AI.DataStructs.WithComplexElements.ComplexVector,System.Numerics.Complex)">
            <summary>
            Деление
            </summary>
            <param name="k">Число</param>
            <param name="vector">Комплексный вектор</param>
            <returns>Комплексный вектор</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Division(AI.DataStructs.WithComplexElements.ComplexVector,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Поэлементное деление
            </summary>
            <param name="left">Первый вектор</param>
            <param name="right">Второй</param>
            <returns>Результат</returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Implicit(AI.DataStructs.WithComplexElements.ComplexVector)~System.Numerics.Complex[]">
            <summary>
            Implicit cast ComplexVector -> Complex[]
            </summary>
            <param name="vect">Вектор</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Implicit(System.Numerics.Complex[])~AI.DataStructs.WithComplexElements.ComplexVector">
            <summary>
            Implicit cast Complex[] -> ComplexVector
            </summary>
            <param name="dbs">Complex array</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Implicit(System.Double[])~AI.DataStructs.WithComplexElements.ComplexVector">
            <summary>
            Implicit cast double[] -> ComplexVector
            </summary>
            <param name="dbs">Double array</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.op_Implicit(AI.DataStructs.Algebraic.Vector)~AI.DataStructs.WithComplexElements.ComplexVector">
            <summary>
            Implicit cast Vector -> ComplexVector
            </summary>
            <param name="dbs"></param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.CutAndZero(System.Int32)">
            <summary>
            Zero padding or cropping to the desired vector size.
            </summary>
            <param name="n">New dimension</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Clone">
            <summary>
            Vector cloning
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Revers">
            <summary>
            Vector reverse (mirror image)
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Shift(System.Int32)">
            <summary>
             Shift the sequence by a certain number.Example: the sequence 1 2 3 is shifted by 2 - this is {0 0 1 2 3}, by 4 - {0 0 0 0 1 2 3}
            </summary>
            <param name="valueShift">Shift amount</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.FurCentr">
            <summary>
            Centering an array of values ​​obtained by the Fourier transform
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Decimation(System.Int32)">
            <summary>
            Decimation (thinning) vector
            </summary>
            <param name="kDecim">Decimation factor</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.AddSimmetr">
            <summary>
            Adding a reflected Vector
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.InterpolayZero(System.Int32)">
            <summary>
            Interpolation by a polynomial of order zero
            </summary>
            <param name="kInterp">Interpolation factor</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Transform(System.Func{System.Numerics.Complex,System.Numerics.Complex})">
            <summary>
            Element-wise vector transformation
            </summary>
            <param name="func">Conversion function</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.TransformSelf(System.Func{System.Numerics.Complex,System.Numerics.Complex})">
            <summary>
            Element-wise vector transformation
            </summary>
            <param name="func">Conversion function</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.ComplexConjugate">
            <summary>
            Complex conjugate number
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.ComplexConjugateSelf">
            <summary>
            Complex conjugate number
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Mean">
            <summary>
            Arithmetic mean of a complex vector
            </summary>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.ComplexVectorPhaseMagn(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Converting the vector of phases and amplitudes into a complex vector
            </summary>
            <param name="magn">Amplitude vector</param>
            <param name="phase"> Phase vector(rad)</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.ComplexVectorPhaseDegMagnDb(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,AI.DataStructs.WithComplexElements.DbType)">
            <summary>
            Converting the vector of phases and amplitudes into a complex vector
            </summary>
            <param name="magnDb">Amplitude vector(db)</param>
            <param name="phaseDeg"> Phase vector(deg)</param>
            <param name="dbType">Тип дб по энергия/амплитуда</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.TransformVectorX(AI.DataStructs.Algebraic.Vector,System.Func{System.Double,System.Numerics.Complex})">
            <summary>
            Vector transformation(A vector of real arguments is used)
            </summary>
            <param name="transformFunc">Conversion function, a function of the value of a vector of arguments</param>
            <param name="x">Argument vector</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.TransformVectorX(AI.DataStructs.WithComplexElements.ComplexVector,System.Func{System.Numerics.Complex,System.Numerics.Complex})">
            <summary>
            Vector transformation(Using a vector of complex arguments)
            </summary>
            <param name="transformFunc"> Conversion function, a function of the value of a vector of arguments</param>
            <param name="x">Argument vector</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Save(System.String)">
            <summary>
            Сохранить в файл
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Save(System.IO.Stream)">
            <summary>
            Сохранениеs vector to stream
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.GetBytes">
            <summary>
            Представить в виде массива байт
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Load(System.String)">
            <summary>
            Загрузить из файла
            </summary>
            <param name="path">Путь до файла</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.Load(System.IO.Stream)">
            <summary>
            Загрузить из потока
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.FromBytes(System.Byte[])">
            <summary>
            Инициализировать массивом байт
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DataStructs.WithComplexElements.ComplexVector.FromDataStream(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Инициализировать потоком данных
            </summary>
            <param name="dataStream"></param>
            <returns></returns>
        </member>
        <member name="T:AI.DataStructs.WithComplexElements.DbType">
            <summary>
            Decibel type
            </summary>
        </member>
        <member name="F:AI.DataStructs.WithComplexElements.DbType.Energy">
            <summary>
            Energetic
            </summary>
        </member>
        <member name="F:AI.DataStructs.WithComplexElements.DbType.Ampl">
            <summary>
            Amplitude
            </summary>
        </member>
        <member name="T:AI.DataStructs.WithComplexElements.IComplexStructure">
            <summary>
            Интефейс комплексной структуры
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.IComplexStructure.Data">
            <summary>
            Одномерный массив комплексных компонент
            </summary>
        </member>
        <member name="P:AI.DataStructs.WithComplexElements.IComplexStructure.Shape">
            <summary>
            Форма структуры
            </summary>
        </member>
        <member name="T:AI.Dog.Tools.ArrayUtils`1">
            <summary>
            Операции над массивами
            </summary>
        </member>
        <member name="M:AI.Dog.Tools.ArrayUtils`1.DeleteSubArray(`0[],`0[])">
            <summary>
            Удаление первого вхождения под массива
            </summary>
            <param name="array">Массив данных</param>
            <param name="subArrayForRemove">Удаляемый массив</param>
        </member>
        <member name="M:AI.Dog.Tools.ArrayUtils`1.SearchSubArray(`0[],`0[])">
            <summary>
            Поиск первого вхождения под массива
            </summary>
            <param name="array">Массив данных</param>
            <param name="subArray">Подмассив</param>
        </member>
        <member name="T:AI.Dog.Tools.NumConverter">
            <summary>
            Преобразование между системами счисления
            </summary>
        </member>
        <member name="M:AI.Dog.Tools.NumConverter.BinaryToDecimal(System.Boolean[])">
            <summary>
            Из двоичной в десятичную
            </summary>
        </member>
        <member name="M:AI.Dog.Tools.NumConverter.BinaryToDecimal(System.String)">
            <summary>
            Из двоичной в десятичную
            </summary>
        </member>
        <member name="M:AI.Dog.Tools.NumConverter.StringToBitArray(System.String)">
            <summary>
            Строка в массив бит
            </summary>
            <param name="binary"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Dog.Tools.NumConverter.DecimalToBinaryStr(System.Int32)">
            <summary>
            Перевод из десятичной в двоичную систему
            </summary>
            <param name="decim">Число в десятичной системе</param>
        </member>
        <member name="M:AI.Dog.Tools.NumConverter.DecimalToBinaryBits(System.Int32)">
            <summary>
            Перевод из десятичной в двоичную систему
            </summary>
            <param name="decim">Число в десятичной системе</param>
        </member>
        <member name="M:AI.Dog.Tools.NumConverter.DecimalToGrayStr(System.Int32)">
            <summary>
            Перевод из десятичной системы в код Грея
            </summary>
            <param name="decim">Число в десятичной системе</param>
        </member>
        <member name="M:AI.Dog.Tools.NumConverter.DecimalToGrayBits(System.Int32)">
            <summary>
            Перевод из десятичной системы в код Грея
            </summary>
            <param name="decim">Число в десятичной системе</param>
        </member>
        <member name="M:AI.Dog.Tools.NumConverter.DecimalToGrayStr(System.Int32,System.Int32)">
            <summary>
            Перевод из десятичной системы в код Грея
            </summary>
            <param name="decim">Число в десятичной системе</param>
            <param name="count">Количество цифр в представлении числа</param>
        </member>
        <member name="M:AI.Dog.Tools.NumConverter.DecimalToGrayBits(System.Int32,System.Int32)">
            <summary>
            Перевод из десятичной системы в код Грея
            </summary>
            <param name="decim">Число в десятичной системе</param>
            <param name="count">Количество цифр в представлении числа</param>
        </member>
        <member name="M:AI.Dog.Tools.NumConverter.GrayDecoder(System.String)">
            <summary>
            Декодирование кода Грея в десятичный 
            </summary>
            <param name="binary">Бинарный код Грея</param>
            <returns></returns>
        </member>
        <member name="M:AI.Dog.Tools.NumConverter.GrayDecoder(System.Boolean[])">
            <summary>
            Декодирование кода Грея в десятичный 
            </summary>
            <param name="binary">Бинарный код Грея</param>
            <returns></returns>
        </member>
        <member name="T:AI.Dog.Tools.Simillary">
            <summary>
            Проверка схожести чисел
            </summary>
        </member>
        <member name="M:AI.Dog.Tools.Simillary.Bools2Vect(System.Boolean[],System.Double,System.Double)">
            <summary>
            Преобразование массива байт в вектор
            </summary>
            <param name="bools">Массив байт</param>
            <param name="min">Минимальное значение</param>
            <param name="max">Максимальное значение</param>
        </member>
        <member name="M:AI.Dog.Tools.Simillary.CorrelationVectorInt(AI.DataStructs.Algebraic.Vector,System.Int32,System.Double,System.Double)">
            <summary>
            Коэффициент корреляции Пирсона между вектором семантического образа и индексом
            </summary>
            <param name="semantic">Семантический образ</param>
            <param name="index">Индекс</param>
            <param name="min">Минимальное значение</param>
            <param name="max">Максимальное значение</param>
            <returns></returns>
        </member>
        <member name="M:AI.Dog.Tools.Simillary.FuzzyMembership(AI.DataStructs.Algebraic.Vector,System.Int32,System.Double,System.Double)">
            <summary>
            Нечеткая принадлежность вектора индексу (множеству)
            </summary>
            <param name="semantic">Семантический образ</param>
            <param name="index">Индекс</param>
            <param name="min">Минимальное значение</param>
            <param name="max">Максимальное значение</param>
        </member>
        <member name="M:AI.Dog.Tools.Simillary.CorrelationIntInt(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Коэффициент корреляции Пирсона между двумя индексами и индексом
            </summary>
            <param name="index1">Индекс 1</param>
            <param name="index2">Индекс 2</param>
            <param name="min">Минимальное значение</param>
            <param name="max">Максимальное значение</param>
            <returns></returns>
        </member>
        <member name="M:AI.Dog.Tools.Simillary.CosIntInt(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Коэффициент корреляции Пирсона между двумя индексами и индексом
            </summary>
            <param name="index1">Индекс 1</param>
            <param name="index2">Индекс 2</param>
            <param name="min">Минимальное значение</param>
            <param name="max">Максимальное значение</param>
            <returns></returns>
        </member>
        <member name="M:AI.Dog.Tools.Simillary.FuzzyMembershipIntInt(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Нечеткое сходствой двух чисел (множеств)
            </summary>
            <param name="index1">Индекс 1</param>
            <param name="index2">Индекс 2</param>
            <param name="min">Минимальное значение</param>
            <param name="max">Максимальное значение</param>
        </member>
        <member name="T:AI.DSP.Analyse.FrequencyResponse">
            <summary>
            АЧХ
            </summary>
        </member>
        <member name="P:AI.DSP.Analyse.FrequencyResponse.FStart">
            <summary>
            Начальная частота
            </summary>
        </member>
        <member name="P:AI.DSP.Analyse.FrequencyResponse.FEnd">
            <summary>
            Конечная частота
            </summary>
        </member>
        <member name="P:AI.DSP.Analyse.FrequencyResponse.Step">
            <summary>
            Шаг по частоте
            </summary>
        </member>
        <member name="P:AI.DSP.Analyse.FrequencyResponse.Time">
            <summary>
            Время реализации
            </summary>
        </member>
        <member name="P:AI.DSP.Analyse.FrequencyResponse.Freq">
            <summary>
            Отсчеты по частоте
            </summary>
        </member>
        <member name="M:AI.DSP.Analyse.FrequencyResponse.#ctor(System.Int32)">
            <summary>
            АЧХ
            </summary>
            <param name="fd">Частота дискретизации</param>
        </member>
        <member name="M:AI.DSP.Analyse.FrequencyResponse.Test(System.Func{AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector})">
            <summary>
            Проверка АЧХ алгоритма
            </summary>
            <param name="alg">Алгоритм</param>
        </member>
        <member name="T:AI.DSP.Analyse.Trend">
            <summary>
            Тренд сигнала
            </summary>
        </member>
        <member name="P:AI.DSP.Analyse.Trend.K">
            <summary>
            Коэффициент наклона
            </summary>
        </member>
        <member name="P:AI.DSP.Analyse.Trend.B">
            <summary>
            Смещение
            </summary>
        </member>
        <member name="M:AI.DSP.Analyse.Trend.#ctor(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучающая выборка
            </summary>
            <param name="X">Вектор X(независимая переменная)</param>
            <param name="Y">Вектор Y(зависимая переменная)</param>
        </member>
        <member name="M:AI.DSP.Analyse.Trend.ToString">
            <summary>
            Вывод в строку
            </summary>
            <returns>Строка типа: f(x) = k*x+(b)</returns>
        </member>
        <member name="M:AI.DSP.Analyse.Trend.Predict(System.Double)">
            <summary>
            Прогнозирование с помощью линейной модели
            </summary>
            <param name="x">Независимая переменная</param>
            <returns>Зависимая переменная</returns>
        </member>
        <member name="M:AI.DSP.Analyse.Trend.Predict(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прогнозирование с помощью линейной модели
            </summary>
            <param name="X">Вектор независимых переменных</param>
            <returns>Вектор зависимых переменных</returns>
        </member>
        <member name="T:AI.DSP.Analyse.Welch">
            <summary>
            Метода Уэлча
            </summary>
        </member>
        <member name="M:AI.DSP.Analyse.Welch.WelchRun(AI.DataStructs.Algebraic.Vector,System.Int32,System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Запуск метода Уэлча
            </summary>
            <param name="signal">Сигнал</param>
            <param name="window">Окно</param>
            <param name="overlap">Перекрытие</param>
            <param name="windowForFFT">Функция взвешивания окна</param>
        </member>
        <member name="M:AI.DSP.Analyse.Welch.BartlettRun(AI.DataStructs.Algebraic.Vector,System.Int32,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Запуск метода периодограммы
            </summary>
            <param name="signal">Сигнал</param>
            <param name="window">Окно</param>
            <param name="windowForFFT">Функция взвешивания окна</param>
        </member>
        <member name="T:AI.DSP.Analyse.WelchData">
            <summary>
            Данные преобразования Уэлча
            </summary>
        </member>
        <member name="F:AI.DSP.Analyse.WelchData.PSD">
            <summary>
            Спектральная плотность мощности
            </summary>
        </member>
        <member name="P:AI.DSP.Analyse.WelchData.HalfPSD">
            <summary>
            Половина спектральной плотности мощности
            </summary>
        </member>
        <member name="F:AI.DSP.Analyse.WelchData.Freq">
            <summary>
            Массив частот
            </summary>
        </member>
        <member name="P:AI.DSP.Analyse.WelchData.HalfFreq">
            <summary>
            Половина массива частот
            </summary>
        </member>
        <member name="M:AI.DSP.Analyse.WelchData.#ctor(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,AI.DSP.Analyse.WelchPSDType)">
            <summary>
            Данные преобразования Уэлча
            </summary>
        </member>
        <member name="M:AI.DSP.Analyse.WelchData.#ctor(AI.DataStructs.Algebraic.Vector,System.Double,AI.DSP.Analyse.WelchPSDType)">
            <summary>
            Данные преобразования Уэлча
            </summary>
        </member>
        <member name="T:AI.DSP.Analyse.WelchPSDType">
            <summary>
            Тип представления СПМ
            </summary>
        </member>
        <member name="F:AI.DSP.Analyse.WelchPSDType.Db">
            <summary>
            Децибеллы
            </summary>
        </member>
        <member name="F:AI.DSP.Analyse.WelchPSDType.Abs">
            <summary>
            Абсолютные значения
            </summary>
        </member>
        <member name="T:AI.DSP.Analyse.WelchFormantFinder">
            <summary>
            Анализ формант
            </summary>
        </member>
        <member name="F:AI.DSP.Analyse.WelchFormantFinder.MinIntervals">
            <summary>
            Минимальные значения 1-й, 2-й и 3-ей формант в Гц
            </summary>
        </member>
        <member name="F:AI.DSP.Analyse.WelchFormantFinder.MaxIntervals">
            <summary>
            Максимальные значения 1-й, 2-й и 3-ей формант в Гц
            </summary>
        </member>
        <member name="M:AI.DSP.Analyse.WelchFormantFinder.FindFormants(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Поиск формант
            </summary>
            <param name="welchData">СПМ метод Уэлча</param>
            <param name="freqs">Массив частот</param>
            <param name="thresholdFactor">Множитель адаптивного порога</param>
            <param name="smoothParam">Параметр сглаживания</param>
            <returns>Вектор пиков</returns>
        </member>
        <member name="T:AI.DSP.Channel">
            <summary>
            Канал
            </summary>
        </member>
        <member name="P:AI.DSP.Channel.ChData">
            <summary>
            Отсчеты сигнала
            </summary>
        </member>
        <member name="P:AI.DSP.Channel.Fd">
            <summary>
            Частота дискретизации
            </summary>
        </member>
        <member name="P:AI.DSP.Channel.Dt">
            <summary>
            Шаг по времени
            </summary>
        </member>
        <member name="P:AI.DSP.Channel.Name">
            <summary>
            Имя канала
            </summary>
        </member>
        <member name="P:AI.DSP.Channel.Description">
            <summary>
            Описание
            </summary>
        </member>
        <member name="P:AI.DSP.Channel.Item(System.Int32)">
            <summary>
            Доступ по индексам к данным канала
            </summary>
            <param name="i">Индекс</param>
        </member>
        <member name="P:AI.DSP.Channel.ScaleVolt">
            <summary>
            Масштаб по напряжению
            </summary>
        </member>
        <member name="M:AI.DSP.Channel.#ctor">
            <summary>
            Канал
            </summary>
        </member>
        <member name="M:AI.DSP.Channel.#ctor(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Канал, задается через вектор данных и частоту дискретизации
            </summary>
            <param name="vectorData">Вектор</param>
            <param name="fd">Частота</param>
        </member>
        <member name="M:AI.DSP.Channel.#ctor(AI.DataStructs.Algebraic.Vector,System.Int32,System.String)">
            <summary>
            Канал, задается через вектор данных, частоту дискретизации и имя
            </summary>
            <param name="vectorData">Вектор</param>
            <param name="fd">Частота</param>
            <param name="name">Имя</param>
        </member>
        <member name="M:AI.DSP.Channel.#ctor(AI.DataStructs.Algebraic.Vector,System.Int32,System.String,System.String)">
            <summary>
            Канал, задается через вектор данных, частоту дискретизации, имя и  описание
            </summary>
            <param name="vectorData">Вектор</param>
            <param name="fd">Частота</param>
            <param name="name">Имя</param>
            <param name="description">Описание</param>
        </member>
        <member name="M:AI.DSP.Channel.GetChannels(AI.DataStructs.Algebraic.Vector[],System.Int32)">
            <summary>
            Преобразует масив векторов в массив каналов
            </summary>
            <param name="vects">Массив векторов</param>
            <param name="fd">Частота дискретизации</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.Channel.ChansToVects(AI.DSP.Channel[])">
            <summary>
            Массив каналов в массив векторов
            </summary>
            <param name="channels">Массив каналов</param>
        </member>
        <member name="M:AI.DSP.Channel.SignalTrend">
            <summary>
            Тренды сигнала
            </summary>
        </member>
        <member name="M:AI.DSP.Channel.SignalWithoutTrend">
            <summary>
            Сигнал без тренда
            </summary>
        </member>
        <member name="M:AI.DSP.Channel.SignalWithM0Std1Trend">
            <summary>
            Сигнал нулевым мат. ожиданием и средне квадратичным отклонением равным 1 (вычитается тренд)
            </summary>
        </member>
        <member name="M:AI.DSP.Channel.SignalWithM0Std1">
            <summary>
            Сигнал нулевым мат. ожиданием и средне квадратичным отклонением равным 1 (вычитается среднее)
            </summary>
        </member>
        <member name="M:AI.DSP.Channel.GetSpectr">
            <summary>
            Рассчитывает спектр
            </summary>
            <returns>Амплитудный спектр частоты 0 .. fd/2</returns>
        </member>
        <member name="M:AI.DSP.Channel.GetSpectr(System.Func{System.Int32,AI.DataStructs.Algebraic.Vector})">
            <summary>
            Рассчитывает спектр с использованием оконных функций
            </summary>
            <returns>Амплитудный спектр частоты 0 .. fd/2</returns>
        </member>
        <member name="M:AI.DSP.Channel.Time">
            <summary>
            Генерация отсчетов времени
            </summary>
            <returns>Отсчеты времени</returns>
        </member>
        <member name="M:AI.DSP.Channel.Freq">
            <summary>
            Генерация отсчетов частоты
            </summary>
            <returns>Отсчеты частоты</returns>
        </member>
        <member name="M:AI.DSP.Channel.KoefScaleToVolt(AI.DSP.TypeScaleVolt)">
            <summary>
            Коэффициент для перевода в вольты
            </summary>
            <param name="scaleVolt">Масштаб</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.Channel.YName">
            <summary>
            Единица измерения шкалы Y
            </summary>
        </member>
        <member name="M:AI.DSP.Channel.ConvertVolt(AI.DSP.TypeScaleVolt)">
            <summary>
            Конвертирование масштаба по Y
            </summary>
            <param name="newScale">Новый масштаб</param>
        </member>
        <member name="M:AI.DSP.Channel.Filtration(AI.DSP.DSPCore.IFilter)">
            <summary>
            Фильтрация канала
            </summary>
            <param name="filter">Фильтр</param>
        </member>
        <member name="T:AI.DSP.Decomposition.FiltersDecomp">
            <summary>
            Декомпозиция сигнала при помощи КИХ фильтров
            </summary>
        </member>
        <member name="M:AI.DSP.Decomposition.FiltersDecomp.#ctor(System.Double[],System.Double[],System.Int32,System.Int32)">
            <summary>
            Декомпозиция сигнала при помощи КИХ фильтров
            </summary>
        </member>
        <member name="M:AI.DSP.Decomposition.FiltersDecomp.Decomosition(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Декомпозиция сигнала по полосам
            </summary>
            <param name="signal">Сигнал</param>
        </member>
        <member name="M:AI.DSP.Decomposition.FiltersDecomp.DecomositionBalanceSTD(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Декомпозиция и нормировка сигнала по полосам
            </summary>
            <param name="signal">Сигнал</param>
        </member>
        <member name="M:AI.DSP.Decomposition.FiltersDecomp.SumDecomosition(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Сумма декопозированного сигнала
            </summary>
        </member>
        <member name="M:AI.DSP.Decomposition.FiltersDecomp.SumDecomositionBalanceSTD(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Разложение сигнала с помощью фильтров
            </summary>
            <param name="signal">Сигнал</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.Decomposition.FiltersDecomp.FIRSincImpulseResponse(System.Int32,System.Double,System.Double,System.Int32,AI.BackEnds.DSP.NWaves.Windows.WindowTypes)">
            <summary>
            КИХ фильтр типа sin(x)/x (Синтезирует импульсную характеристику)
            </summary>
            <param name="fd">Частота дискретизации</param>
            <param name="f1">Нижняя частота среза</param>
            <param name="f2">Верхняя частота среза</param>
            <param name="order">Порядок</param>
            <param name="windowType">Тип весового окна</param>
        </member>
        <member name="M:AI.DSP.Decomposition.FiltersDecomp.FIRRemezImpulseResponse(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Int32,AI.BackEnds.DSP.NWaves.Windows.WindowTypes)">
            <summary>
            Синтезирует импульсную характеристику методом Ремеза
            </summary>
            <param name="fd">Частота дискретизации</param>
            <param name="f1_stop">Нижняя частота подавление</param>
            <param name="f1_pass">Нижняя частота пропускания</param>
            <param name="f2_stop">Верхняя частота подавление</param>
            <param name="f2_pass">Верхняя частота пропускания</param>
            <param name="w_stop">Коэф. в полосе подавления</param>
            <param name="w_pass">Коэф. в полосе пропускания</param>
            <param name="order">Порядок</param>
            <param name="windowType">Тип весового окна</param>
        </member>
        <member name="M:AI.DSP.Decomposition.FiltersDecomp.RunFirFilter(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прямой проход КИХ фильтра
            </summary>
            <param name="signal">Сигнал</param>
            <param name="impulseResponse">Импульсная характеристика</param>
        </member>
        <member name="T:AI.DSP.DSPCore.DCT">
            <summary>
            Дискретно-косинусное преобразование
            </summary>
        </member>
        <member name="P:AI.DSP.DSPCore.DCT.MainMatrix">
            <summary> 
            Матрица прямого преобразования
            </summary>
        </member>
        <member name="P:AI.DSP.DSPCore.DCT.InvMatrix">
            <summary> 
            Матрица обратного преобразования
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.DCT.#ctor">
            <summary>
            Дискретно-косинусное преобразование
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.DCT.#ctor(System.Int32,System.Int32)">
            <summary>
            Дискретно-косинусное преобразование
            </summary>
            <param name="countInp">Кол-во входов</param>
            <param name="countOutp">Кол-во Выходов</param>
        </member>
        <member name="M:AI.DSP.DSPCore.DCT.GetMatrW(System.Int32,System.Int32)">
            <summary>
            Матрица
            </summary>
            <param name="Count"></param>
            <param name="M"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.DCT.DirectDCTNorm(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прямое ДКТ
            </summary>
            <param name="inp"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.DCT.InversDCTNorm(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обратное Дкт
            </summary>
            <param name="inp"></param>
            <returns></returns>
        </member>
        <member name="T:AI.DSP.DSPCore.DCT2NWaveWrapper">
            <summary>
            Обертка для ДКП-2
            </summary>
        </member>
        <member name="P:AI.DSP.DSPCore.DCT2NWaveWrapper.Count">
            <summary>
            Число отсчетов ДКП
            </summary>
        </member>
        <member name="P:AI.DSP.DSPCore.DCT2NWaveWrapper.IsFast">
            <summary>
            Испольльзовать ли быструю реализацию
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.DCT2NWaveWrapper.#ctor(System.Int32)">
            <summary>
            Обертка для ДКП-2
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.DCT2NWaveWrapper.DirectDCT(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прямое преобразование
            </summary>
            <param name="st"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.DCT2NWaveWrapper.DirectDCTNorm(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прямое нормированное преобразование
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.DCT2NWaveWrapper.InversDCT(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обратное преобразование
            </summary>
        </member>
        <member name="T:AI.DSP.DSPCore.FastConv">
            <summary>
            Реализация быстрых сверток
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.FastConv.FastConvolution(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Быстрая свертка
            </summary>
            <param name="signal">Сигнал</param>
            <param name="ht">Импульсивный ответ</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.FastConv.FastConvolution(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Быстрая свертка
            </summary>
            <param name="signal">Сигнал</param>
            <param name="ht">Импульсивный ответ</param>
            <param name="fd">Частота дискретизации</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.FastConv.FastConvolutionNorm(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Быстрая нормированная свертка
            </summary>
            <param name="signal">Сигнал</param>
            <param name="ht">Импульсивный ответ</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.FastConv.FastCorrelation(System.Double[])">
            <summary>
            Быстрая корреляция
            </summary>
            <param name="signal">Сигнал</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.FastConv.FastNormCrossCorrelation(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Быстрый алгоритм расчета нормированной ВКФ
            </summary>
            <param name="signal"></param>
            <param name="ht"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.FastConv.FastCorrelation(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Быстрая нормированная корреляция
            </summary>
            <param name="signal">Сигнал</param>
            <param name="ht">Патерн</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.FastConv.SectionalConvolutionNorm(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Быстрая секционная свертка
            </summary>
            <param name="signal">Сигнал</param>
            <param name="pattern">Паттерн (участок в разы меньше сигнала)</param>
            <param name="num">Число секций</param>
        </member>
        <member name="M:AI.DSP.DSPCore.FastConv.SectionalConvolution(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Быстрая секционная свертка
            </summary>
            <param name="signal">Сигнал</param>
            <param name="pattern">Паттерн (участок в разы меньше сигнала)</param>
            <param name="num">Число секций</param>
        </member>
        <member name="T:AI.DSP.DSPCore.FastHilbert">
            <summary>
            Метод Гильберта
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.FastHilbert.ConjugateToTheHilbert(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Сигнал сопряженный по Гильберту
            </summary>
            <param name="st">Исходный сигнал</param>
        </member>
        <member name="M:AI.DSP.DSPCore.FastHilbert.GetAnalSig(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Аналитический сигнал
            </summary>
            <param name="st">Входной сигнал</param>
        </member>
        <member name="M:AI.DSP.DSPCore.FastHilbert.Envelope(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Огибающая
            </summary>
            <param name="st">Входной сигнал</param>
        </member>
        <member name="M:AI.DSP.DSPCore.FastHilbert.Phase(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Мгновенная фаза
            </summary>
            <param name="st">Входной сигнал</param>
        </member>
        <member name="M:AI.DSP.DSPCore.FastHilbert.Frequency(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Мгновенная частота
            </summary>
            <param name="st">Входной сигнал</param>
        </member>
        <member name="M:AI.DSP.DSPCore.FastHilbert.EnvelopeIQ(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Выделение огибающей на базе квадратурн. сост
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.FastHilbert.PhaseIQ(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Выделение девиации частоты на базе квадратурн. сост
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.FastHilbert.IQ(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Выделение девиации частоты на базе квадратурн. сост
            </summary>
        </member>
        <member name="T:AI.DSP.DSPCore.Filters">
            <summary>
            Класс для реализации цифровых фильтров
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.Filter(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Boolean)">
            <summary>
            Реализация простого фильтра
            </summary>
            <param name="st">Вектор сигнала</param>
            <param name="kw">АЧХ</param>
            <param name="mean">Нужна ли постоянная составляющая</param>
            <returns>Фильтрованный сигнал</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.Filter(AI.DataStructs.Algebraic.Vector,AI.DataStructs.WithComplexElements.ComplexVector,System.Boolean)">
            <summary>
            Реализация простого фильтра
            </summary>
            <param name="st">Вектор сигнала</param>
            <param name="kw">КЧХ</param>
            <param name="mean">Нужна ли постоянная составляющая</param>
            <returns>Фильтрованный сигнал</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.FilterKontur(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Int32)">
            <summary>
            Реализация колебательного контура
            </summary>
            <param name="st">Вектор сигнала</param>
            <param name="Q">Добротность</param>
            <param name="f0">Резонансная частота</param>
            <param name="fd">Частота дискретизации</param>
            <returns>Фильтрованный сигнал</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.FilterLow(AI.DataStructs.Algebraic.Vector,System.Double,System.Int32)">
            <summary>
            ФНЧ (Прямоугольная АЧХ)
            </summary>
            <param name="signal">Отсчеты сигнала</param>
            <param name="sr">Частота среза</param>
            <param name="fd">Частота дискретизации</param>
            <returns>Фильтрованный сигнал</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.FilterLowButterworthCFH(AI.DataStructs.Algebraic.Vector,System.Double,System.Int32,System.Int32)">
            <summary>
            ФНЧ (АЧХ повторяет АЧХ Баттерворта), задан через КЧХ
            </summary>
            <param name="signal">Отсчеты сигнала</param>
            <param name="sr">Частота среза</param>
            <param name="fd">Частота дискретизации</param>
            <param name="order">Порядок фильтра</param>
            <returns>Фильтрованный сигнал</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.FilterLowButterworthAFH(AI.DataStructs.Algebraic.Vector,System.Double,System.Int32,System.Int32)">
            <summary>
            ФНЧ (АЧХ повторяет АЧХ Баттерворта), задан через АЧХ
            </summary>
            <param name="signal">Отсчеты сигнала</param>
            <param name="sr">Частота среза</param>
            <param name="fd">Частота дискретизации</param>
            <param name="order">Порядок фильтра</param>
            <returns>Фильтрованный сигнал</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.FilterBand(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Int32)">
            <summary>
            Полосовой фильтр (Прямоугольная АЧХ)
            </summary>
            <param name="signal">Отсчеты сигнала</param>
            <param name="sr1">Нижняя частота полосы</param>
            <param name="sr2">Верхняя частота полосы</param>
            <param name="fd">Частота дискретизации</param>
            <returns>Фильтрованный сигнал</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.FilterHigh(AI.DataStructs.Algebraic.Vector,System.Double,System.Int32)">
            <summary>
            ФВЧ (Прямоугольная АЧХ)
            </summary>
            <param name="signal">Отсчеты сигнала</param>
            <param name="sr">Частота среза</param>
            <param name="fd">Частота дискретизации</param>
            <returns>Фильтрованный сигнал</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.FilterRezector(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Int32)">
            <summary>
            Режекторный фильтр
            </summary>
            <param name="signal">Отсчеты сигнала</param>
            <param name="sr1">Нижняя частота полосы</param>
            <param name="sr2">Верхняя частота полосы</param>
            <param name="fd">Частота дискретизации</param>
            <returns>Фильтрованный сигнал</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.GetAFH(AI.DataStructs.Algebraic.Vector,System.Double[],AI.DSP.DSPCore.AFHType)">
            <summary>
            Создание АЧХ нужного типа
            </summary>
            <param name="f">Вектор частот</param>
            <param name="param">параметры</param>
            <param name="afh">Тип АЧХ</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.CreatAFH(AI.DataStructs.Algebraic.Vector,System.String[])">
            <summary>
            Создание составной АЧХ
            </summary>
            <param name="f">Вектор частот</param>
            <param name="param">Параметры</param>
            <returns>Возвращает АЧХ</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.ExpAv(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Эспоненциональное скользящее среднее
            </summary>
            <param name="inp">Вход</param>
            <param name="oldPart">Коэффициент сглаживания</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.MAv(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Cкользящее среднее
            </summary>
            <param name="inp">Вход</param>
            <param name="l">Размер окна</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.GetEnvelope(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Получение огибающей
            </summary>
            <param name="inp"></param>
            <param name="dec">Прореживание</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.ButterworthLowAFH(System.Int32,System.Double,System.Int32,System.Int32)">
            <summary>
            Ачх фильтра Баттерворта
            </summary>
            <param name="Count">Число отсчетов сигнала</param>
            <param name="sr">Частота среза</param>
            <param name="fd">Частота дискретизации</param>
            <param name="order">Порядок фильтра</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Filters.ButterworthLowCFH(System.Int32,System.Double,System.Int32,System.Int32)">
            <summary>
            КЧХ фильтра Баттерворта
            </summary>
            <param name="Count">Число отсчетов сигнала</param>
            <param name="sr">Частота среза</param>
            <param name="fd">Частота дискретизации</param>
            <param name="order">Порядок фильтра</param>
        </member>
        <member name="T:AI.DSP.DSPCore.AFHType">
            <summary>
            Типы АЧХ
            </summary>
        </member>
        <member name="F:AI.DSP.DSPCore.AFHType.Low">
            <summary>
            ФНЧ
            </summary>
        </member>
        <member name="F:AI.DSP.DSPCore.AFHType.High">
            <summary>
            ФВЧ
            </summary>
        </member>
        <member name="F:AI.DSP.DSPCore.AFHType.Rezector">
            <summary>
            Режектор
            </summary>
        </member>
        <member name="F:AI.DSP.DSPCore.AFHType.Band">
            <summary>
            Полосовой
            </summary>
        </member>
        <member name="T:AI.DSP.DSPCore.GetSpectrEnerge">
            <summary>
            Анализ формант
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.GetSpectrEnerge.#ctor(System.Double)">
            <summary>
            Анализ формант
            </summary>
            <param name="fd">Частота дискретизации</param>
        </member>
        <member name="M:AI.DSP.DSPCore.GetSpectrEnerge.Add(System.Double,System.Double)">
            <summary>
            Добавление диапозона частот
            </summary>
            <param name="b">Начальная частота форманты</param>
            <param name="e">Конечная частота форманты</param>
        </member>
        <member name="M:AI.DSP.DSPCore.GetSpectrEnerge.GetAmplFreq(AI.DataStructs.Algebraic.Vector)">
            <summary>
             Возвращает суммарные амплитуды в формантах
            </summary>
            <param name="inp">Входной вектор</param>
            <returns>Вектор амплитуд</returns>
        </member>
        <member name="T:AI.DSP.DSPCore.IFilter">
            <summary>
            Интерфейс фильтра
            </summary>
        </member>
        <member name="P:AI.DSP.DSPCore.IFilter.Name">
            <summary>
            Имя фильтра
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.IFilter.FilterOutp(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Запуск фильтрации
            </summary>
            <param name="signal">Исходный сигнал</param>
            <returns>Отфильтрованный</returns>
        </member>
        <member name="T:AI.DSP.DSPCore.Kepstr">
            <summary>
            Кепстральный анализ
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.Kepstr.FKT(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Быстрое кепстральное преобразование
            </summary>
            <param name="signal">Сигнал</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Kepstr.WelchFKT(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Быстрое кепстральное преобразование
            </summary>
            <param name="signal">Сигнал</param>
            <param name="window_size_1">Размер окна для преобразования Welch1</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Kepstr.FKT(AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Быстрое кепстральное преобразование
            </summary>
            <param name="signal">Сигнал</param>
        </member>
        <member name="T:AI.DSP.DSPCore.OptimalFilter">
            <summary>
            Оптимальный (согласованный) фильтр
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.OptimalFilter.#ctor(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Оптимальный (согласованный) фильтр
            </summary>
            <param name="signal"></param>
            <param name="n"></param>
        </member>
        <member name="M:AI.DSP.DSPCore.OptimalFilter.Result(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прохождение фильтра
            </summary>
            <param name="signal">Сигнал на входе</param>
        </member>
        <member name="M:AI.DSP.DSPCore.OptimalFilter.SpectrCompressLFM(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Сжатие ЛЧМ по спектру
            </summary>
        </member>
        <member name="T:AI.DSP.DSPCore.Signal">
            <summary>
            Реализация сигналов
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Sin(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double)">
            <summary>
            Синусоидальные колебания
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">частота</param>
            <param name="fi">Начальная фаза</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Sin(AI.DataStructs.Algebraic.Vector,System.Double,AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Синусоидальные колебания
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">частота</param>
            <param name="fi">Начальная фаза</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Sin(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Синусоидальные колебания
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">частота</param>
            <param name="fi">Начальная фаза</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Sin(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Синусоидальные колебания
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">частота</param>
            <param name="fi">Начальная фаза</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Sin(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Синусоидальные колебания
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">частота</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Frequency(System.Int32,System.Double)">
            <summary>
            Массив частот
            </summary>
            <param name="Count">Кол-во значений</param>
            <param name="fd">Частота дискретизации</param>
            <returns>Вектор частот</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.FrequencyCentr(System.Int32,System.Double)">
            <summary>
            Центрированный массив частот 
            </summary>
            <param name="Count">Кол-во значений</param>
            <param name="fd">Частота дискретизации</param>
            <returns>Вектор частот</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Sin(AI.DataStructs.Algebraic.Vector,System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Синусоидальные колебания
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">частота</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Sin(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Синусоидальные колебания
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">частота</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Sin(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Синусоидальные колебания
            </summary>
            <param name="t">Вектор времени</param>
            <param name="f">частота</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Sin(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Синусоидальные колебания
            </summary>
            <param name="t">Вектор времени</param>
            <param name="f">частота</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Rect(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double)">
            <summary>
            Прямоугольный сигнал
            </summary>
            <param name="t">Вектор отсчетов времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">Частота</param>
            <param name="fi">Фаза</param>
            <returns>Отсчеты сигнала</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Rect(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Прямоугольный сигнал
            </summary>
            <param name="t">Вектор отсчетов времени</param>
            <param name="A">Вектор амплитуд</param>
            <param name="f">Частота</param>
            <param name="fi">Фаза</param>
            <returns>Отсчеты сигнала</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Rect(AI.DataStructs.Algebraic.Vector,System.Double,AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Прямоугольный сигнал
            </summary>
            <param name="t">Вектор отсчетов времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">Вектор частот</param>
            <param name="fi">Фаза</param>
            <returns>Отсчеты сигнала</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Rect(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прямоугольный сигнал
            </summary>
            <param name="t">Вектор отсчетов времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">Частота</param>
            <param name="fi">Вектор фаз</param>
            <returns>Отсчеты сигнала</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Rect(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Прямоугольный сигнал
            </summary>
            <param name="t">Вектор отсчетов времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">Частота</param>
            <returns>Отсчеты сигнала</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Rect(AI.DataStructs.Algebraic.Vector,System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прямоугольный сигнал
            </summary>
            <param name="t">Вектор отсчетов времени</param>
            <param name="A">Амплитуда</param>
            <param name="f">Вектор частот</param>
            <returns>Отсчеты сигнала</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Rect(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Прямоугольный сигнал
            </summary>
            <param name="t">Вектор отсчетов времени</param>
            <param name="A">Вектор амплитуда</param>
            <param name="f">Вектор частот</param>
            <returns>Отсчеты сигнала</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Rect(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Прямоугольный сигнал
            </summary>
            <param name="t">Вектор отсчетов времени</param>
            <param name="f">Частота</param>
            <returns>Отсчеты сигнала</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Rect(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прямоугольный сигнал
            </summary>
            <param name="t">Вектор отсчетов времени</param>
            <param name="f">Вектор частот</param>
            <returns>Отсчеты сигнала</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.AmkRect(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Амплитудно-модулированые колебания (прямоугольное модулирующее колебание)
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f1">Несущая частота</param>
            <param name="fi1">Фаза модулирующего сигала</param>
            <param name="f2">Частота модулятора</param>
            <param name="fi2">Фаза модулируемого сигала</param>
            <param name="k">Коэф. модуляции</param>
            <returns>Вектор отсчетов</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.AmkRect(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Амплитудно-модулированые колебания (прямоугольное модулирующее колебание)
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f1">Несущая частота</param>
            <param name="f2">Частота модулятора</param>
            <param name="fi2">Фаза модулируемого сигала</param>
            <param name="k">Коэф. модуляции</param>
            <returns>Вектор отсчетов</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.AmkRect(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Амплитудно-модулированые колебания (прямоугольное модулирующее колебание)
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f1">Несущая частота</param>
            <param name="f2">Частота модулятора</param>
            <param name="k">Коэф. модуляции</param>
            <returns>Вектор отсчетов</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.AmkRectK(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double)">
            <summary>
            Амплитудно-модулированые колебания (прямоугольное модулирующее колебание)
            </summary>
            <param name="t">Вектор времени</param>
            <param name="f1">Несущая частота</param>
            <param name="f2">Частота модулятора</param>
            <param name="k">Коэф. модуляции</param>
            <returns>Вектор отсчетов</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.AmkRectA(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double)">
            <summary>
            Амплитудно-модулированые колебания (прямоугольное модулирующее колебание)
            </summary>
            <param name="t">Вектор времени</param>
            <param name="A">Амплитуда</param>
            <param name="f1">Несущая частота</param>
            <param name="f2">Частота модулятора</param>
            <returns>Вектор отсчетов</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.AmkRect(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Амплитудно-модулированые колебания
            </summary>
            <param name="t"></param>
            <param name="f1"></param>
            <param name="f2"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.DampedOscillations(AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Затухающие колебания
            </summary>
            <param name="t">Время симуляции</param>
            <param name="f">частота</param>
            <param name="kDamp">Коэффициент затухания</param>
            <param name="A">Амплитуда(начальная)</param>
            <param name="fi">Фаза</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Energe(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Энергия выделяемая на едичном резисторе за все время
            </summary>
            <param name="signal">Сигнал отсчеты</param>
            <param name="fd">Частота дискретизация</param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.LFMRectNP(System.Double,System.Int32,System.Int32,System.Double)">
            <summary>
            Пачка ЛЧМ
            </summary>
            <param name="f"></param>
            <param name="f0"></param>
            <param name="fd"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.LFM(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            ЛЧМ
            </summary>
            <param name="df"></param>
            <param name="f0"></param>
            <param name="fd"></param>
            <param name="time"></param>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Perediscr(AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32)">
            <summary>
            Передискретизация сигнала
            (повышение частоты дискретизации в целое число раз)
            </summary>
            <param name="inp">Входной вектор</param>
            <param name="fd">Старая частота дискретизации</param>
            <param name="newfd">Новая частота дикретизации</param>
            <returns>Вектор тойже длительности, что и входной,
            но с более высокой частотой дискретизации</returns>
        </member>
        <member name="M:AI.DSP.DSPCore.Signal.Norm(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Норма сигнала
            </summary>
            <param name="signal"></param>
            <param name="fd"></param>
            <returns></returns>
        </member>
        <member name="T:AI.DSP.DSPCore.Wavelet">
            <summary>
            Вейвлеты
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.Wavelet.#ctor(AI.DSP.DSPCore.PerentWavelet)">
            <summary>
            Непрерывное вейвлет преобразование
            </summary>
            <param name="pw">Порождение вейвлетов</param>
        </member>
        <member name="M:AI.DSP.DSPCore.Wavelet.SerchPatern(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Поиск патернов в сигнале
            </summary>
            <param name="sig">Сигнал</param>
            <returns>Максимумы патернов</returns>
        </member>
        <member name="T:AI.DSP.DSPCore.PerentWavelet">
            <summary>
            Функция порождения вейвлетов
            </summary>
        </member>
        <member name="F:AI.DSP.DSPCore.PerentWavelet.waveletSpectrs">
            <summary>
            Спектры ф-й
            </summary>
        </member>
        <member name="F:AI.DSP.DSPCore.PerentWavelet.fur">
            <summary>
            Фурье
            </summary>
        </member>
        <member name="F:AI.DSP.DSPCore.PerentWavelet.std">
            <summary>
            Вектор СКО
            </summary>
        </member>
        <member name="F:AI.DSP.DSPCore.PerentWavelet.scals">
            <summary>
            Масштабы
            </summary>
        </member>
        <member name="M:AI.DSP.DSPCore.PerentWavelet.#ctor(System.Func{System.Double,AI.DataStructs.Algebraic.Vector},AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Порождения вейвлетов
            </summary>
            <param name="wavelet">Порождающая функция</param>
            <param name="scales">Масштабы</param>
            <param name="n">Размерность входа</param>
        </member>
        <member name="T:AI.DSP.FIR.FIRFilter">
            <summary>
            Фильтр с конечной импульсной характеристикой
            </summary>
        </member>
        <member name="P:AI.DSP.FIR.FIRFilter.Name">
            <summary>
            Имя фильтра
            </summary>
        </member>
        <member name="M:AI.DSP.FIR.FIRFilter.#ctor(AI.DataStructs.Algebraic.Vector,System.Int32,AI.DSP.FIR.FIRCalcConvType)">
            <summary>
            Инициализация фильтра
            </summary>
            <param name="ht">Импульсивный ответ фильтра</param>
            <param name="fd">Частота дискретизации</param>
            <param name="calcConvType">Метод расчета свертки</param>
        </member>
        <member name="M:AI.DSP.FIR.FIRFilter.FilterOutp(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Расчет отклика фильтра на сигнал
            </summary>
            <param name="input">Сигнал</param>
        </member>
        <member name="T:AI.DSP.FIR.FIRCalcConvType">
            <summary>
            Метод расчета свертки
            </summary>
        </member>
        <member name="F:AI.DSP.FIR.FIRCalcConvType.Simple">
            <summary>
            Простая свертка
            </summary>
        </member>
        <member name="F:AI.DSP.FIR.FIRCalcConvType.WithFFT">
            <summary>
            Быстрая с исп. БПФ
            </summary>
        </member>
        <member name="F:AI.DSP.FIR.FIRCalcConvType.Sectional">
            <summary>
            Секционная
            </summary>
        </member>
        <member name="F:AI.DSP.FIR.FIRCalcConvType.Sectional4">
            <summary>
            Секционная 4 потока
            </summary>
        </member>
        <member name="T:AI.DSP.IIR.IIRFilter">
            <summary>
            БИХ фильтр
            </summary>
        </member>
        <member name="P:AI.DSP.IIR.IIRFilter.Name">
            <summary>
            Имя фильтра
            </summary>
        </member>
        <member name="P:AI.DSP.IIR.IIRFilter.A">
            <summary>
            Коэффициенты "A"
            </summary>
        </member>
        <member name="P:AI.DSP.IIR.IIRFilter.B">
            <summary>
            Коэффициенты B (числитель)
            </summary>
        </member>
        <member name="P:AI.DSP.IIR.IIRFilter.Treshold">
            <summary>
            Ограничение сигнала
            </summary>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.#ctor(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            БИХ фильтр
            </summary>
            <param name="a">Коэффициенты "A"</param>
            <param name="b">Коэффициенты B (числитель)</param>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.FilterOutp(System.Double)">
            <summary>
            Filter output
            </summary>
            <param name="inp">Вход</param>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.FilterOutp(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Выход рекурсивного фильтра
            </summary>
            <param name="signal">Входной сигнал</param>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.FilterOutp(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Выход рекурсивного фильтра
            </summary>
            <param name="signal">Входной сигнал</param>
            <param name="iteration">Итерации фильтрации</param>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.Reset">
            <summary>
            Сброс состояния нейронной сети
            </summary>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.ExportState">
            <summary>
            Экспорт состояния
            </summary>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.ImportState(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32)">
            <summary>
            Импорт состояния фильтра
            </summary>
            <param name="inputs">Входы</param>
            <param name="outputs">Выходы (целевые значения)</param>
            <param name="offsetA">Смещение выходов</param>
            <param name="offsetB">Смещение входов</param>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.Save(System.String)">
            <summary>
            Созранение фильтра
            </summary>
            <param name="path">Путь</param>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.Load(System.String)">
            <summary>
            Загрузка фильтра
            </summary>
            <param name="path">Путь</param>
        </member>
        <member name="M:AI.DSP.IIR.IIRFilter.Load(System.Byte[])">
            <summary>
            Загрузка фильтра
            </summary>
            <param name="data">Буфер данных</param>
        </member>
        <member name="T:AI.DSP.Modulation.AM">
            <summary>
            Амплитудная модуляция
            </summary>
        </member>
        <member name="M:AI.DSP.Modulation.AM.#ctor(System.Int32,System.Double,System.Double)">
            <summary>
            Инициализация модулятора ампл. модуляции
            </summary>
            <param name="fd">Частота дискретизации</param>
            <param name="f0">Несущая частота</param>
            <param name="m">Коэф. модуляции</param>
        </member>
        <member name="M:AI.DSP.Modulation.AM.Modulate(AI.DSP.Channel)">
            <summary>
            Модуляция
            </summary>
            <param name="signalIn"></param>
            <returns></returns>
        </member>
        <member name="M:AI.DSP.Modulation.AM.Demodulate(AI.DSP.Channel)">
            <summary>
            Демодуляция
            </summary>
            <param name="channel">Канал с модулированным сигналом</param>
        </member>
        <member name="M:AI.DSP.Modulation.AM.ModulateSimple(AI.DSP.Channel)">
            <summary>
            Модуляция для сигналов с одинаковой частотой дискретизации
            </summary>
            <param name="signalIn">Входной сигнал</param>
        </member>
        <member name="T:AI.DSP.Modulation.IModulator">
            <summary>
            Интерфейс модулятора
            </summary>
        </member>
        <member name="M:AI.DSP.Modulation.IModulator.Modulate(AI.DSP.Channel)">
            <summary>
            Модуляция сигнала
            </summary>
            <param name="channel">Channel</param>
        </member>
        <member name="M:AI.DSP.Modulation.IModulator.Demodulate(AI.DSP.Channel)">
            <summary>
            Демодуляция сигнала
            </summary>
            <param name="channel">Channel</param>
        </member>
        <member name="T:AI.DSP.MusicUtils.EchoReverb">
            <summary>
            Эхо и реверберация
            </summary>
        </member>
        <member name="P:AI.DSP.MusicUtils.EchoReverb.SampleRate">
            <summary>
            Частота дискретизации проекта
            </summary>
        </member>
        <member name="M:AI.DSP.MusicUtils.EchoReverb.#ctor(System.Int32)">
            <summary>
            Эхо и реверберация
            </summary>
            <param name="sr">Частота дискретизации проекта</param>
        </member>
        <member name="M:AI.DSP.MusicUtils.EchoReverb.Echo(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Эхо
            </summary>
        </member>
        <member name="M:AI.DSP.MusicUtils.EchoReverb.EchoInvers(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Эхо
            </summary>
        </member>
        <member name="T:AI.DSP.Oversampling.UpSampling">
            <summary>
            Увеличение частоты дискретизации
            </summary>
        </member>
        <member name="M:AI.DSP.Oversampling.UpSampling.UpSamplingRectFilter(AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32)">
            <summary>
            Увеличение частоты дискретизации(Фильтр с прямоугольной АЧХ)
            </summary>
            <param name="signal">Сигнал</param>
            <param name="fd">Частота дискретизации</param>
            <param name="kUpSemp">Во сколько раз увеличить</param>
        </member>
        <member name="M:AI.DSP.Oversampling.UpSampling.UpSamplingButterworthFilter(AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32,System.Int32)">
            <summary>
            Увеличение частоты дискретизации(Фильтр Баттерворта)
            </summary>
            <param name="signal">Сигнал</param>
            <param name="fd">Частота дискретизации</param>
            <param name="kUpSemp">Во сколько раз увеличить</param>
            <param name="order">Порядок фильтра</param>
        </member>
        <member name="M:AI.DSP.Oversampling.UpSampling.UpSamplingButterworthFilterW(AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32,System.Int32)">
            <summary>
            Увеличение частоты дискретизации(Фильтр Баттерворта)
            </summary>
            <param name="signal">Сигнал</param>
            <param name="fd">Частота дискретизации</param>
            <param name="kUpSemp">Во сколько раз увеличить</param>
            <param name="order">Порядок фильтра</param>
        </member>
        <member name="T:AI.DSP.PhaseCorrectingWindow">
            <summary>
            Равнобедренная трапеция (окно убирающее разрыв фазы)
            </summary>
        </member>
        <member name="M:AI.DSP.PhaseCorrectingWindow.Trapezoid(System.Int32,System.Double)">
            <summary>
            Равнобедренная трапеция
            </summary>
            <param name="len">Длинна основания</param>
            <param name="slope">Угол наклона</param>
            <returns></returns>
        </member>
        <member name="T:AI.DSP.Signal1D">
            <summary>
            Основной класс для одномерного сигнала
            </summary>
        </member>
        <member name="P:AI.DSP.Signal1D.Name">
            <summary>
            Имя сигнала
            </summary>
        </member>
        <member name="P:AI.DSP.Signal1D.Description">
            <summary>
            Описание сигнала
            </summary>
        </member>
        <member name="P:AI.DSP.Signal1D.Fd">
            <summary>
            Частота дискретизации
            </summary>
        </member>
        <member name="P:AI.DSP.Signal1D.Dt">
            <summary>
            Шаг по времени
            </summary>
        </member>
        <member name="P:AI.DSP.Signal1D.ScaleVolt">
            <summary>
            Масштаб в вольтах
            </summary>
        </member>
        <member name="M:AI.DSP.Signal1D.#ctor(AI.DataStructs.Algebraic.Vector[],System.Int32)">
            <summary>
            Инициализация многоканальным сигналом
            </summary>
            <param name="channels">Сигнал</param>
            <param name="fd">Частота дискретизации</param>
        </member>
        <member name="M:AI.DSP.Signal1D.#ctor">
            <summary>
            Создает пустой список каналов
            </summary>
        </member>
        <member name="M:AI.DSP.Signal1D.#ctor(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Инициализация многоканальным сигналом
            </summary>
            <param name="signal">Сигнал</param>
            <param name="fd">Частота дискретизации</param>
        </member>
        <member name="M:AI.DSP.Signal1D.#ctor(AI.DSP.Channel)">
            <summary>
            Инициализация многоканальным сигналом
            </summary>
            <param name="signal">Сигнал</param>
        </member>
        <member name="M:AI.DSP.Signal1D.Add(AI.DSP.Channel)">
            <summary>
            Добавление сигнала
            </summary>
            <param name="signal">Сигнал</param>
        </member>
        <member name="M:AI.DSP.Signal1D.Trends">
            <summary>
            Тренды сигнала
            </summary>
        </member>
        <member name="M:AI.DSP.Signal1D.SignalWithoutTrend">
            <summary>
            Сигнал без тренда
            </summary>
        </member>
        <member name="M:AI.DSP.Signal1D.SignalWithM0Std1Trend">
            <summary>
            Сигнал нулевым мат. ожиданием и средне квадратичным отклонением равным 1 (вычитается тренд)
            </summary>
        </member>
        <member name="M:AI.DSP.Signal1D.SignalWithM0Std1">
            <summary>
            Сигнал нулевым мат. ожиданием и средне квадратичным отклонением равным 1 (вычитается среднее)
            </summary>
        </member>
        <member name="M:AI.DSP.Signal1D.GetSpectr(System.Int32)">
            <summary>
            Рассчитывает спектр
            </summary>
            <param name="numCh">Номер канала</param>
            <returns>Амплитудный спектр частоты 0 .. fd/2</returns>
        </member>
        <member name="M:AI.DSP.Signal1D.GetSpectrAll">
            <summary>
            Рассчитывает спектр по всем каналам
            </summary>
            <returns>Спектры</returns>
        </member>
        <member name="M:AI.DSP.Signal1D.CorrelationMatrix">
            <summary>
            Корреляционная матрица по каналам
            </summary>
            <returns>Матрица</returns>
        </member>
        <member name="M:AI.DSP.Signal1D.CorrelationMatrixSpectr">
            <summary>
            Корреляционная матрица амплитудных спектров
            </summary>
            <returns>Матрица</returns>
        </member>
        <member name="M:AI.DSP.Signal1D.CouplingCoefficient">
            <summary>
            Коэффициент связи между каналами рассчитывается как, единица минус определитель корреляционной матрицы
            </summary>
            <returns>Коэфициент связи [1,0] близко к 1 связь сильная, к 0 слабая</returns>
        </member>
        <member name="M:AI.DSP.Signal1D.CouplingCoefficientSp">
            <summary>
            Коэффициент связи между сперктрами каналов рассчитывается как, единица минус определитель корреляционной матрицы амплитудных спектров
            </summary>
            <returns>Коэфициент связи [1,0] близко к 1 связь сильная, к 0 слабая</returns>
        </member>
        <member name="M:AI.DSP.Signal1D.Time">
            <summary>
            Генерация отсчетов времени
            </summary>
            <returns>Отсчеты времени</returns>
        </member>
        <member name="M:AI.DSP.Signal1D.Freq">
            <summary>
            Генерация отсчетов частоты
            </summary>
            <returns>Отсчеты частоты</returns>
        </member>
        <member name="M:AI.DSP.Signal1D.ConvertVolt(AI.DSP.TypeScaleVolt)">
            <summary>
            Конвертирование шкалы напряжения 
            </summary>
            <param name="typeScaleVolt">Новый масштаб</param>
        </member>
        <member name="M:AI.DSP.Signal1D.Filtration(AI.DSP.DSPCore.IFilter)">
            <summary>
            Фильтрация сигнала
            </summary>
            <param name="filter">Фильтр</param>
        </member>
        <member name="M:AI.DSP.Signal1D.YName">
            <summary>
            Единица измерения шкалы Y
            </summary>
        </member>
        <member name="M:AI.DSP.Signal1D.ChannelNames">
            <summary>
            Список имен каналов
            </summary>
        </member>
        <member name="T:AI.DSP.ISpectr">
            <summary>
            Базовый интерфейс реализации спектров
            </summary>
        </member>
        <member name="P:AI.DSP.ISpectr.Freq">
            <summary>
            Отсчеты частоты
            </summary>
        </member>
        <member name="P:AI.DSP.ISpectr.Data">
            <summary>
            Данные спектра
            </summary>
        </member>
        <member name="P:AI.DSP.ISpectr.Name">
            <summary>
            Имя
            </summary>
        </member>
        <member name="P:AI.DSP.ISpectr.YLable">
            <summary>
            Название шкалы Y
            </summary>
        </member>
        <member name="P:AI.DSP.ISpectr.XLable">
            <summary>
            Название шкалы X
            </summary>
        </member>
        <member name="P:AI.DSP.ISpectr.IsDbScale">
            <summary>
            Выводится ли шкала данные по Y в децибелах
            </summary>
        </member>
        <member name="P:AI.DSP.ISpectr.LogScaleX">
            <summary>
            Логарифмическая ли шкала частот
            </summary>
        </member>
        <member name="T:AI.DSP.AmplitudeSpectr">
            <summary>
            Амплитудный спектр
            </summary>
        </member>
        <member name="P:AI.DSP.AmplitudeSpectr.Freq">
            <summary>
            Отсчеты частоты
            </summary>
        </member>
        <member name="P:AI.DSP.AmplitudeSpectr.Data">
            <summary>
            Амплитуды спектра
            </summary>
        </member>
        <member name="P:AI.DSP.AmplitudeSpectr.Name">
            <summary>
            Имя
            </summary>
        </member>
        <member name="P:AI.DSP.AmplitudeSpectr.YLable">
            <summary>
            Название шкалы Y
            </summary>
        </member>
        <member name="P:AI.DSP.AmplitudeSpectr.XLable">
            <summary>
            Название шкалы X
            </summary>
        </member>
        <member name="P:AI.DSP.AmplitudeSpectr.IsDbScale">
            <summary>
            Выводится ли шкала данные по Y в децибелах
            </summary>
        </member>
        <member name="P:AI.DSP.AmplitudeSpectr.LogScaleX">
            <summary>
            Логарифмическая ли шкала частот
            </summary>
        </member>
        <member name="M:AI.DSP.AmplitudeSpectr.#ctor(AI.DSP.Channel,System.Boolean)">
            <summary>
            Амплитудный спектр
            </summary>
            <param name="channel">Channel</param>
            <param name="isDbScale">Выражать ли в db, 20log(x)</param>
        </member>
        <member name="M:AI.DSP.AmplitudeSpectr.#ctor(AI.DSP.Channel,System.Func{System.Int32,AI.DataStructs.Algebraic.Vector},System.Boolean)">
            <summary>
            Амплитудный спектр
            </summary>
            <param name="channel">Channel</param>
            <param name="windowWFunc">Оконная функция</param>
            <param name="isDbScale">Выражать ли в db, 20log(x)</param>
        </member>
        <member name="T:AI.DSP.SpectrumStretching">
            <summary>
            Растяжение и сжатие спектра
            </summary>
        </member>
        <member name="M:AI.DSP.SpectrumStretching.SpectrumStretch(AI.DataStructs.Algebraic.Vector,System.Double,System.Int32)">
            <summary>
            Растяжение спектра
            </summary>
            <param name="signal">Входной сигнал</param>
            <param name="k">Коэффициент растяжения</param>
            <param name="lFilt"></param>
        </member>
        <member name="T:AI.DSP.TypeScaleVolt">
            <summary>
            Масштаб в вольтах
            </summary>
        </member>
        <member name="F:AI.DSP.TypeScaleVolt.kV">
            <summary>
            Киловольты 
            </summary>
        </member>
        <member name="F:AI.DSP.TypeScaleVolt.V">
            <summary>
            Вольты
            </summary>
        </member>
        <member name="F:AI.DSP.TypeScaleVolt.mV">
            <summary>
            Милливольты
            </summary>
        </member>
        <member name="F:AI.DSP.TypeScaleVolt.uV">
            <summary>
            Микровольты
            </summary>
        </member>
        <member name="F:AI.DSP.TypeScaleVolt.nV">
            <summary>
            Нановольты
            </summary>
        </member>
        <member name="T:AI.FFT">
            <summary>
            Быстрое преобразование Фурье (БПФ)
            </summary>
        </member>
        <member name="F:AI.FFT.SemplesCount">
            <summary>
            Число отсчетов БПФ
            </summary>
        </member>
        <member name="M:AI.FFT.#ctor(System.Int32)">
            <summary>
            FFT (init rotate coef)
            </summary>
        </member>
        <member name="M:AI.FFT.BaseStaticFFT(AI.DataStructs.WithComplexElements.ComplexVector,System.Boolean)">
            <summary>
            Базовый статичный метод, для БПФ
            </summary>
            <param name="input">Данные входа</param>
            <param name="canonic">Если true, то ядро jwt, если false, то -jwt</param>
            <returns></returns>
        </member>
        <member name="M:AI.FFT.CalcFFT(AI.DataStructs.Algebraic.Vector,System.Boolean)">
            <summary>
            Расчет БПФ
            </summary>
        </member>
        <member name="M:AI.FFT.CalcFFT(System.Double[],System.Int32,System.Boolean)">
            <summary>
            Расчет БПФ
            </summary>
        </member>
        <member name="M:AI.FFT.CalcIFFTReal(System.Numerics.Complex[],System.Int32)">
            <summary>
            Расчет БПФ
            </summary>
        </member>
        <member name="M:AI.FFT.RealIFFT(AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Действительная часть обратного БПФ
            </summary>
        </member>
        <member name="M:AI.FFT.RealIFFT2(AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Действительная часть обратного БПФ(Без нормализации)
            </summary>
        </member>
        <member name="M:AI.FFT.GetSpectrum(AI.DataStructs.Algebraic.Vector,System.Func{System.Int32,AI.DataStructs.Algebraic.Vector})">
            <summary>
            Получение спектра в диапазоне (0, fd/2)
            </summary>
            <param name="input">Вектор входных данных</param>
            <param name="window">Оконная функция</param>
        </member>
        <member name="M:AI.FFT.IFFT(AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Обратное преобразование Фурье (ОБПФ)
            </summary>
            <param name="inp">Вход</param>
        </member>
        <member name="M:AI.FFT.CalcIFFT(System.Numerics.Complex[])">
            <summary>
            Возвращает спектр сигнала
            </summary>
            <param name="inp">Массив значений сигнала. Количество значений должно быть степенью 2</param>
            <returns>Массив со значениями спектра сигнала</returns>
        </member>
        <member name="M:AI.FFT.CalcFFT(AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Возвращает комплексный вектор спектра сигнала
            </summary>
            <param name="inp">Массив значений сигнала. Количество значений должно быть степенью 2</param>
            <returns>Массив со значениями спектра сигнала</returns>
        </member>
        <member name="M:AI.FFT.CalcFFT(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Быстрое преобразование Фурье(БПФ)
            </summary>
            <param name="inp">Входной вектор</param>
        </member>
        <member name="M:AI.FFT.CalcIFFT(AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            ОБПФ
            </summary>
            <param name="inp">Входной вектор</param>
        </member>
        <member name="M:AI.FFT.CalcIFFT(AI.DataStructs.Algebraic.Vector)">
            <summary>
            ОБПФ
            </summary>
            <param name="inp">Входной вектор</param>
        </member>
        <member name="M:AI.FFT.TimeFrTransform(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Частотно-временное преобразование
            </summary>
            <param name="vect">Вектор</param>
            <param name="lenFr">Frame size</param>
        </member>
        <member name="M:AI.FFT.TimeFrTransformHalf(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Частотно-временное преобразование
            </summary>
            <param name="vect">Вектор</param>
            <param name="lenFr">Frame size</param>
        </member>
        <member name="T:AI.WindowForFFT">
            <summary>
            FFT Оконная функцияs
            </summary>
        </member>
        <member name="M:AI.WindowForFFT.HannWindow(System.Int32)">
            <summary>
            Окно Ханна (Хенинга) (-31 дб)
            </summary>
            <param name="windowSize">Размер окна</param>
        </member>
        <member name="M:AI.WindowForFFT.HammingWindow(System.Int32)">
            <summary>
            Окно Хэмминга (-42 дб)
            </summary>
            <param name="windowSize">Размер окна</param>
        </member>
        <member name="M:AI.WindowForFFT.RectWindow(System.Int32)">
            <summary>
            Прямоугольное окно (-13 дб)
            </summary>
            <param name="windowSize">Размер окна</param>
        </member>
        <member name="M:AI.WindowForFFT.BlackmanWindow(System.Int32)">
            <summary>
            Окно Блэкмана (-58 дб)
            </summary>
            <param name="windowSize">Размер окна</param>
        </member>
        <member name="T:AI.Extensions.AlgebraicStructsExtensions">
            <summary>
            Расширения для алгебраических методов
            </summary>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.MatricesToTensor(AI.DataStructs.Algebraic.Matrix[])">
            <summary>
            Преобразование массива в тензор
            </summary>
            <param name="matrices">Массив матриц</param>
            <returns>Тензор</returns>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToVector(System.Double[])">
            <summary>
            Преобразование массива в вектор
            </summary>
            <param name="array">Массив</param>
            <returns>Вектор</returns>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToVector(System.Single[])">
            <summary>
            Преобразование массива в вектор
            </summary>
            <param name="array">Массив</param>
            <returns>Вектор</returns>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToVector(System.Int32[])">
            <summary>
            Преобразование массива в вектор
            </summary>
            <param name="array">Массив</param>
            <returns>Вектор</returns>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToVector(System.Int64[])">
            <summary>
            Преобразование массива в вектор
            </summary>
            <param name="array">Массив</param>
            <returns>Вектор</returns>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToVector(System.Decimal[])">
            <summary>
            Преобразование массива в вектор
            </summary>
            <param name="array">Массив</param>
            <returns>Вектор</returns>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToVector(System.Int16[])">
            <summary>
            Преобразование массива в вектор
            </summary>
            <param name="array">Массив</param>
            <returns>Вектор</returns>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToVector(System.Byte[])">
            <summary>
            Преобразование массива в вектор
            </summary>
            <param name="array">Массив</param>
            <returns>Вектор</returns>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToMatrix(System.Double[],System.Int32,System.Int32)">
            <summary>
            Преобразование массива в матрицу
            </summary>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToMatrix(System.Single[],System.Int32,System.Int32)">
            <summary>
            Преобразование массива в матрицу
            </summary>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToMatrix(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Преобразование массива в матрицу
            </summary>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToMatrix(System.Int16[],System.Int32,System.Int32)">
            <summary>
            Преобразование массива в матрицу
            </summary>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToMatrix(System.Decimal[],System.Int32,System.Int32)">
            <summary>
            Преобразование массива в матрицу
            </summary>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToMatrix(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Преобразование массива в матрицу
            </summary>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToMatrix(System.Int64[],System.Int32,System.Int32)">
            <summary>
            Преобразование массива в матрицу
            </summary>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToMatrix(System.Double[0:,0:])">
            <summary>
            Преобразование массива в матрицу
            </summary>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToMatrix(System.Int32[0:,0:])">
            <summary>
            Преобразование массива в матрицу
            </summary>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToMatrix(System.Int64[0:,0:])">
            <summary>
            Преобразование массива в матрицу
            </summary>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToMatrix(System.Int16[0:,0:])">
            <summary>
            Преобразование массива в матрицу
            </summary>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToMatrix(System.Single[0:,0:])">
            <summary>
            Преобразование массива в матрицу
            </summary>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.ToMatrix(System.Byte[0:,0:])">
            <summary>
            Преобразование массива в матрицу
            </summary>
        </member>
        <member name="M:AI.Extensions.AlgebraicStructsExtensions.GetDimention(AI.DataStructs.Algebraic.Vector[],System.Int32)">
            <summary>
            Getting the vector of the desired coordinate from the array of vectors
            </summary>
            <param name="array"></param>
            <param name="dim"></param>
            <returns></returns>
        </member>
        <member name="T:AI.Extensions.ArraysExtensions">
            <summary>
            Расширения для конвертации массивов
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ToDoubleArray(System.Single[])">
            <summary>
            Конвертация в массив элементов типа double
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ToDoubleArray(System.Int32[])">
            <summary>
            Конвертация в массив элементов типа double
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ToDoubleArray(System.Int64[])">
            <summary>
            Конвертация в массив элементов типа double
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ToDoubleArray(System.Decimal[])">
            <summary>
            Конвертация в массив элементов типа double
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ToDoubleArray(System.Int16[])">
            <summary>
            Конвертация в массив элементов типа double
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ToDoubleArray(System.Byte[])">
            <summary>
            Конвертация в массив элементов типа double
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ToDoubleArray2D(System.Single[0:,0:])">
            <summary>
            Конвертация в массив элементов типа double
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ToDoubleArray2D(System.Int32[0:,0:])">
            <summary>
            Конвертация в массив элементов типа double
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ToDoubleArray2D(System.Int64[0:,0:])">
            <summary>
            Конвертация в массив элементов типа double
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ToDoubleArray2D(System.Decimal[0:,0:])">
            <summary>
            Конвертация в массив элементов типа double
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ToDoubleArray2D(System.Int16[0:,0:])">
            <summary>
            Конвертация в массив элементов типа double
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ToDoubArray2D(System.Byte[0:,0:])">
            <summary>
            Конвертация в массив элементов типа double
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ToFloatArray(System.Double[])">
            <summary>
            Конвертация в массив элементов типа float
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ToFloatArray(System.Int32[])">
            <summary>
            Конвертация в массив элементов типа float
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ToFloatArray(System.Decimal[])">
            <summary>
            Конвертация в массив элементов типа float
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ToFloatArray(System.Int64[])">
            <summary>
            Конвертация в массив элементов типа float
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ToFloatArray(System.Int16[])">
            <summary>
            Конвертация в массив элементов типа float
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ToFloatArray(System.Byte[])">
            <summary>
            Конвертация в массив элементов типа float
            </summary>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.Transform``2(``0[],System.Func{``0,``1})">
            <summary>
            Поэлементное преобразование над элементами исходного массива с созданием выходного массифа нужного типа
            </summary>
            <typeparam name="TI">Тип фходного массива</typeparam>
            <typeparam name="TO">Тип выходного массива</typeparam>
            <param name="array">Входной массив</param>
            <param name="function">Функция преобразования</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.ArraysExtensions.ElementWiseEqual``1(``0[],``0[])">
            <summary>
            Поэлементное сравнение 2х массивов
            </summary>
            <typeparam name="T">Тип массивов</typeparam>
            <param name="arr1"></param>
            <param name="arr2"></param>
            <returns></returns>
        </member>
        <member name="T:AI.Extensions.DataStreamExtensions">
            <summary>
            Работа с массивами байт
            </summary>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ToDataStream(System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            Получение объекта памяти
            </summary>
            <param name="array">Массив байт</param>
            <param name="isEncrypted">Зашифрован ли объект</param>
            <param name="isZipped">Сжат ли объект</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ToDataStream(AI.DataStructs.IByteConvertable)">
            <summary>
            Получение объекта памяти
            </summary>
            <param name="convertable">AI объект конвертируемый в байты</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.Write(AI.DataStructs.InMemoryDataStream,AI.DataStructs.IByteConvertable)">
            <summary>
            Writes IByteConvertable to the stream
            </summary>
            <param name="stream">Поток</param>
            <param name="convertable"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.Write(AI.DataStructs.InMemoryDataStream,AI.DataStructs.IByteConvertable[])">
            <summary>
            Writes IByteConvertable array to the stream
            </summary>
            <param name="stream">Поток</param>
            <param name="convertables"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadVector(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads vector from the stream
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadVector(AI.DataStructs.InMemoryDataStream,AI.DataStructs.Algebraic.Vector@)">
            <summary>
            Reads vector from the stream
            </summary>
            <param name="stream">Поток</param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadVectors(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads vector array from the stream
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadVectors(AI.DataStructs.InMemoryDataStream,AI.DataStructs.Algebraic.Vector[]@)">
            <summary>
            Reads vector array from the stream
            </summary>
            <param name="stream">Поток</param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadMatrix(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads matrix from the stream
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadMatrix(AI.DataStructs.InMemoryDataStream,AI.DataStructs.Algebraic.Matrix@)">
            <summary>
            Reads matrix from the stream
            </summary>
            <param name="stream">Поток</param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadMatrices(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads matrix array from the stream
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadMatrices(AI.DataStructs.InMemoryDataStream,AI.DataStructs.Algebraic.Matrix[]@)">
            <summary>
            Reads matrix array from the stream
            </summary>
            <param name="stream">Поток</param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadTensor(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads tensor from the stream
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadTensor(AI.DataStructs.InMemoryDataStream,AI.DataStructs.Algebraic.Tensor@)">
            <summary>
            Reads tensor from the stream
            </summary>
            <param name="stream">Поток</param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadTensors(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads tensor array from the stream
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadTensors(AI.DataStructs.InMemoryDataStream,AI.DataStructs.Algebraic.Tensor[]@)">
            <summary>
            Reads tensor array from the stream
            </summary>
            <param name="stream">Поток</param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadNDTensor(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads NDTensor from the stream
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadNDTensor(AI.DataStructs.InMemoryDataStream,AI.DataStructs.Algebraic.NDTensor@)">
            <summary>
            Reads NDTensor from the stream
            </summary>
            <param name="stream">Поток</param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadNDTensors(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads NDTensor array from the stream
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadNDTensors(AI.DataStructs.InMemoryDataStream,AI.DataStructs.Algebraic.NDTensor[]@)">
            <summary>
            Reads NDTensor array from the stream
            </summary>
            <param name="stream">Поток</param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadNNValue(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads NNValue from the stream
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadNNValue(AI.DataStructs.InMemoryDataStream,AI.ML.NeuralNetwork.CoreNNW.NNValue@)">
            <summary>
            Reads NNValue from the stream
            </summary>
            <param name="stream">Поток</param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadNNValues(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads NNValue array from the stream
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadNNValues(AI.DataStructs.InMemoryDataStream,AI.ML.NeuralNetwork.CoreNNW.NNValue[]@)">
            <summary>
            Reads NNValue array from the stream
            </summary>
            <param name="stream">Поток</param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadComplexVector(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads complex vector from the stream
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadComplexVector(AI.DataStructs.InMemoryDataStream,AI.DataStructs.WithComplexElements.ComplexVector@)">
            <summary>
            Reads complex vector from the stream
            </summary>
            <param name="stream">Поток</param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadComplexVectors(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads complex vector array from the stream
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadComplexVectors(AI.DataStructs.InMemoryDataStream,AI.DataStructs.WithComplexElements.ComplexVector[]@)">
            <summary>
            Reads complex vector array from the stream
            </summary>
            <param name="stream">Поток</param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadComplexMatrix(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads complex matrix from the stream
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadComplexMatrix(AI.DataStructs.InMemoryDataStream,AI.DataStructs.WithComplexElements.ComplexMatrix@)">
            <summary>
            Reads complex matrix from the stream
            </summary>
            <param name="stream">Поток</param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadComplexMatrices(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Reads complex matrix array from the stream
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.DataStreamExtensions.ReadComplexMatrices(AI.DataStructs.InMemoryDataStream,AI.DataStructs.WithComplexElements.ComplexMatrix[]@)">
            <summary>
            Reads complex matrix array from the stream
            </summary>
            <param name="stream">Поток</param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:AI.Extensions.ShuffleExtensions">
            <summary>
            Расширение для алгоритма перемешивания данных
            </summary>
        </member>
        <member name="M:AI.Extensions.ShuffleExtensions.Shuffle``1(``0[],System.Nullable{System.Int32})">
            <summary>
            Перемешивание данных в массиве методом Кнута
            </summary>
            <param name="data">Массив</param>
            <param name="seed">Seed для ГПСЧ</param>
        </member>
        <member name="M:AI.Extensions.ShuffleExtensions.Shuffle``1(System.Collections.Generic.IList{``0},System.Nullable{System.Int32})">
            <summary>
            Перемешивание списка методом Кнута
            </summary>
            <param name="data">Список</param>
            <param name="seed">Seed для генератора псевдо-случайных чисел</param>
        </member>
        <member name="T:AI.Extensions.StatisticsExtensions">
            <summary>
            Расширение для статистик
            </summary>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Mean(System.Double[])">
            <summary>
            Среднее значение в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Mean(System.Single[])">
            <summary>
            Среднее значение в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Mean(System.Int32[])">
            <summary>
            Среднее значение в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Mean(System.Int16[])">
            <summary>
            Среднее значение в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Mean(System.Byte[])">
            <summary>
            Среднее значение в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Mean(System.Decimal[])">
            <summary>
            Среднее значение в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Mean(System.Int64[])">
            <summary>
            Среднее значение в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Disp(System.Double[])">
            <summary>
            Дисперсия (\sigma^2) в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Disp(System.Single[])">
            <summary>
            Дисперсия (\sigma^2) в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Disp(System.Int16[])">
            <summary>
            Дисперсия (\sigma^2) в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Disp(System.Int32[])">
            <summary>
            Дисперсия (\sigma^2) в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Disp(System.Decimal[])">
            <summary>
            Дисперсия (\sigma^2) в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Disp(System.Int64[])">
            <summary>
            Дисперсия (\sigma^2) в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Disp(System.Byte[])">
            <summary>
            Дисперсия (\sigma^2) в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Std(System.Double[])">
            <summary>
            Среднеквадратичное отклонение в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Std(System.Byte[])">
            <summary>
            Среднеквадратичное отклонение в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Std(System.Int16[])">
            <summary>
            Среднеквадратичное отклонение в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Std(System.Int32[])">
            <summary>
            Среднеквадратичное отклонение в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Std(System.Int64[])">
            <summary>
            Среднеквадратичное отклонение в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Std(System.Single[])">
            <summary>
            Среднеквадратичное отклонение в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StatisticsExtensions.Std(System.Decimal[])">
            <summary>
            Среднеквадратичное отклонение в массиве
            </summary>
            <param name="array">Массив</param>
            <returns></returns>
        </member>
        <member name="T:AI.Extensions.StringExtensions">
            <summary>
            Со строками
            </summary>
        </member>
        <member name="M:AI.Extensions.StringExtensions.ToSingleString``1(``0[],System.String)">
            <summary>
            Преобразовать массив в строку
            </summary>
            <typeparam name="T">Тип данных</typeparam>
            <param name="array">Массив</param>
            <param name="separator">Разделитель между элементами массива</param>
            <returns></returns>
        </member>
        <member name="M:AI.Extensions.StringExtensions.ToSingleString(System.Single[],System.Globalization.NumberFormatInfo,System.String)">
            <summary>
            Преобразовать массив в строку
            </summary>
        </member>
        <member name="M:AI.Extensions.StringExtensions.ToSingleString(System.Double[],System.Globalization.NumberFormatInfo,System.String)">
            <summary>
            Преобразовать массив в строку
            </summary>
        </member>
        <member name="M:AI.Extensions.StringExtensions.ToSingleString(System.Decimal[],System.Globalization.NumberFormatInfo,System.String)">
            <summary>
            Преобразовать массив в строку
            </summary>
        </member>
        <member name="M:AI.Extensions.StringExtensions.ToStringArray``1(``0[])">
            <summary>
            Преобразовать массив в масссив строк
            </summary>
        </member>
        <member name="M:AI.Extensions.StringExtensions.ToStringArray(System.Single[],System.Globalization.NumberFormatInfo)">
            <summary>
            Преобразовать массив в масссив строк
            </summary>
        </member>
        <member name="M:AI.Extensions.StringExtensions.ToStringArray(System.Double[],System.Globalization.NumberFormatInfo)">
            <summary>
            Преобразовать массив в масссив строк
            </summary>
        </member>
        <member name="M:AI.Extensions.StringExtensions.ToStringArray(System.Decimal[],System.Globalization.NumberFormatInfo)">
            <summary>
            Преобразовать массив в масссив строк
            </summary>
        </member>
        <member name="T:AI.Functions">
            <summary>
            Математические фукции
            </summary>
        </member>
        <member name="M:AI.Functions.WindowFunc(AI.DataStructs.Algebraic.Vector,System.Func{AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector},System.Int32)">
            <summary>
            Реализация оконных функций
            </summary>
            <param name="vect">входной вектор</param>
            <param name="Function">функция</param>
            <param name="window">окно</param>
            <returns>Результат применения ф-и</returns>
        </member>
        <member name="M:AI.Functions.WindowFuncDouble(AI.DataStructs.Algebraic.Vector,System.Func{AI.DataStructs.Algebraic.Vector,System.Double},System.Int32)">
            <summary>
            Реализация оконных функций
            </summary>
            <param name="vect">входной вектор</param>
            <param name="Function">функция</param>
            <param name="window">окно</param>
            <returns>Результат применения ф-и</returns>
        </member>
        <member name="M:AI.Functions.WindowFuncDouble(AI.DataStructs.Algebraic.Vector,System.Func{AI.DataStructs.Algebraic.Vector,System.Double},System.Int32,System.Int32)">
            <summary>
            Реализация оконных функций
            </summary>
            <param name="vect">входной вектор</param>
            <param name="Function">функция</param>
            <param name="window">окно</param>
            <param name="stride">Шаг</param>
            <returns>Результат применения ф-и</returns>
        </member>
        <member name="M:AI.Functions.NextPow2(System.Int32)">
            <summary>
            Следующая степень числа 2
            </summary>
            <param name="n">входное число</param>
            <returns></returns>
        </member>
        <member name="M:AI.Functions.Summ(System.Double[])">
            <summary>
            Суммирование всех элементов массива типа double
            </summary>
        </member>
        <member name="M:AI.Functions.Summ(System.Single[])">
            <summary>
            Суммирование всех элементов массива типа double
            </summary>
        </member>
        <member name="M:AI.Functions.Summ(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Поэлементная сумма
            </summary>
            <param name="vectors">Массив векторов</param>
            <returns>Результирующий вектор</returns>
        </member>
        <member name="M:AI.Functions.Summ(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Суммирование всех элементов действительного вектора
            </summary>
        </member>
        <member name="M:AI.Functions.Summ(System.Int32[])">
            <summary>
            Суммирование всех элементов массива типа int
            </summary>
        </member>
        <member name="M:AI.Functions.Summ(AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Суммирование всех элементов комплексного вектора
            </summary>
        </member>
        <member name="M:AI.Functions.IntegralInterp(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисляет интегральную функцию действительный вектор
            Входной вектор апроксиммирован полиномом 0-го порядка
            с коэфициентом 2
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.Functions.Integral(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисляет интегральную функцию действительный вектор
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.Functions.Integral(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Вычисляет интегральную функцию действительный вектор
            </summary>
            <param name="A">Входной вектор</param>
            <param name="fd">Частота дискретизации</param>
        </member>
        <member name="M:AI.Functions.Diff(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисляет диференциальную функцию действительный вектор
            </summary>
            <param name="A"> Входной вектор</param>
        </member>
        <member name="M:AI.Functions.Diff(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Вычисляет диференциальную функцию действительный вектор
            </summary>
            <param name="A"> Входной вектор</param>   
            <param name="fd"> Частота дискретизации</param>
        </member>
        <member name="M:AI.Functions.DiffWithOutF(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Вычисляет диференциальную функцию действительный вектор (без первого отсчета)
            </summary>
            <param name="A"> Входной вектор</param>
            <param name="fd"> Частота дискретизации</param>
        </member>
        <member name="M:AI.Functions.Diff(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Вычисляет i-ю производную по dx
            </summary>
            <param name="A">Входной вектор</param>
            <param name="i">Порядок производной 1, 2, 3 ....</param>
            <returns>Действительный вектор</returns>
        </member>
        <member name="M:AI.Functions.Multiplication(System.Double[])">
            <summary>
            Перемножение всех элементов массива типа double
            </summary>
        </member>
        <member name="M:AI.Functions.Multiplication(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Перемножение всех элементов действительного вектора
            </summary>
        </member>
        <member name="M:AI.Functions.MultiplicationFunction(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Перемножение всех элементов действительного вектора
            </summary>
        </member>
        <member name="M:AI.Functions.PowFunction(System.Double,System.Int32)">
            <summary>
            Возвращает набор степеней данного числа
            </summary>
            <param name="inp">Число</param>
            <param name="pow">максимальная степень</param>
        </member>
        <member name="M:AI.Functions.Multiplication(System.Int32[])">
            <summary>
            Перемножение всех элементов массива типа int
            </summary>
        </member>
        <member name="T:AI.Fuzzy.Conclusion">
            <summary>
            Заключение
            </summary>
        </member>
        <member name="P:AI.Fuzzy.Conclusion.W">
            <summary>
            Вес
            </summary>
        </member>
        <member name="T:AI.Fuzzy.ActivatedFuzzySet">
            <summary>
            Активированные множества
            </summary>
        </member>
        <member name="P:AI.Fuzzy.ActivatedFuzzySet.TruthDegree">
            <summary>
            Истинность
            </summary>
        </member>
        <member name="T:AI.Fuzzy.BaseVar">
            <summary>
            
            </summary>
        </member>
        <member name="P:AI.Fuzzy.BaseVar.Variable">
            <summary>
            Нечеткая переменная
            </summary>
        </member>
        <member name="P:AI.Fuzzy.BaseVar.Term">
            <summary>
            Нечеткое множество
            </summary>
        </member>
        <member name="T:AI.Fuzzy.FuzzyCondition">
            <summary>
            Нечеткое условие
            </summary>
        </member>
        <member name="T:AI.Fuzzy.FuzzyRuleClassic">
            <summary>
            Классическое нечеткое правило
            </summary>
        </member>
        <member name="P:AI.Fuzzy.FuzzyRuleClassic.FuzzyConditions">
            <summary>
            Нечеткие условия
            </summary>
        </member>
        <member name="P:AI.Fuzzy.FuzzyRuleClassic.Conclusions">
            <summary>
            Заключения
            </summary>
        </member>
        <member name="T:AI.Fuzzy.ClassicFuzzySet">
            <summary>
            Классическое нечеткое множество
            </summary>
        </member>
        <member name="P:AI.Fuzzy.ClassicFuzzySet.Fuzzyficator">
            <summary>
            Функция фаззификации
            </summary>
        </member>
        <member name="T:AI.Fuzzy.FuzzyVariable">
            <summary>
            Нечеткая переменная
            </summary>
        </member>
        <member name="F:AI.Fuzzy.FuzzyVariable.Terms">
            <summary>
            Нечеткие множества
            </summary>
        </member>
        <member name="T:AI.Fuzzy.FLV">
            <summary>
            Нечетка логическая переменная(FLV)
            </summary>
        </member>
        <member name="P:AI.Fuzzy.FLV.Flv">
            <summary>
            Нечеткая логическая переменная
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FLV.#ctor">
            <summary>
            Конструктор по умолчанию
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FLV.op_Implicit(System.Double)~AI.Fuzzy.FLV">
            <summary>
            Инициализация double
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FLV.op_Implicit(System.Single)~AI.Fuzzy.FLV">
            <summary>
            Инициализация float
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FLV.op_Implicit(System.Int32)~AI.Fuzzy.FLV">
            <summary>
            Инициализация int
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FLV.op_Implicit(AI.Fuzzy.FLV)~System.Double">
            <summary>
            Инициализация double
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FLV.#ctor(System.Double)">
            <summary>
            Конструктор
            </summary>
            <param name="flv">численное значение нечеткой переменной</param>
        </member>
        <member name="M:AI.Fuzzy.FLV.op_LogicalNot(AI.Fuzzy.FLV)">
            Не 
        </member>
        <member name="M:AI.Fuzzy.FLV.op_BitwiseAnd(AI.Fuzzy.FLV,AI.Fuzzy.FLV)">
            И
        </member>
        <member name="M:AI.Fuzzy.FLV.op_BitwiseOr(AI.Fuzzy.FLV,AI.Fuzzy.FLV)">
            <summary>
            Или
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FLV.KDImplication(AI.Fuzzy.FLV,AI.Fuzzy.FLV)">
            <summary>
            Импликация Клини
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FLV.GImplication(AI.Fuzzy.FLV,AI.Fuzzy.FLV)">
            <summary>
            Импликация Гогена
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FLV.MamdaniImplication(AI.Fuzzy.FLV,AI.Fuzzy.FLV)">
            <summary>
            Импликация Мамдани
            </summary>
        </member>
        <member name="T:AI.Fuzzy.FuzzyAnalogyInference">
            <summary>
            Нечеткий вывод по аналогии
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FuzzyAnalogyInference.GetImplicationMatrixG(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Матрица импликаций с применение импликации Гогена
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FuzzyAnalogyInference.GetImplicationMatrixG(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Vector},System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Vector})">
            <summary>
            Усредненная матрица импликаций с применение импликации Гогена
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FuzzyAnalogyInference.GetImplicationMatrix(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Matrix},AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Усредненная матрица импликаций, обучение с подкреплением
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FuzzyAnalogyInference.Inference(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Логический вывод
            </summary>
            <param name="matrix">Матрица импликаций</param>
            <param name="ifVector">Вектор условия</param>
        </member>
        <member name="T:AI.Fuzzy.Fuzzyficators.FVector.IFuzzyficatorVector">
            <summary>
            Интерфейс векторного фаззификатора
            </summary>
        </member>
        <member name="M:AI.Fuzzy.Fuzzyficators.FVector.IFuzzyficatorVector.Fuzzyfication(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Фаззификация
            </summary>
            <param name="value">Значение</param>
        </member>
        <member name="M:AI.Fuzzy.Fuzzyficators.FVector.IFuzzyficatorVector.DeFuzzyfication(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Дефаззификация
            </summary>
            <param name="valueF">Нечеткое значение</param>
        </member>
        <member name="T:AI.Fuzzy.Fuzzyficators.FVector.SigmoidVectorFuzzyficator">
            <summary>
            Векторный фаззификатор на базе сигмоиды
            </summary>
        </member>
        <member name="M:AI.Fuzzy.Fuzzyficators.FVector.SigmoidVectorFuzzyficator.#ctor(System.Double)">
            <summary>
            Векторный фаззификатор на базе сигмоиды
            </summary>
            <param name="beta">Наклон</param>
        </member>
        <member name="M:AI.Fuzzy.Fuzzyficators.FVector.SigmoidVectorFuzzyficator.DeFuzzyfication(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Дефаззификация
            </summary>
            <param name="valueF">Нечеткое значение</param>
        </member>
        <member name="M:AI.Fuzzy.Fuzzyficators.FVector.SigmoidVectorFuzzyficator.Fuzzyfication(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Фаззификация
            </summary>
            <param name="value">Значение</param>
        </member>
        <member name="T:AI.Fuzzy.Fuzzyficators.LingVarGaussian">
            <summary>
            Лингвистическая переменная
            </summary>
        </member>
        <member name="M:AI.Fuzzy.Fuzzyficators.LingVarGaussian.#ctor(System.Int32)">
            <summary>
            Лингвистическая переменная
            </summary>
        </member>
        <member name="M:AI.Fuzzy.Fuzzyficators.LingVarGaussian.AddVar(AI.DataStructs.Algebraic.Vector,System.String)">
            <summary>
            Добавить переменную
            </summary>
            <param name="features"></param>
            <param name="nameVar"></param>
        </member>
        <member name="M:AI.Fuzzy.Fuzzyficators.LingVarGaussian.Recognition(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Распознать
            </summary>
            <param name="features"></param>
        </member>
        <member name="M:AI.Fuzzy.Fuzzyficators.LingVarGaussian.FeaturesToFuzzySet(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Преобразование вектора в нечеткое множество
            </summary>
            <param name="features"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Fuzzy.Fuzzyficators.LingVarGaussian.FeaturesToFuzzySet(AI.DataStructs.Algebraic.Vector,System.Func{AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector},System.Double)">
            <summary>
            Преобразование вектора в нечеткое множество
            </summary>
        </member>
        <member name="T:AI.Fuzzy.FuzzySetTools">
            <summary>
            Инструменты для работы с нечеткими множествами
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FuzzySetTools.Merge``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.Dictionary{``0,System.Double}})">
            <summary>
            Объединение нечетких множеств
            </summary>
            <param name="sets"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Fuzzy.FuzzySetTools.Add``1(System.Collections.Generic.Dictionary{``0,System.Double},System.Collections.Generic.Dictionary{``0,System.Double})">
            <summary>
            Объединение 2х множеств
            </summary>
            <param name="set_1">Множество 1</param>
            <param name="set_2">Множество 2</param>
            <returns></returns>
        </member>
        <member name="M:AI.Fuzzy.FuzzySetTools.Array2FuzzySet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Преобразование списка в нечеткое множество
            </summary>
            <param name="set"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Fuzzy.FuzzySetTools.SetDiceSimModification(System.Collections.Generic.Dictionary{System.String,System.Double},System.Collections.Generic.Dictionary{System.String,System.Double})">
            <summary>
            Сходство на базе модифицированной метрики Дайса
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FuzzySetTools.SetDiceSimModificationAsymmetric(System.Collections.Generic.Dictionary{System.String,System.Double},System.Collections.Generic.Dictionary{System.String,System.Double})">
            <summary>
            Сходство на базе модифицированной метрики Дайса
            (функция асиммтрична, сравнивает только с ключами основного множества)
            </summary>
        </member>
        <member name="M:AI.Fuzzy.FuzzySetTools.DicObjIsDicT``1(System.Collections.Generic.Dictionary{System.Object,System.Double})">
            <summary>
            Все ли объекты множества являются типом T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="set"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Fuzzy.FuzzySetTools.SetConvert``1(System.Collections.Generic.Dictionary{System.Object,System.Double})">
            <summary>
            Конвертирует все объекты множества в тип T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="set"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Fuzzy.FuzzySetTools.SetConvertToObj``1(System.Collections.Generic.Dictionary{``0,System.Double})">
            <summary>
            Конвертирует все объекты множества в тип object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="set"></param>
            <returns></returns>
        </member>
        <member name="T:AI.HightLevelFunctions.ActivationFunctions">
            <summary>
            Функции активации нейронов
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Softmax(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Softmax
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Sigmoid(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Сигмоидальная однополярная активационная функция
            </summary>
            <param name="Inp">Входной вектор</param>
            <param name="betta">Угол наклона</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Sigmoid(System.Double,System.Double)">
            <summary>
            Сигмоидальная однополярная активационная функция
            </summary>
            <param name="x">Входное значение</param>
            <param name="betta">Угол наклона</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.InverseSigmoid(System.Double,System.Double)">
            <summary>
            Сигмоидальная однополярная активационная функция
            </summary>
            <param name="x">Входное значение</param>
            <param name="betta">Угол наклона</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.InverseSigmoid(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Сигмоидальная однополярная активационная функция
            </summary>
            <param name="x">Входное значение</param>
            <param name="betta">Угол наклона</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.SigmoidBiplyar(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Сигмоидальная биполярная активационная функция
            </summary>
            <param name="Inp">Входной вектор</param>
            <param name="betta">Угол наклона</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Threshold(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Пороговая активационная функция
            </summary>
            <param name="Inp">Входной вектор</param>
            <param name="threshold">Порог</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Threshold(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Ограничение сверху и снизу
            </summary>
            <param name="Inp">Входной вектор</param>
            <param name="thresholdUp"></param>
            <param name="thresholdDoun"></param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Relu(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Релу
            </summary>
            <param name="Inp"></param>
            <param name="threshold"></param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Relu(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Активация Релу
            </summary>
            <param name="Inp">Вход</param>
            <param name="thresholdUp">Верхний порог</param>
            <param name="thresholdDoun">Нижний порог</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Relu(AI.DataStructs.Algebraic.Matrix,System.Double,System.Double)">
            <summary>
            Активация Релу
            </summary>
            <param name="inp">Вход</param>
            <param name="thresholdUp">Верхний порог</param>
            <param name="thresholdDoun">Нижний порог</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Sigmoid(AI.DataStructs.Algebraic.Matrix,System.Double)">
            <summary>
            Сигмоида
            </summary>
            <param name="Inp"></param>
            <param name="betta"></param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.SigmoidBiplyar(AI.DataStructs.Algebraic.Matrix,System.Double)">
            <summary>
            Сигмоида
            </summary>
            <param name="Inp"></param>
            <param name="betta"></param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Threshold(AI.DataStructs.Algebraic.Matrix,System.Double)">
            <summary>
            Сигмоида
            </summary>
            <param name="inp"></param>
            <param name="threshold"></param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Sigmoid(AI.DataStructs.Algebraic.Tensor,System.Double)">
            <summary>
            Сигмоида
            </summary>
            <param name="tensor">Тензор входных данных</param>
            <param name="betta">Коэфициент наклона</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Log10(AI.DataStructs.Algebraic.Tensor)">
            <summary>
            Логарифм по основанию 10
            </summary>
            <param name="tensor">Тензор входных данных</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Relu(AI.DataStructs.Algebraic.Matrix,System.Double)">
            <summary>
            Активация Релу
            </summary>
            <param name="Inp">Вход</param>
            <param name="threshold">Нижний порог</param>
        </member>
        <member name="M:AI.HightLevelFunctions.ActivationFunctions.Relu(AI.DataStructs.Algebraic.Vector[],System.Double)">
            <summary>
            Активация Релу
            </summary>
            <param name="Inp">Вход</param>
            <param name="threshold">Нижний порог</param>
        </member>
        <member name="T:AI.HightLevelFunctions.AnalyticGeometryFunctions">
            <summary>
            Аналитическая геометрия
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.AnalyticGeometryFunctions.Cos(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Косинус между векторами
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.AnalyticGeometryFunctions.NormVect(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Расчет Евклидовой нормы
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.AnalyticGeometryFunctions.Dot(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Скалярное произведение векторов
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.AnalyticGeometryFunctions.ProectionAtoB(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Проекция вектора A на вектор B
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.AnalyticGeometryFunctions.AngleVect(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Угол между векторами
            </summary>
            <returns>Возвращает угол в радианах</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.AnalyticGeometryFunctions.VectorFromAToB(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисляет расстояния по компонентам от точки A до B
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.AnalyticGeometryFunctions.DistanceFromAToB(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Calculates the distance from point A to B
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.AnalyticGeometryFunctions.VectorRotate(AI.DataStructs.Algebraic.Vector,System.Double,System.Int32,System.Int32)">
            <summary>
            Повернуть вектор на заданные углы
            </summary>
        </member>
        <member name="T:AI.HightLevelFunctions.DistributionFunctions">
            <summary>
            Функции распределения случайной величины
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.DistributionFunctions.Gauss(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Функция распределения по нормальному закону 
            </summary>
            <param name="inp">Входной вектор</param>
            <param name="m">Мат. ожидание</param>
            <param name="std">Среднеквадратичное отклонение</param>
        </member>
        <member name="M:AI.HightLevelFunctions.DistributionFunctions.Gauss(AI.DataStructs.Algebraic.Matrix,System.Double,System.Double)">
            <summary>
            Функция Гаусса
            </summary>
            <param name="inp"></param>
            <param name="m"></param>
            <param name="std"></param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.DistributionFunctions.GaussRect(System.Int32,System.Int32,System.Double)">
            <summary>
            Фильтр гаусса
            </summary>
            <param name="h">Высота фильтра</param>
            <param name="w">Ширина</param>
            <param name="std">Среднеквадратичное отклонение</param>
            <returns>Фильтр Гаусса</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.DistributionFunctions.Gauss(System.Double,System.Double,System.Double)">
            <summary>
            Функция вероятность принадлежности
            </summary>
            <param name="Inp">Входное значение</param>
            <param name="m">Мат. ожидание</param>
            <param name="sko">Среднеквадратичное отклонение</param>
        </member>
        <member name="M:AI.HightLevelFunctions.DistributionFunctions.Gauss1(AI.DataStructs.Algebraic.Matrix,System.Double,System.Double)">
            <summary>
            Функция Гаусса при x=m -> G(x) = 1
            </summary>
            <param name="inp"></param>
            <param name="m"></param>
            <param name="sko"></param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.DistributionFunctions.GaussNorm1(System.Double,System.Double,System.Double)">
            <summary>
            Функция вероятность принадлежности при inp = m, out = 1
            </summary>
            <param name="Inp">Входное значение</param>
            <param name="m">Мат. ожидание</param>
            <param name="std">Среднеквадратичное отклонение</param>
        </member>
        <member name="M:AI.HightLevelFunctions.DistributionFunctions.GaussNorm1(AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Функция вероятность принадлежности при inp = m, out = 1
            </summary>
            <param name="Inp">Входной вектор</param>
            <param name="m">Мат. ожидание</param>
            <param name="std">Среднеквадратичное отклонение</param>
        </member>
        <member name="M:AI.HightLevelFunctions.DistributionFunctions.Puasson(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Функция распределения Пуасона 
            </summary>
            <param name="inp">Входной вектор</param>
            <param name="m">Мат. ожидание от 0 до +inf</param>
        </member>
        <member name="T:AI.HightLevelFunctions.FunctionsForEachElements">
            <summary>
            Математические функции для векторов и матриц
            </summary>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Unwrap(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Разворачивание арктангенса
            </summary>
            <param name="data">Данные с функции atan</param>
            <param name="diffMax">Максимальный разрыв</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Pow(System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Возведение числа в вектор степеней
            </summary>
            <param name="a">Число</param>
            <param name="pow">Вектор степеней</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.PeakDel(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Устранение выбросов на одном отсчете сигнала(пиков)
            </summary>
            <param name="data">Сигнал</param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.MinusOnePow(System.Int32)">
            <summary>
            Возведение -1 в степень
            </summary>
            <param name="pow">Степень</param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Rad(System.Double,System.Int32)">
            <summary>
            Функции Радемахера
            </summary>
            <param name="x">Параметр</param>
            <param name="num">Номер функции</param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Rad(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Функции Радемахера
            </summary>
            <param name="x">Вектор параметров</param>
            <param name="num">Номер функции</param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Walsh(System.Double,System.Int32)">
            <summary>
            Функции Уолша
            </summary>
            <param name="x">Параметр</param>
            <param name="num">Номер функции</param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Walsh(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Функции Радемахера
            </summary>
            <param name="x">Вектор параметров</param>
            <param name="num">Номер функции</param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Erf(System.Double)">
            <summary>
            Функция ошибки
            </summary>
            <param name="x">Аргумент</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Erf(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Функция ошибок
            </summary>
            <param name="Inp">Входной вектор</param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.GenerateTheSequence(System.Double,System.Double,System.Double)">
            <summary>
            Генерирование последовательности
            </summary>
            <param name="began">Начальное значение</param>
            <param name="step">Шаг</param>
            <param name="end">Конечное значение</param>
            <returns>Возвращает последовательность</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.GenerateTheSequence(System.Double,System.Double)">
            <summary>
            Генерирование последовательности
            </summary>
            <param name="began">Начальное значение</param>
            <param name="end">Конечное значение</param>
            <returns>Возвращает послеовательность с шагом 1</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.GradToRad(System.Double)">
            <summary>
            Перевод градусов в радианы
            </summary>
            <param name="grad">значение в градусах</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.GradToRad(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Перевод градусов в радианы
            </summary>
            <param name="Inp">значения в градусах</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.RadToGrad(System.Double)">
            <summary>
            Перевод радиан в градусы
            </summary>
            <param name="rad">значение в радианах</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.RadToGrad(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Перевод радиан в градусы
            </summary>
            <param name="Inp">значение в радианах</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Factorial(System.Int32)">
            <summary>
            Вычисление факториала числа
            </summary>
            <param name="x">Число</param>
            <returns>Факториал</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Factorial(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисление факториала векторов поэлементно
            </summary>
            <param name="Inp">Входной вектор</param>
            <returns>Факториал</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Sin(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисление синусов
            </summary>
            <param name="Inp">Вектор углов (в радианах)</param>
            <returns>Вектор синусов</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Round(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Окугление
            </summary>
            <param name="Inp">Вектор входных данных</param>
            <param name="digits">до какого знака</param>
            <returns>Вектор выхода</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Cos(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисление косинусов
            </summary>
            <param name="Inp">Вектор углов (в радианах)</param>
            <returns>Вектор косинусов</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Tan(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Calculating tangents
            </summary>
            <param name="Inp">Вектор углов (в радианах)</param>
            <returns>Вектор тангенсов</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.ctg(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисление котангенсов
            </summary>
            <param name="Inp">Вектор углов (в радианах)</param>
            <returns>Вектор котангенсов</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Asin(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисление арксинусов
            </summary>
            <param name="Inp">Вектор синусов</param>
            <returns>Вектор углов (в радианах)</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Acos(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисление арккосинусов
            </summary>
            <param name="Inp">Вектор косинусов</param>
            <returns>Вектор углов (в радианах)</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Atan(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Вычисление арктангенсов
            </summary>
            <param name="Inp">Вектор тангенсов</param>
            <returns>Вектор углов (в радианах)</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Log10(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Дсятичный логарифм
            </summary>
            <param name="Inp">Подлогарифмическое число</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Ln(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Логарифм по основанию "e"
            </summary>
            <param name="Inp">Подлогарифмическое число</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Sec(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Секанс угла
            </summary>
            <param name="Inp">углы</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Cosec(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Косеканс угла
            </summary>
            <param name="Inp">углы</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Exp(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Экспонента e^x
            </summary>
            <param name="Inp">показатели степени</param>
            <returns>e^Inp - поэлементно</returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Tanh(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Гиперболический тангенс
            </summary>
            <param name="Inp">углы</param>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Sign(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Определение знака
            </summary>
            <param name="Inp">Входной вектор</param>
            <returns></returns>
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Sqrt(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Квадратный корень
            </summary>
            <param name="Inp">числа</param>		
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Sin(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Вычисление синуса
            </summary>
            <param name="Inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Exp(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            e^x
            </summary>
            <param name="Inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Tanh(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Гиперболический тангенс
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Cos(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Косинус
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Tan(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Тангенс
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Ctan(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Котангенс
            </summary>
            <param name="Inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Asin(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Арксинус
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Acos(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Арккосинус
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Atan(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Арктангенс
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Abs(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Модуль
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Sqrt(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Квадратный корень
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Log10(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Десятичный логарифм
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Ln(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Логарифм по основанию E
            </summary>
            <param name="inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Sec(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Секонс
            </summary>
            <param name="Inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Cosec(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Косеконс
            </summary>
            <param name="Inp">Матрица значений для преобразования</param>	
        </member>
        <member name="M:AI.HightLevelFunctions.FunctionsForEachElements.Abs(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Модуль
            </summary>
            <param name="Inp">Комплексный вектор значений для преобразования</param>
        </member>
        <member name="T:AI.IntervalData">
            <summary>
            Данные интервалов
            </summary>
        </member>
        <member name="M:AI.IntervalData.#ctor">
            <summary>
            Данные интервалов
            </summary>
        </member>
        <member name="M:AI.IntervalData.Add(System.Int32,System.Int32)">
            <summary>
            Добавление интервала
            </summary>
            <param name="bI">Начало</param>
            <param name="eI">Конец</param>
        </member>
        <member name="M:AI.IntervalData.GetVects(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Нарезка вектора по интервалам
            </summary>
            <param name="inputVector">Вектор входных данных</param>
        </member>
        <member name="M:AI.IntervalData.GetVect(System.Func{AI.DataStructs.Algebraic.Vector,System.Double},AI.DataStructs.Algebraic.Vector)">
            <summary>
            Нарезка вектора по интервалам + преобразование
            </summary>
            <param name="vect2doub">Функция для преобразования вектора в число</param>
            <param name="input">Вектор входных данных</param>
        </member>
        <member name="T:AI.MathUtils.Algebra.Gauss">
            <summary>
            Метод Гаусса с выч. сложностью O(n^3)
            </summary>
        </member>
        <member name="M:AI.MathUtils.Algebra.Gauss.SolvingEquations(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Решение СЛАУ методом Гаусса
            </summary>
            <param name="A">Матрица коэффициентов</param>
            <param name="B">Вектор свободных членов</param>
        </member>
        <member name="T:AI.MathUtils.Algebra.Kramer">
            <summary>
            Метод Крамера
            </summary>
        </member>
        <member name="M:AI.MathUtils.Algebra.Kramer.SolvingEquations(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Решение СЛАУ методом Крамера
            </summary>
            <param name="A">Матрица коэффициентов</param>
            <param name="B">Вектор свободных членов</param>
        </member>
        <member name="T:AI.MathUtils.Combinatorics.CombinatoricsBaseFunction">
            <summary>
            Базовые функции коммбинарики
            </summary>
        </member>
        <member name="M:AI.MathUtils.Combinatorics.CombinatoricsBaseFunction.PlacingWithoutRepetition(System.Int32,System.Int32)">
            <summary>
            Размещение без повторов
            </summary>
            <param name="k">Количество элементов</param>
            <param name="n">Количество возможных позиций</param>
        </member>
        <member name="M:AI.MathUtils.Combinatorics.CombinatoricsBaseFunction.NumberOfCombinations(System.Int32,System.Int32)">
            <summary>
            Количество комбинаций
            </summary>
            <param name="k">Количество элементов</param>
            <param name="n">Количество возможных позиций</param>
        </member>
        <member name="M:AI.MathUtils.ODE.CubicSplineInterpolator.#ctor(System.Double[],System.Double[])">
            <summary>
            Initializes a new instance of the <see cref="T:AI.MathUtils.ODE.CubicSplineInterpolator"/> class.
            </summary>
            <param name="xValues">The x-coordinates of the data points.</param>
            <param name="yValues">The y-coordinates of the data points.</param>
            <exception cref="T:System.ArgumentException">Thrown when xValues and yValues have different lengths or there are not enough data points.</exception>
        </member>
        <member name="M:AI.MathUtils.ODE.CubicSplineInterpolator.ComputeSplineCoefficients">
            <summary>
            Computes spline coefficients using the tridiagonal system.
            </summary>
        </member>
        <member name="M:AI.MathUtils.ODE.CubicSplineInterpolator.Interpolate(System.Double)">
            <summary>
            Interpolates the value at a given x-coordinate using the cubic spline.
            </summary>
            <param name="x">The x-coordinate to interpolate at.</param>
            <returns>The interpolated value.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the x-coordinate to interpolate is outside the domain of the x-values.</exception>
        </member>
        <member name="T:AI.MathUtils.ODE.RungeKutta">
            <summary>
            Solves an ordinary differential equation using the 4th order Runge-Kutta method.
            </summary>
        </member>
        <member name="M:AI.MathUtils.ODE.RungeKutta.RungeKutta4(System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            Solves an ordinary differential equation using the 4th order Runge-Kutta method.
            </summary>
            <param name="function">The function representing the right-hand side of the differential equation dy/dx = f(x, y).</param>
            <param name="initialX">The initial value of x.</param>
            <param name="initialY">The initial value of y.</param>
            <param name="finalX">The final value of x for which y is required.</param>
            <param name="stepSize">The step size for the iteration.</param>
            <returns>The approximate value of y at finalX.</returns>
        </member>
        <member name="M:AI.MathUtils.ODE.RungeKutta.RungeRombergRK4(System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Estimates the error of the Runge-Kutta 4 method using the Runge-Romberg rule.
            </summary>
            <param name="function">The function representing the right-hand side of the differential equation dy/dx = f(x, y).</param>
            <param name="initialX">The initial value of x.</param>
            <param name="initialY">The initial value of y.</param>
            <param name="finalX">The final value of x for which y is required.</param>
            <param name="stepSize">The step size for the iteration.</param>
            <returns>A tuple containing the corrected value of y and the estimated error.</returns>
        </member>
        <member name="T:AI.MathUtils.SpecialFunction.EllipticIntegral">
            <summary>
            Эллиптические интегралы
            </summary>
        </member>
        <member name="M:AI.MathUtils.SpecialFunction.EllipticIntegral.CompleteEllipticIntegral_I(System.Double)">
            <summary>
            Полный эллиптический интеграл первого рода
            </summary>
            <param name="k">Значение</param>
        </member>
        <member name="M:AI.MathUtils.SpecialFunction.EllipticIntegral.CompleteComplementarEllipticIntegral_I(System.Double)">
            <summary>
            Полный комплементарный эллиптический интеграл первого рода
            </summary>
            <param name="k">Значение</param>
        </member>
        <member name="T:AI.ML.AlgorithmAnalysis.CorrelationAnalysis">
            <summary>
            Корреляционный анализ, проверка ортогональности
            </summary>
        </member>
        <member name="P:AI.ML.AlgorithmAnalysis.CorrelationAnalysis.CorMatrNorm">
            <summary>
            Проверка нормализованной ортогональной матрицы
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.CorrelationAnalysis.#ctor(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Корреляционный анализ, проверка ортогональности
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.CorrelationAnalysis.MeanOrtog">
            <summary>
            Средний коэффициент ортогональности
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.CorrelationAnalysis.CorMatrDeterm">
            <summary>
            Определитель корреляционной матрицы (один из показателей мультиколлинеарности)
            </summary>
        </member>
        <member name="T:AI.ML.AlgorithmAnalysis.ImageSimilarityMetrics">
            <summary>
            Метрики схожести изображений
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.ImageSimilarityMetrics.DiceApproximate(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Приблизительный алгоритм вычисления значения метрики Дайса (метрика симметричная) 
            </summary>
            <param name="alg_str_1">Алгебраическая структура 1</param>
            <param name="alg_str_2">Алгебраическая структура 2</param>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.ImageSimilarityMetrics.Dice(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},System.Double)">
            <summary>
            Значение метрики Дайса (метрика симметричная) 
            </summary>
            <param name="alg_str_1">Алгебраическая структура 1</param>
            <param name="alg_str_2">Алгебраическая структура 2</param>
            <param name="trashold">Порог</param>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.ImageSimilarityMetrics.SSIM(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Структурное сходство 2х изображений, метрика SSIM
            </summary>
            <param name="img1"></param>
            <param name="img2"></param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.AlgorithmAnalysis.MetricsForClassification">
            <summary>
            Метрики качества классфикатора
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.Accuracy(System.Int32[],System.Int32[])">
            <summary>
            Accuracy
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.PrecisionForEachClass(System.Int32[],System.Int32[])">
            <summary>
            Точность алгоритма для каждого класса
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.AveragePrecision(System.Int32[],System.Int32[])">
            <summary>
            Средня точность алгоритма
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.ConfusionMatrix(System.Int32[],System.Int32[])">
            <summary>
            Матрица ошибок (перепутывания)
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.Recall(System.Int32[],System.Int32[])">
            <summary>
            полнота
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.RecallForEachClass(System.Int32[],System.Int32[])">
            <summary>
            Полнота для каждого класса
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.AverageRecall(System.Int32[],System.Int32[])">
            <summary>
            Средняя полнота
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.FMeasure(System.Int32[],System.Int32[])">
            <summary>
            F-1 мера, формула: 2 * recall * precision / (recall + precision)
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.FMeasure(System.Int32[],System.Int32[],System.Double)">
            <summary>
            F мера, формула: (1+beta^2) * recall * precision / (recall + beta^2 * precision)
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForClassification.FullReport(System.Int32[],System.Int32[],System.Double,System.Boolean)">
            <summary>
            Составляет отчет по всем метрикам
            </summary>
        </member>
        <member name="T:AI.ML.AlgorithmAnalysis.MetricsForRegression">
            <summary>
            Метрики оценки регрессионных моделей
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.AvMetric(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}},System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}},System.Func{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},System.Double})">
            <summary>
            Усредненная метрика
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.MAE(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Cредняя абсолютная ошибка
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.MAEPercent(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Cредняя абсолютная ошибка (В процентах)
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.MAPE(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Средняя абсолютная процентная ошибка
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.MSE(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Средний квадрат ошибки
            </summary>
            <param name="target"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.RMSE(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Корень из среднего квадрата ошибки
            </summary>
            <param name="target"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.RMSLE(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            RMLE (target[i]>-1, output[i]>-1 for all i \in [0; N-1])
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.RMSEPercent(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Корень из среднего квадрата ошибки в процентах
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.R2(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Корреляция Пирсона в квадрате
            </summary>
            <param name="target"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.Bias(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Среднее смещение относительно 0
            </summary>
            <param name="target"></param>
            <param name="output"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.MAE(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}},System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}})">
            <summary>
            Cредняя абсолютная ошибка
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.MAEPercent(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}},System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}})">
            <summary>
            Cредняя абсолютная ошибка (В процентах)
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.MAPE(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}},System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}})">
            <summary>
            Средняя абсолютная процентная ошибка
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.MSE(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}},System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}})">
            <summary>
            Средний квадрат ошибки
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.RMSE(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}},System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}})">
            <summary>
            Корень из среднего квадрата ошибки
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.RMSEPercent(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}},System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}})">
            <summary>
            Корень из среднего квадрата ошибки в процентах
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.R2(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}},System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}})">
            <summary>
            Корреляция Пирсона в квадрате
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.MetricsForRegression.Bias(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}},System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}})">
            <summary>
            Среднее смещение относительно 0
            </summary>
        </member>
        <member name="T:AI.ML.AlgorithmAnalysis.SimilarityOfBases">
            <summary>
            Проверка схожести двух базисов
            </summary>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.SimilarityOfBases.#ctor(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Проверка схожести двух базисов
            </summary>
            <param name="bas1">Базис №1</param>
            <param name="bas2">Базис №2</param>
        </member>
        <member name="M:AI.ML.AlgorithmAnalysis.SimilarityOfBases.ProbRandBasis">
            <summary>
            Вероятность что базисы не связаны (случайны)
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.Classifiers.BaseClassifier`1">
            <summary>
            Базовый классификатор
            </summary>
            <typeparam name="T">Тип классификатора</typeparam>
        </member>
        <member name="M:AI.ML.Classifiers.BaseClassifier`1.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Классификация
            </summary>
            <param name="inp">Вход</param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:AI.ML.Classifiers.BaseClassifier`1.ClassifyProbVector(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Классификация (вероятности)
            </summary>
            <param name="inp">Вход</param>
        </member>
        <member name="M:AI.ML.Classifiers.BaseClassifier`1.Train(AI.DataStructs.Algebraic.Vector[],System.Int32[])">
            <summary>
            Обучить
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.BaseClassifier`1.Train(AI.ML.DataSets.VectorIntDataset)">
            <summary>
            Обучить
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.BaseClassifier`1.Save(System.String)">
            <summary>
            Сохранить
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Classifiers.BaseClassifier`1.Save(System.IO.Stream)">
            <summary>
            Сохранить
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.ML.Classifiers.BaseClassifier`1.Load(System.String)">
            <summary>
            Загрузить
            </summary>
            <param name="path">Путь</param>
        </member>
        <member name="M:AI.ML.Classifiers.BaseClassifier`1.Load(System.IO.Stream)">
            <summary>
            Загрузить 
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="T:AI.ML.Classifiers.BayesianClassifier">
            <summary>
            Классификатор основанный на теореме Байеса
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.BayesianClassifier.#ctor(System.Int32,System.Int32)">
            <summary>
            Классификатор основанный на теореме Байеса
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.BayesianClassifier.#ctor">
            <summary>
            Классификатор основанный на теореме Байеса
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.BayesianClassifier.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Классификация
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.BayesianClassifier.ClassifyProbVector(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Классификация
            </summary>
            <param name="inp"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Classifiers.BayesianClassifier.Save(System.String)">
            <summary>
            Не реализовано
            </summary>
            <param name="path">Путь до файла</param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:AI.ML.Classifiers.BayesianClassifier.Save(System.IO.Stream)">
            <summary>
            Не реализовано
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.BayesianClassifier.Train(AI.DataStructs.Algebraic.Vector[],System.Int32[])">
            <summary>
            Обучение байесовского классификатора
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.BayesianClassifier.Train(AI.ML.DataSets.VectorIntDataset)">
            <summary>
            Обучение байесовского классификатора
            </summary>
            <param name="dataset"></param>
        </member>
        <member name="T:AI.ML.Classifiers.CorrelationClassifier">
            <summary>
            Корреляционный классификатор
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.CorrelationClassifier.Classes">
            <summary>
            Классы
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.#ctor">
            <summary>
            Корреляционный классификатор
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.#ctor(System.String)">
            <summary>
            Корреляционный классификатор
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.#ctor(AI.ML.Classifiers.StructClasses)">
            <summary>
            Корреляционный классификатор
            </summary>
            <param name="classifikator">Классы</param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.AddClass(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Добавить класс
            </summary>
            <param name="features">Вектор признаков</param>
            <param name="num">Метка</param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Распознавание вектора
            </summary>
            <param name="inp">Вход</param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.ClassifyProbVector(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Распознавание вектора, представить вектором распределения вероятностей
            </summary>
            <param name="inp">Вектор входа</param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.Train(AI.DataStructs.Algebraic.Vector[],System.Int32[])">
            <summary>
            Обучение классификатора
            </summary>
            <param name="features">Признаки</param>
            <param name="classes">Метки классов</param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.Train(AI.ML.DataSets.VectorIntDataset)">
            <summary>
            Обучение классификатора
            </summary>
            <param name="dataset">Набор данных признаки-метка</param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.Save(System.String)">
            <summary>
            Сохранить в файл
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.Save(System.IO.Stream)">
            <summary>
            Сохранить в поток
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.Load(System.String)">
            <summary>
            Загрузить из файла
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Classifiers.CorrelationClassifier.Load(System.IO.Stream)">
            <summary>
            Загрузить из потока
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.Classifiers.FuzzyClassifier">
            <summary>
            Нечеткий классификатор
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.FuzzyClassifier.FuzzyficatorVectorInp">
            <summary>
            Фаззификатор входов
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.FuzzyClassifier.FuzzyficatorVectorOutp">
            <summary>
            Фаззификатор выходов
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.FuzzyClassifier.ImplMatrix">
            <summary>
            Матрица импликаций
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.FuzzyClassifier.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Распознать вектор
            </summary>
            <param name="inp">Вход</param>
            <returns>Метка класса</returns>
        </member>
        <member name="M:AI.ML.Classifiers.FuzzyClassifier.ClassifyProbVector(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Распознать вектор
            </summary>
            <param name="inp">Вход</param>
            <returns>Вектор принадлежностей</returns>
        </member>
        <member name="M:AI.ML.Classifiers.FuzzyClassifier.Train(AI.DataStructs.Algebraic.Vector[],System.Int32[])">
            <summary>
            Обучить
            </summary>
        </member>
        <member name="T:AI.ML.Classifiers.IClassifier">
            <summary>
            Интерфейс для работы классификаторов
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.IClassifier.Train(AI.DataStructs.Algebraic.Vector[],System.Int32[])">
            <summary>
            Обучение классификатора
            </summary>
            <param name="features">Признаки</param>
            <param name="classes">Классы</param>
        </member>
        <member name="M:AI.ML.Classifiers.IClassifier.Train(AI.ML.DataSets.VectorIntDataset)">
            <summary>
            Обучение классификатора
            </summary>
            <param name="dataset">Набор данных</param>
        </member>
        <member name="M:AI.ML.Classifiers.IClassifier.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Распознавание
            </summary>
            <param name="inp">Вектор который надо распознать</param>
        </member>
        <member name="M:AI.ML.Classifiers.IClassifier.ClassifyProbVector(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Распознавание
            </summary>
            <param name="inp">Вектор который надо распознать</param>
        </member>
        <member name="T:AI.ML.Classifiers.KNNCl">
            <summary>
            Метод k-ближайших соседей
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.KNNCl.K">
            <summary>
            Число соседей
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.KNNCl.H">
            <summary>
            Ширина окна
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.KNNCl.IsFixed">
            <summary>
            Фиксирована ли ширина окна
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.KNNCl.IsParsenMethod">
            <summary>
            Использовать ли метод Парзена
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.KNNCl.KernelParsenWindow">
            <summary>
            Ядро окна Парзена
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.KNNCl.Dist">
            <summary>
            Функция измерения расстояния
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.KNNCl.Classes">
            <summary>
            Набор данных
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.#ctor">
            <summary>
            Метод k-ближайших соседей
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.#ctor(AI.ML.DataSets.VectorIntDataset)">
            <summary>
            Метод k-ближайших соседей
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.RbfK(System.Double)">
            <summary>
            Радиально-базисная функция окна
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.#ctor(AI.ML.Classifiers.StructClasses)">
            <summary>
            Метод k-ближайших соседей
            </summary>
            <param name="classifikator">Коллекция классов</param>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Распознавание
            </summary>
            <param name="inp">Вектор входа</param>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.AddClass(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Добавить класс
            </summary>
            <param name="features">Вектор признаков</param>
            <param name="num">Метка </param>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.ClassifyProbVector(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Распознавание вектора, представить вектором распределения вероятностей
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.RecognizeVectorMax(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Возвращает вектор, его длина равна количеству классов, на позиции распознанного класса установлено значение 1
            </summary>
            <param name="inp">Вектор входных данных</param>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.Train(AI.DataStructs.Algebraic.Vector[],System.Int32[])">
            <summary>
            Обучение классификатора
            </summary>
            <param name="features">Признаки</param>
            <param name="classes">Метки классов</param>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.Train(AI.ML.DataSets.VectorIntDataset)">
            <summary>
            Обучение на базе набора данных вектор-класс
            </summary>
            <param name="dataset">Набор данных Vector-int32</param>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.Save(System.String)">
            <summary>
            Сохранить в файл
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.Save(System.IO.Stream)">
            <summary>
            Сохранить в поток
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.Load(System.String)">
            <summary>
            Загрузить из файла
            </summary>
            <param name="path">Путь до файла</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.Load(System.IO.Stream)">
            <summary>
            Загрузить из потока
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.GetKNN(System.String)">
            <summary>
            Загрузить из csv (признаки; метка класса)
            </summary>
            <param name="pathToEtallonClassCsv">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Classifiers.KNNCl.ToVector(System.Int32)">
            <summary>
            Transform to vector
            </summary>
            <param name="i">Индекс</param>
        </member>
        <member name="T:AI.ML.Classifiers.LinearClassifierBinarry">
            <summary>
            Линейный 2х классовый классификатор
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.LinearClassifierBinarry.LearningRate">
            <summary>
            Скорость обучения
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.LinearClassifierBinarry.EpochesToPass">
            <summary>
            Число эпох
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.LinearClassifierBinarry.L1">
            <summary>
            L1 регуляризация
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.LinearClassifierBinarry.L2">
            <summary>
            L2 регуляризация
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.LinearClassifierBinarry.MinimalMargin">
            <summary>
            Минимальный отступ
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.LinearClassifierBinarry.C">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.LinearClassifierBinarry.#ctor(System.Int32)">
            <summary>
            Линейный 2х классовый классификатор
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.LinearClassifierBinarry.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Классификация объектов
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.LinearClassifierBinarry.ClassifyProbVector(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Классификация объектов (вектор вероятностей)
            </summary>
            <param name="inp"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Classifiers.LinearClassifierBinarry.Train(AI.DataStructs.Algebraic.Vector[],System.Int32[])">
            <summary>
            Обучение
            </summary>
            <param name="features"></param>
            <param name="classes"></param>
        </member>
        <member name="T:AI.ML.Classifiers.NeuralClassifier">
            <summary>
            Классификатор на базе нейронной сети
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.NeuralClassifier.Graph">
            <summary>
            Граф автоматического дифференцирования
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.NeuralClassifier.LearningRate">
            <summary>
            Скорость обучения
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.NeuralClassifier.EpochesToPass">
            <summary>
            Число эпох
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.NeuralClassifier.Optimizer">
            <summary>
            Оптимизатор
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.NeuralClassifier.ValSplit">
            <summary>
            Доля валидационной выборки
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.NeuralClassifier.Loss">
            <summary>
            Метод измерения ошибки
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.NeuralClassifier.#ctor(AI.ML.NeuralNetwork.CoreNNW.NNW)">
            <summary>
            Классификатор на базе нейронной сети
            </summary>
            <param name="net">Нейронная сеть</param>
        </member>
        <member name="M:AI.ML.Classifiers.NeuralClassifier.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Распознать
            </summary>
            <param name="inp">Вектор входа</param>
        </member>
        <member name="M:AI.ML.Classifiers.NeuralClassifier.ClassifyProbVector(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Распознать
            </summary>
            <param name="inp">Вектор входа</param>
        </member>
        <member name="M:AI.ML.Classifiers.NeuralClassifier.Train(AI.DataStructs.Algebraic.Vector[],System.Int32[])">
            <summary>
            Обучение нейронной сети
            </summary>
            <param name="features"></param>
            <param name="classes"></param>
        </member>
        <member name="T:AI.ML.Classifiers.NN">
            <summary>
            Классификатор, работающий по принципу метода эталонов
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.NN.Classes">
            <summary>
            Классы
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.NN.#ctor">
            <summary>
             Классификатор, работающий по принципу метода эталонов
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.NN.#ctor(System.String)">
            <summary>
             Классификатор, работающий по принципу метода эталонов
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.#ctor(AI.ML.Classifiers.StructClasses)">
            <summary>
             Классификатор, работающий по принципу метода эталонов
            </summary>
            <param name="classifikator">Классы</param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.AddClass(AI.DataStructs.Algebraic.Vector[],System.Int32)">
            <summary>
            Добавить эталон в классификатор
            </summary>
            <param name="tDataset">Набор данных</param>
            <param name="numClass">Индекс класса</param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Распознавание вектора
            </summary>
            <param name="inp">Вход</param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.AddClass(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Добавить класс
            </summary>
            <param name="features">Вектор признаков</param>
            <param name="num">Метка </param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.ClassifyProbVector(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Возвращает вектор, длина которого равна количеству классов, значение по индексу искомого класса устанавливается равным единице, а по остальным индексам равно нулю.
            </summary>
            <param name="inp">Вектор входных данных</param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.Train(AI.DataStructs.Algebraic.Vector[],System.Int32[])">
            <summary>
            Обучение классификатора
            </summary>
            <param name="features">Признаки</param>
            <param name="classes">Метки классов</param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.Train(AI.ML.DataSets.VectorIntDataset)">
            <summary>
            Обучение классификатора
            </summary>
            <param name="dataset">Набор данных признаки-метка</param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.TrainGroup(AI.ML.DataSets.VectorIntDataset)">
            <summary>
            Обучение классификатора (группировка данных)
            </summary>
            <param name="dataset">Набор данных признаки-метка</param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.Save(System.String)">
            <summary>
            Сохранить в файл
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.Save(System.IO.Stream)">
            <summary>
            Сохранить в поток
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.ML.Classifiers.NN.Load(System.String)">
            <summary>
            Загрузить из файла
            </summary>
            <param name="path">Путь до файла</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Classifiers.NN.Load(System.IO.Stream)">
            <summary>
            Загрузить из потока
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.Classifiers.StructClasses">
            <summary>
            Структура классификатора
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.StructClasses.Save(System.String)">
            <summary>
            Сохранить в файл
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Classifiers.StructClasses.Save(System.IO.Stream)">
            <summary>
            Сохранить в поток
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.ML.Classifiers.StructClasses.Load(System.String)">
            <summary>
            Загрузить из файла
            </summary>
            <param name="path">Путь до файла</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Classifiers.StructClasses.Load(System.IO.Stream)">
            <summary>
            Загрузить из потока
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.Classifiers.SVMBinary">
            <summary>
            Машина опорных векторов (для 2 классов)
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.SVMBinary.LearningRate">
            <summary>
            Скорость обучения
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.SVMBinary.EpochesToPass">
            <summary>
            Число эпох
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.SVMBinary.L1">
            <summary>
            Регуляризация L1
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.SVMBinary.L2">
            <summary>
            Регуляризация L2
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.SVMBinary.MinimalMargin">
            <summary>
            Минимальный отступ
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.SVMBinary.C">
            <summary>
            
            </summary>
        </member>
        <member name="P:AI.ML.Classifiers.SVMBinary.NumSupportVectors">
            <summary>
            Число опорных векторов
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.SVMBinary.#ctor(System.Int32)">
            <summary>
            Машина опорных векторов (для 2 классов)
            </summary>
        </member>
        <member name="M:AI.ML.Classifiers.SVMBinary.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Классификация
            </summary>
            <param name="inp"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Classifiers.SVMBinary.ClassifyProbVector(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Классификация (вектор вероятностей)
            </summary>
            <param name="inp"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Classifiers.SVMBinary.Train(AI.DataStructs.Algebraic.Vector[],System.Int32[])">
            <summary>
            Обучение
            </summary>
            <param name="features"></param>
            <param name="classes"></param>
        </member>
        <member name="T:AI.ML.Clustering.Cluster">
            <summary>
            Структура кластера
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.Cluster.Dataset">
            <summary>
            Набор данных
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.Cluster.Centr">
            <summary>
            Центр кластера
            </summary>
        </member>
        <member name="T:AI.ML.Clustering.Forel">
            <summary>
            Кластеризация методом FOREL
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.Forel.Clusters">
            <summary>
            Массив кластеров
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.Forel.DistanceFunction">
            <summary>
            Функция измерения расстояния
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.Forel.#ctor">
            <summary>
            Кластеризация методом FOREL
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.Forel.Train(AI.DataStructs.Algebraic.Vector[],System.Int32)">
            <summary>
            Обучение кластеризации
            </summary>
            <param name="dataset">Векторы</param>
            <param name="minR">Minimum cluster radius</param>
        </member>
        <member name="M:AI.ML.Clustering.Forel.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Распознать вектор
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.Forel.Classify(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Vector})">
            <summary>Классификация векторов</summary>
            <param name="vectors">Векторы</param>
        </member>
        <member name="M:AI.ML.Clustering.Forel.GetHypersphere(System.Double,AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Проводит гиперсферу нужного радиуса из конкретной точки и на заданном множестве
            </summary>
            <param name="R">Радиус</param>
            <param name="m">Центр масс</param>
            <param name="pointsSet">Множество точек</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Clustering.Forel.Max(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Максимальная дистанция
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Clustering.Forel.AWithOutB(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Множество А\В
            </summary>
            <param name="A">Множество А</param>
            <param name="B">Множество В</param>
            <returns>А\B</returns>
        </member>
        <member name="T:AI.ML.Clustering.IClustering">
            <summary>
            Интерфейс для метрического алгоритма кластеризации
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.IClustering.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Распознать вектор
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.IClustering.Classify(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Vector})">
            <summary>
            Распознать векторs
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.IClustering.Train(AI.DataStructs.Algebraic.Vector[],System.Int32)">
            <summary>
            Обучение кластеризации
            </summary>
            <param name="dataset">Векторы</param>
            <param name="param">Свободный параметр</param>
        </member>
        <member name="P:AI.ML.Clustering.IClustering.DistanceFunction">
            <summary>
            Функция измерения расстояния
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.IClustering.Clusters">
            <summary>
            Массив кластеров
            </summary>
        </member>
        <member name="T:AI.ML.Clustering.KMeans">
            <summary>Алгоритм k-means</summary>
        </member>
        <member name="P:AI.ML.Clustering.KMeans.Centroids">
            <summary>
            Центроиды
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.KMeans.MaxCount">
            <summary>
            Максимальное число циклов
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.KMeans.#ctor(System.Int32)">
            <summary>K-Mean</summary>
            <param name="clasterCount">Количество кластеров</param>
        </member>
        <member name="P:AI.ML.Clustering.KMeans.GroupCount">
            <summary>Количество кластеров</summary>
        </member>
        <member name="P:AI.ML.Clustering.KMeans.DimentionOfData">
            <summary>Размерность данных</summary>
        </member>
        <member name="P:AI.ML.Clustering.KMeans.Сentroids">
            <summary>Цендроиды кластеров</summary>
        </member>
        <member name="P:AI.ML.Clustering.KMeans.DistanceFunction">
            <summary>
            Функция измерения расстояния
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.KMeans.Clusters">
            <summary>
            Массив кластеров
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.KMeans.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>Классификация вектора</summary>
            <param name="vector">Вектор</param>
        </member>
        <member name="M:AI.ML.Clustering.KMeans.Classify(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Vector})">
            <summary>Классификация векторов</summary>
            <param name="vectors">Векторы</param>
        </member>
        <member name="M:AI.ML.Clustering.KMeans.Train(AI.DataStructs.Algebraic.Vector[],System.Int32)">
            <summary>
            Обучение кластеризации
            </summary>
            <param name="dataset">Векторы</param>
            <param name="seed">Seed</param>
        </member>
        <member name="M:AI.ML.Clustering.KMeans.OnlineTuning(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Доучивание
            </summary>
            <param name="vect">Вектор</param>
            <param name="lr">Скорость обучения</param>
        </member>
        <member name="M:AI.ML.Clustering.KMeans.Initialize">
            <summary>Инизиализация</summary>
        </member>
        <member name="M:AI.ML.Clustering.KMeans.NearestVector(AI.DataStructs.Algebraic.Vector)">
            <summary>Ближайший вектор</summary>
        </member>
        <member name="M:AI.ML.Clustering.KMeans.ValidateData(System.Int32,AI.DataStructs.Algebraic.Vector[])">
            <summary>Validate the sample</summary>
        </member>
        <member name="T:AI.ML.Clustering.KohonenNet">
            <summary>
            Самоорганизующиеся карты Кохонена
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.KohonenNet.DistanceFunction">
            <summary>
            Функция расстояния
            </summary>
        </member>
        <member name="F:AI.ML.Clustering.KohonenNet.w">
            <summary>
            Веса сети
            </summary>
        </member>
        <member name="F:AI.ML.Clustering.KohonenNet.bias">
            <summary>
            Веса смещения
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.KohonenNet.Steps">
            <summary>
            Neural network setup steps
            </summary>
        </member>
        <member name="P:AI.ML.Clustering.KohonenNet.Clusters">
            <summary>
            Массив кластеров
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.KohonenNet.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Самоорганизующиеся карты Кохонена
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.KohonenNet.Classify(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Классификация
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Clustering.KohonenNet.Classify(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Vector})">
            <summary>
            Массива векторов
            </summary>
        </member>
        <member name="M:AI.ML.Clustering.KohonenNet.ClassifyAndTrain(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучение и классификация
            </summary>
            <param name="vect"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Clustering.KohonenNet.Train(AI.DataStructs.Algebraic.Vector[],System.Int32)">
            <summary>
            Обучение сети кохонена
            </summary>
            <param name="datasetInp"></param>
            <param name="param"></param>
        </member>
        <member name="T:AI.ML.CrossCorrMatrix">
            <summary>
            Корреляционная матрица
            </summary>
        </member>
        <member name="M:AI.ML.CrossCorrMatrix.CalcMatrix(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Рассчет корреляционной матрицы
            </summary>
        </member>
        <member name="T:AI.ML.DataEncoding.PositionalEncoding.IPositionEncoding">
            <summary>
            Кодер позиций
            </summary>
        </member>
        <member name="P:AI.ML.DataEncoding.PositionalEncoding.IPositionEncoding.Dim">
            <summary>
            Размерность выходного вектора
            </summary>
        </member>
        <member name="M:AI.ML.DataEncoding.PositionalEncoding.IPositionEncoding.GetCode(System.Int32)">
            <summary>
            Код(вектор) позиции 
            </summary>
        </member>
        <member name="M:AI.ML.DataEncoding.PositionalEncoding.IPositionEncoding.GetCode(System.Double)">
            <summary>
            Код(вектор) позиции 
            </summary>
        </member>
        <member name="T:AI.ML.DataEncoding.PositionalEncoding.MultiscaleEncoder">
            <summary>
            Многомасштабное кодирование позиции, предполагается, что размерность может быть представлена ​​как 2^N
            </summary>
        </member>
        <member name="P:AI.ML.DataEncoding.PositionalEncoding.MultiscaleEncoder.Dim">
            <summary>
            Размерность
            </summary>
        </member>
        <member name="M:AI.ML.DataEncoding.PositionalEncoding.MultiscaleEncoder.#ctor(System.Int32)">
            <summary>
            Многомасштабное кодирование позиции, предполагается, что размерность может быть представлена ​​как 2^N
            </summary>
            <param name="dim">Размерность</param>
        </member>
        <member name="M:AI.ML.DataEncoding.PositionalEncoding.MultiscaleEncoder.GetCode(System.Int32)">
            <summary>
            Получение многомасштабного кода положения, код представляется вектором
            </summary>
            <param name="position">Позиция</param>
        </member>
        <member name="M:AI.ML.DataEncoding.PositionalEncoding.MultiscaleEncoder.GetCode(System.Double)">
            <summary>
            Получение многомасштабного кода положения, код представляется вектором
            </summary>
            <param name="position">Позиция</param>
        </member>
        <member name="T:AI.ML.DataEncoding.PositionalEncoding.OneHotPositionEncoder">
            <summary>
            Кодирование позиции в вектор например, позиция 1 кодируется [0, 1, 0, 0], позиция 2 [0, 0, 1, 0]
            </summary>
        </member>
        <member name="P:AI.ML.DataEncoding.PositionalEncoding.OneHotPositionEncoder.Dim">
            <summary>
            Размерность вектора
            </summary>
        </member>
        <member name="M:AI.ML.DataEncoding.PositionalEncoding.OneHotPositionEncoder.#ctor(System.Int32)">
            <summary>
            Кодирование позиции в вектор например, позиция 1 кодируется [0, 1, 0, 0], позиция 2 [0, 0, 1, 0]
            </summary>
        </member>
        <member name="M:AI.ML.DataEncoding.PositionalEncoding.OneHotPositionEncoder.GetCode(System.Int32)">
            <summary>
            Получить код
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.DataEncoding.PositionalEncoding.OneHotPositionEncoder.GetCode(System.Double)">
            <summary>
            Получить код
            </summary>
        </member>
        <member name="T:AI.ML.DataEncoding.PositionalEncoding.PositionEncoderOnDeductionRings">
            <summary>
            Кодирование позиции в вектор на базе колец вычетов
            </summary>
        </member>
        <member name="P:AI.ML.DataEncoding.PositionalEncoding.PositionEncoderOnDeductionRings.Dim">
            <summary>
            Модуль кольца - размерность вектора
            </summary>
        </member>
        <member name="M:AI.ML.DataEncoding.PositionalEncoding.PositionEncoderOnDeductionRings.#ctor(System.Int32)">
            <summary>
            Кодирование позиции в вектор на базе колец вычетов
            </summary>
        </member>
        <member name="M:AI.ML.DataEncoding.PositionalEncoding.PositionEncoderOnDeductionRings.GetCode(System.Int32)">
            <summary>
            Код(вектор) позиции 
            </summary>
        </member>
        <member name="M:AI.ML.DataEncoding.PositionalEncoding.PositionEncoderOnDeductionRings.GetCode(System.Double)">
            <summary>
            Код(вектор) позиции 
            </summary>
        </member>
        <member name="T:AI.ML.DataEncoding.PositionalEncoding.TrigonometricPositionalEncoder">
            <summary>
            Позиционное (индексное) кодирование на основе ортогональных тригонометрических функций
            </summary>
        </member>
        <member name="P:AI.ML.DataEncoding.PositionalEncoding.TrigonometricPositionalEncoder.Dim">
            <summary>
            Размерность вектора выхода
            </summary>
        </member>
        <member name="M:AI.ML.DataEncoding.PositionalEncoding.TrigonometricPositionalEncoder.#ctor(System.Int32)">
            <summary>
            Позиционное (индексное) кодирование на основе ортогональных тригонометрических функций
            </summary>
            <param name="dim">Размерность вектора выхода</param>
        </member>
        <member name="M:AI.ML.DataEncoding.PositionalEncoding.TrigonometricPositionalEncoder.GetCode(System.Int32)">
            <summary>
            Получение кода позиции вектора (индекса)
            </summary>
        </member>
        <member name="M:AI.ML.DataEncoding.PositionalEncoding.TrigonometricPositionalEncoder.GetCode(System.Double)">
            <summary>
            Получение кода позиции вектора (Время)
            </summary>
        </member>
        <member name="T:AI.ML.DataSets.Base.Many2ManyVectorClassifier">
            <summary>
            Последовательность данных для обучения рекуррентной сети по принципу «многие ко многим»
            </summary>
        </member>
        <member name="P:AI.ML.DataSets.Base.Many2ManyVectorClassifier.Labels">
            <summary>
            Метки классов
            </summary>
        </member>
        <member name="P:AI.ML.DataSets.Base.Many2ManyVectorClassifier.Features">
            <summary>
            Признаки
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.Base.Many2ManyVectorClassifier.#ctor">
            <summary>
            Последовательность данных для обучения рекуррентной сети по принципу «многие ко многим»
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.Base.Many2ManyVectorClassifier.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}})">
            <summary>
            Последовательность данных для обучения рекуррентной сети по принципу «многие ко многим»
            </summary>
            <param name="labels">Метки классов</param>
            <param name="features">Признаки</param>
        </member>
        <member name="M:AI.ML.DataSets.Base.Many2ManyVectorClassifier.GetDataset(System.Collections.Generic.IEnumerable{AI.ML.DataSets.Base.Many2ManyVectorClassifier},System.Boolean)">
            <summary>
            Получение набора данных для использования с менеджером нейронной сети
            </summary>
            <param name="data">Набор данных</param>
            <param name="doShuffling">Нужно ли перемешивать данные в случайном порядке</param>
        </member>
        <member name="T:AI.ML.DataSets.Base.Many2ManyVectorClassifierDataset">
            <summary>
            Набор данных, содержащий массив последовательностей для обучения рекуррентных нейронных сетей.
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.Base.Many2ManyVectorClassifierDataset.GetLabels">
            <summary>
            Метод возвращает массив списков (массив последовательностей) меток классов
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.Base.Many2ManyVectorClassifierDataset.GetFeatures">
            <summary>
            Метод возвращает массив списков (массив последовательностей) векторов признаков.
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.Base.Many2ManyVectorClassifierDataset.GetVectorLabels(System.Int32)">
            <summary>
            Метод возвращает массив списков (массив последовательностей) меток классов в векторном представлении.
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.Base.Many2ManyVectorClassifierDataset.ShufflingDataset">
            <summary>
            Перемешивание с равномерным распределением
            </summary>
        </member>
        <member name="T:AI.ML.DataSets.ExtensionOfFeatureSpace">
            <summary>
            Расширение пространства признаков
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.Polinomial(System.Double,System.Int32)">
            <summary>
            Раширение пространства признаков полиномиальной ф-ей
            </summary>
            <param name="x">Вход</param>
            <param name="n">степень полинома</param>
            <returns>Новый вектор</returns>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.Polinomial(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Раширение пространства признаков полиномиальной ф-ей
            </summary>
            <param name="inp">Вход</param>
            <param name="n">степень полинома</param>
            <returns>Новый вектор</returns>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.Cos(System.Double,System.Int32)">
            <summary>
            Раширение пространства признаков косинусами
            </summary>
            <param name="x">Вход</param>
            <param name="n">Число гармоник</param>
            <returns>Новый вектор</returns>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.Sin(System.Double,System.Int32)">
            <summary>
            Раширение пространства признаков синусами 
            </summary>
            <param name="x">Вход</param>
            <param name="n">Число гармоник</param>
            <returns>Новый вектор</returns>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.SinCos(System.Double,System.Int32)">
            <summary>
            Раширение пространства признаков синусами и косинусами
            </summary>
            <param name="x">Вход</param>
            <param name="n">Число гармоник</param>
            <returns>Новый вектор</returns>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.Cos(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Раширение пространства признаков косинусами
            </summary>
            <param name="inp">Вход</param>
            <param name="n">Число гармоник</param>
            <returns>Новый вектор</returns>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.PoliCos(AI.DataStructs.Algebraic.Vector,System.Int32,System.Int32)">
            <summary>
            Расширение пространства с помощью полиномиальных ф-й и потом косинусов
            </summary>
            <param name="x">Вход</param>
            <param name="nPolinom">Степень полинома</param>
            <param name="nCos">Кол-во косинусов</param>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.PoliCos(System.Double,System.Int32,System.Int32)">
            <summary>
            Расширение пространства с помощью полиномиальных ф-й и потом косинусов
            </summary>
            <param name="x">Вход</param>
            <param name="nPolinom">Степень полинома</param>
            <param name="nCos">Кол-во косинусов</param>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.GaussRBF(System.Double,AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Радиально-базисная функция Гаусса
            </summary>
            <param name="x">Вход</param>
            <param name="centers">Массив центров</param>
            <param name="std">Среднеквадратичное отклонение</param>
            <returns>Вектор значений от 0 до 1</returns>
        </member>
        <member name="M:AI.ML.DataSets.ExtensionOfFeatureSpace.Sinc(System.Double,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Синус Котельникова sin(x)/x
            </summary>
            <param name="x"></param>
            <param name="centers"></param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.DataSets.MatrixInt">
            <summary>
            Датасет с картинками матрица-нормер класса
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.MatrixInt.GetRandMatrixIntSemple">
            <summary>
            Выдает случайную матрицу
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.DataSets.MatrixIntSample">
            <summary>
            Элемент датасета (матрица - номер класса)
            </summary>
        </member>
        <member name="P:AI.ML.DataSets.MatrixIntSample.Matrix">
            <summary>
            Матрица
            </summary>
        </member>
        <member name="P:AI.ML.DataSets.MatrixIntSample.ClassNum">
            <summary>
            Номер класса
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.MatrixIntSample.#ctor">
            <summary>
            Элемент датасета (матрица - номер класса)
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.MatrixIntSample.#ctor(AI.DataStructs.Algebraic.Matrix,System.Int32)">
            <summary>
            Элемент датасета (матрица - номер класса)
            </summary>
            <param name="matr">Матрица</param>
            <param name="numClass">Номер класса</param>
        </member>
        <member name="T:AI.ML.DataSets.MatrixVector">
            <summary>
            Коллекция(датасет) матрица-вектор
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.MatrixVector.MatrixVectorSempleRand">
            <summary>
            Случайный экземпляр
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.DataSets.MatrixVectorSample">
            <summary>
            Матрица-вектор
            </summary>
        </member>
        <member name="F:AI.ML.DataSets.MatrixVectorSample.matrix">
            <summary>
            Матрица
            </summary>
        </member>
        <member name="F:AI.ML.DataSets.MatrixVectorSample.vector">
            <summary>
            Вектор
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.MatrixVectorSample.#ctor(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Матрица-вектор
            </summary>
            <param name="matr">Матрица</param>
            <param name="vect">Вектор</param>
        </member>
        <member name="T:AI.ML.DataSets.Synthetic.PointClouds">
            <summary>
            Синтетические облака точек (данных)
            </summary>
        </member>
        <member name="P:AI.ML.DataSets.Synthetic.PointClouds.Dimention">
            <summary>
            Размерность
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.Synthetic.PointClouds.#ctor(System.Int32)">
            <summary>
            Синтетические облака точек (данных)
            </summary>
            <param name="dim">Размерность</param>
        </member>
        <member name="M:AI.ML.DataSets.Synthetic.PointClouds.AddCloud(System.Int32,AI.DataStructs.Algebraic.Vector,AI.ML.DataSets.Synthetic.PointClouds.CloudType,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Добавить облако точек (данных)
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.Synthetic.PointClouds.GetArray">
            <summary>
            Вывести как массив данных
            </summary>
        </member>
        <member name="T:AI.ML.DataSets.Synthetic.PointClouds.CloudType">
            <summary>
            Тип облака точек
            </summary>
        </member>
        <member name="F:AI.ML.DataSets.Synthetic.PointClouds.CloudType.Hypersphere">
            <summary>
            Гиперсфера
            </summary>
        </member>
        <member name="F:AI.ML.DataSets.Synthetic.PointClouds.CloudType.Hypercube">
            <summary>
            Гиперкуб
            </summary>
        </member>
        <member name="T:AI.ML.DataSets.VectorClass">
            <summary>
            Представляет структуру вектор-класс
            </summary>
        </member>
        <member name="F:AI.ML.DataSets.VectorClass.Features">
            <summary>
            Вектор для классификации
            </summary>
        </member>
        <member name="F:AI.ML.DataSets.VectorClass.ClassMark">
            <summary>
            Метка класса
            </summary>
        </member>
        <member name="P:AI.ML.DataSets.VectorClass.R">
            <summary>
            Радиус(схожесть)
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.VectorClass.#ctor(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Представляет структуру вектор-класс
            </summary>
            <param name="vector">Вектор</param>
            <param name="mark">Метка класса</param>
        </member>
        <member name="M:AI.ML.DataSets.VectorClass.#ctor">
            <summary>
            Представляет структуру вектор-класс
            </summary>
        </member>
        <member name="T:AI.ML.DataSets.GroupeVidData">
            <summary>
            Группа объектов одного класса
            </summary>
        </member>
        <member name="F:AI.ML.DataSets.GroupeVidData.GroupeMark">
            <summary>
            Индекс класса(группы)
            </summary>
        </member>
        <member name="F:AI.ML.DataSets.GroupeVidData.GroupeFeatures">
            <summary>
            Мукторы признаков группы
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.GroupeVidData.#ctor">
            <summary>
            Группа объектов одного класса
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.GroupeVidData.#ctor(System.Int32,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Группа объектов одного класса
            </summary>
        </member>
        <member name="P:AI.ML.DataSets.GroupeVidData.Mean">
            <summary>
            Вектор средних
            </summary>
        </member>
        <member name="P:AI.ML.DataSets.GroupeVidData.Std">
            <summary>
            Вектор СКО
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.GroupeVidData.IndexLbl(System.Collections.Generic.IEnumerable{AI.ML.DataSets.GroupeVidData},System.Int32)">
            <summary>
            Возвращет индекс первого вхождения заданной метки класса
            </summary>
            <param name="lbl">Метка класса</param>
            <param name="data">Списо групп</param>
        </member>
        <member name="T:AI.ML.DataSets.VectorIntDataset">
            <summary>
            Датасет
            </summary>
        </member>
        <member name="F:AI.ML.DataSets.VectorIntDataset.mean">
            <summary>
            Средний вектор
            </summary>
        </member>
        <member name="F:AI.ML.DataSets.VectorIntDataset.disp">
            <summary>
            Дисперсия по выборке
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.#ctor(System.String)">
            <summary>
            Загрузка датасета из файла
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.#ctor">
            <summary>
            Датасет
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.#ctor(System.Int32)">
            <summary>
            Датасет
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.GetRandomData">
            <summary>
            Случайный представитель датасета
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.GetFeatures">
            <summary>
            Получение векторов признаков
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.CorrMatrFeatures">
            <summary>
            Корреляционная матрица признаков
            </summary>
            <returns>Нормированная кор. матрица</returns>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.DispMeanResult">
            <summary>
            Получение вектора дисперсии и среднего вектора
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.ZNormalise(System.String,System.Boolean)">
            <summary>
            Нормализация датасета
            </summary>
            <returns>Датасет</returns>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.GetDatasetDelSim(System.Double)">
            <summary>
            Удаление похожих векторов из разных классов
            </summary>
            <param name="simCoef">Коэффициент схожести</param>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.CsvToVid(System.String,System.Char)">
            <summary>
            
            </summary>
            <param name="path">Путь до файла</param>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.CsvToVid(System.String,System.Int32,System.Char)">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.Save(System.String,System.Char)">
            <summary>
            Сохранение датасета
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.GroupMean">
            <summary>
            Группирует классы вычисляя средний вектор признаков
            </summary>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.GetGroupes">
            <summary>
            Группирует датасет по классам
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.DataSets.VectorIntDataset.IndexLbl(System.Int32)">
            <summary>
            Возвращет индекс первого вхождения заданной метки класса
            </summary>
            <param name="lbl">Метка класса</param>
        </member>
        <member name="T:AI.ML.Distances.BaseDist">
            <summary>
            Базовые функции измерения расстояний
            </summary>
        </member>
        <member name="M:AI.ML.Distances.BaseDist.LpDist(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},System.Int32)">
            <summary>
            Lp семейство расстояний
            </summary>
        </member>
        <member name="M:AI.ML.Distances.BaseDist.EuclideanDistance(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Евклидово расстояние
            </summary>
        </member>
        <member name="M:AI.ML.Distances.BaseDist.LinfDist(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Расстояние L-infinity
            </summary>
        </member>
        <member name="M:AI.ML.Distances.BaseDist.Cos(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Косинусное сходство
            </summary>
        </member>
        <member name="M:AI.ML.Distances.BaseDist.CosDist(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Косинусное расстояние
            </summary>
        </member>
        <member name="M:AI.ML.Distances.BaseDist.SquareEucl(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Квадрат эвклидова расстояния
            </summary>
        </member>
        <member name="M:AI.ML.Distances.BaseDist.ManhattanDistance(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Манхетонское расстояние
            </summary>
        </member>
        <member name="T:AI.ML.Distances.DistancesBetweenDistributions">
            <summary>
            Расстояние между распределениями
            </summary>
        </member>
        <member name="T:AI.ML.Distances.DistancesIntoAccountDistributions">
            <summary>
            Расстояния между точками с учетом распределений или расстояния от точки до распределения.
            </summary>
        </member>
        <member name="T:AI.ML.Distances.ProbabilityDistances">
            <summary>
            Вероятностные (энтропийные) расстояния
            </summary>
        </member>
        <member name="M:AI.ML.Distances.ProbabilityDistances.DKL(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Дивергенция Кульбака Лэйблера
            </summary>
        </member>
        <member name="M:AI.ML.Distances.ProbabilityDistances.DKLSymmetrical(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Дивергенция Кульбака Лэйблера (симетричная)
            </summary>
        </member>
        <member name="T:AI.ML.EmbedingMatrix">
            <summary>
            Матрица векторов встраивания
            </summary>
        </member>
        <member name="P:AI.ML.EmbedingMatrix.Rows">
            <summary>
            Векторы встраивания, строки
            </summary>
        </member>
        <member name="M:AI.ML.EmbedingMatrix.#ctor(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Матрица векторов встраивания
            </summary>
        </member>
        <member name="M:AI.ML.EmbedingMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Матрица векторов встраивания
            </summary>
        </member>
        <member name="T:AI.ML.FeaturesTransforms.AutoEncoder">
            <summary>
            Автокодировщик
            </summary>
        </member>
        <member name="P:AI.ML.FeaturesTransforms.AutoEncoder.LayersEncoder">
            <summary>
            Слои кодировщика
            </summary>
        </member>
        <member name="P:AI.ML.FeaturesTransforms.AutoEncoder.LayersDecoder">
            <summary>
            Слои декодера
            </summary>
        </member>
        <member name="P:AI.ML.FeaturesTransforms.AutoEncoder.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.FeaturesTransforms.AutoEncoder.GraphAutoDif">
            <summary>
            Граф автодиф
            </summary>
        </member>
        <member name="M:AI.ML.FeaturesTransforms.AutoEncoder.#ctor(AI.DataStructs.Shapes.Shape3D,System.Collections.Generic.List{AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer},System.Collections.Generic.List{AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer})">
            <summary>
            Автокодировщик
            </summary>
        </member>
        <member name="M:AI.ML.FeaturesTransforms.AutoEncoder.#ctor(System.Int32,System.Int32)">
            <summary>
            Линейный автокодировщик
            </summary>
        </member>
        <member name="M:AI.ML.FeaturesTransforms.AutoEncoder.Transform(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Преобразование (векторизация)
            </summary>
            <param name="input"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:AI.ML.FeaturesTransforms.AutoEncoder.Transform(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}})">
            <summary>
            Преобразование (векторизация)
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.FeaturesTransforms.AutoEncoder.Transform(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Преобразование
            </summary>
        </member>
        <member name="M:AI.ML.FeaturesTransforms.AutoEncoder.Train(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}},System.Int32,System.Double,AI.ML.NeuralNetwork.CoreNNW.Optimizers.IOptimizer)">
            <summary>
            Обучение автокодировщика
            </summary>
            <param name="data">Данные</param>
            <param name="epoch">Число эпох</param>
            <param name="lr">Скорость обучения</param>
            <param name="optimizer">Оптимизатор</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.FeaturesTransforms.AutoEncoder.Train(AI.DataStructs.Algebraic.Matrix,System.Int32,System.Double,AI.ML.NeuralNetwork.CoreNNW.Optimizers.IOptimizer)">
            <summary>
            Обучение автокодировщика
            </summary>
            <param name="data">Данные</param>
            <param name="epoch">Число эпох</param>
            <param name="lr">Скорость обучения</param>
            <param name="optimizer">Оптимизатор</param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.FeaturesTransforms.PCA">
            <summary>
            Метод главных компонент
            </summary>
        </member>
        <member name="P:AI.ML.FeaturesTransforms.PCA.Iterations">
            <summary>
            Число итераций
            </summary>
        </member>
        <member name="P:AI.ML.FeaturesTransforms.PCA.Info">
            <summary>
            Информация об экземпляре
            </summary>
        </member>
        <member name="P:AI.ML.FeaturesTransforms.PCA.Eigenvalues">
            <summary>
            Собственные числа ков матрицы
            </summary>
        </member>
        <member name="P:AI.ML.FeaturesTransforms.PCA.Eps">
            <summary>
            Значение сходимости (если разница в RQ алгоритме выше, срабатывает исключение)
            </summary>
        </member>
        <member name="F:AI.ML.FeaturesTransforms.PCA._sqrtEigenvalues">
            <summary>
            Корень из собственных чисел ков матрицы
            </summary>
        </member>
        <member name="M:AI.ML.FeaturesTransforms.PCA.#ctor(System.Nullable{System.Int32})">
            <summary>
            Метод главных компонент
            </summary>
            <param name="k">Число компонент null - все</param>
        </member>
        <member name="M:AI.ML.FeaturesTransforms.PCA.Train(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Обучение PCA
            </summary>
            <param name="matrix">Матрица данных</param>
        </member>
        <member name="M:AI.ML.FeaturesTransforms.PCA.Train(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Обучение PCA
            </summary>
            <param name="vectors">Матрица данных</param>
        </member>
        <member name="M:AI.ML.FeaturesTransforms.PCA.Transform(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Vector},System.Boolean)">
            <summary>
            Прямое преобразование
            </summary>
            <param name="data">Данные</param>
            <param name="isNormal">Нормализовывать ли</param>
        </member>
        <member name="M:AI.ML.FeaturesTransforms.PCA.Transform(AI.DataStructs.Algebraic.Vector,System.Boolean)">
            <summary>
            Прямое преобразование одного вектора
            </summary>
            <param name="vector">Данные</param>
            <param name="isNormal">Нормализовывать ли</param>
        </member>
        <member name="M:AI.ML.FeaturesTransforms.PCA.Transform(AI.DataStructs.Algebraic.Matrix,System.Boolean)">
            <summary>
            Прямое преобразование
            </summary>
            <param name="data">Данные</param>
            <param name="isNormal">Нормализовывать ли</param>
        </member>
        <member name="T:AI.ML.FeaturesTransforms.PCAInfo">
            <summary>
            Информация о преобразовании
            </summary>
        </member>
        <member name="P:AI.ML.FeaturesTransforms.PCAInfo.InfoSaveEnergy">
            <summary>
            Доля сохраненной энергии
            </summary>
        </member>
        <member name="P:AI.ML.FeaturesTransforms.PCAInfo.LastVar">
            <summary>
            Остаточная дисперсия
            </summary>
        </member>
        <member name="P:AI.ML.FeaturesTransforms.PCAInfo.SaveVar">
            <summary>
            Сохраненная дисперсия
            </summary>
        </member>
        <member name="P:AI.ML.FeaturesTransforms.PCAInfo.EpsEigenvalues">
            <summary>
            Ошибка при вычисление собственных чисел
            </summary>
        </member>
        <member name="P:AI.ML.FeaturesTransforms.PCAInfo.IsConvergence">
            <summary>
            Сошелся ли алгоритм
            </summary>
        </member>
        <member name="T:AI.ML.Genetic.GeneticCore.Cell">
            <summary>
            Клетка
            </summary>
        </member>
        <member name="P:AI.ML.Genetic.GeneticCore.Cell.Score">
            <summary>
            Набранные очки
            </summary>
        </member>
        <member name="P:AI.ML.Genetic.GeneticCore.Cell.Parametrs">
            <summary>
            Параметры (хромосомы)
            </summary>
        </member>
        <member name="P:AI.ML.Genetic.GeneticCore.Cell.Function">
            <summary>
            Полезная функция
            </summary>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Cell.#ctor(System.Int32,System.Func{AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector},System.Random,System.Double,System.Double)">
            <summary>
            Клетка
            </summary>
            <param name="parametrsCount">Число параметров</param>
            <param name="function">Функция</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
            <param name="valDown">Нижняя граница распределения</param>
            <param name="valUp">Верхняя граница распределения</param>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Cell.Output(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Выход модели
            </summary>
            <param name="inpVector">Входной вектор</param>
        </member>
        <member name="T:AI.ML.Genetic.GeneticCore.Population">
            <summary>
            Популяция клеток
            </summary>
        </member>
        <member name="F:AI.ML.Genetic.GeneticCore.Population.mutProb">
            <summary>
            Вероятность мутации
            </summary>
        </member>
        <member name="F:AI.ML.Genetic.GeneticCore.Population.k">
            <summary>
            Скрещивание
            </summary>
        </member>
        <member name="P:AI.ML.Genetic.GeneticCore.Population.LiderCount">
            <summary>
            Число лидеров для размножения
            </summary>
        </member>
        <member name="P:AI.ML.Genetic.GeneticCore.Population.MutationValue">
            <summary>
            Величина мутации
            </summary>
        </member>
        <member name="P:AI.ML.Genetic.GeneticCore.Population.DValueUp">
            <summary>
            Верхняя граница поиска (ГПСЧ)
            </summary>
        </member>
        <member name="P:AI.ML.Genetic.GeneticCore.Population.DValueDown">
            <summary>
            Нижняя граница поиска (ГПСЧ)
            </summary>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Population.#ctor(System.Int32,System.Int32,System.Func{AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector},AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[],System.Double,System.Double)">
            <summary>
            Population
            </summary>
            <param name="countCell">Число клеток</param>
            <param name="countParam">Число параметров</param>
            <param name="function">Функция полезности</param>
            <param name="inp">Вектор входных данных</param>
            <param name="outp">Вектор выхода</param>
            <param name="valDown">Минимальное значение поиска параметров</param>
            <param name="valUp">Максимальное значение поиска параметра</param>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Population.#ctor(System.Int32,System.Int32,System.Func{AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector},AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Double,System.Double)">
            <summary>
            Популяция
            </summary>
            <param name="countCell">Число клеток</param>
            <param name="countParam">Число параметров</param>
            <param name="function">Функция полезности</param>
            <param name="inp">Вектор входных данных</param>
            <param name="outp">Вектор выхода</param>
            <param name="valDown">Минимальное значение поиска параметров</param>
            <param name="valUp">Максимальное значение поиска параметра</param>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Population.CellOut(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
             Передача функции от одной переменной
            </summary>
            <param name="inp">Вектор входов</param>
            <param name="indCell">Номер клетки</param>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Population.Epoch(System.Int32)">
            <summary>
            Эпоха для клеток
            </summary>
            <param name="count">Число потомков</param>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Population.Score(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Баллы за один пример
            </summary>
            <param name="outp">Выход модели</param>
            <param name="targ">Целевые значения</param>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Population.SortCells">
            <summary>
            Сортировка
            </summary>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Population.Mutation(AI.ML.Genetic.GeneticCore.Cell)">
            <summary>
            Мутация клетки
            </summary>
            <param name="input">Оригинальная клетка</param>
        </member>
        <member name="M:AI.ML.Genetic.GeneticCore.Population.Cross(AI.ML.Genetic.GeneticCore.Cell,AI.ML.Genetic.GeneticCore.Cell)">
            <summary>
            Cell crossing
            </summary>
            <param name="par1">First parent</param>
            <param name="par2">Second parent</param>
        </member>
        <member name="T:AI.ML.GradientDecentDataset">
            <summary>
            Класс для хранения обучающей выборки для градиентного спуска
            </summary>
        </member>
        <member name="P:AI.ML.GradientDecentDataset.X">
            <summary>
            Набор векторов "Х"
            </summary>
        </member>
        <member name="P:AI.ML.GradientDecentDataset.Y">
            <summary>
            Набор векторов "Y"
            </summary>
        </member>
        <member name="M:AI.ML.GradientDecentDataset.#ctor">
            <summary>
            Создает экземпляр GradientDecentDataset
            </summary>
        </member>
        <member name="M:AI.ML.GradientDecentDataset.#ctor(System.Collections.Generic.List{AI.DataStructs.Algebraic.Vector},System.Collections.Generic.List{AI.DataStructs.Algebraic.Vector})">
            <summary>
            Создает экземпляр GradientDecentDataset
            </summary>
            <param name="xVector">Набор векторов "Х"</param>
            <param name="yVector">Набор векторов "Y"</param>
        </member>
        <member name="M:AI.ML.GradientDecentDataset.Add(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Добавляет данные в обучающую выборку
            </summary>
            <param name="x">Вектор х</param>
            <param name="y">Вектор у</param>
        </member>
        <member name="M:AI.ML.GradientDecentDataset.Add(System.Double,System.Double)">
            <summary>
            Добавляет данные в обучающую выборку
            </summary>
            <param name="x">переменная х</param>
            <param name="y">переменная у</param>
        </member>
        <member name="M:AI.ML.GradientDecentDataset.Add(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Добавляет данные в обучающую выборку
            </summary>
            <param name="x">Вектор х</param>
            <param name="y">Переменная у</param>
        </member>
        <member name="M:AI.ML.GradientDecentDataset.Clear">
            <summary>
            Очистка данных
            </summary>
        </member>
        <member name="T:AI.ML.GradientDecent">
            <summary>
            Градиентный спуск
            </summary>
        </member>
        <member name="P:AI.ML.GradientDecent.Step">
            <summary>
            Шаг для вычисления частных производных и градиента
            (чем он меньше, тем точнее вычисление частных производных)
            по умолчанию step 1e-7
            </summary>
        </member>
        <member name="P:AI.ML.GradientDecent.GdDataset">
            <summary>
            Обучающая выборка
            </summary>
        </member>
        <member name="P:AI.ML.GradientDecent.Parammetrs">
            <summary>
            Вектор оптимизируемых парамметров
            </summary>
        </member>
        <member name="P:AI.ML.GradientDecent.Function">
            <summary>
            Целевая функция типа:
            double SF(Vector_парамметры, ListVector_обучающая_выборка_Х, ListVector_обучающая_выборка_Y)
            </summary>
        </member>
        <member name="P:AI.ML.GradientDecent.Norm">
            <summary>
            Норма обучения, по умолчанию 0.002
            </summary>
        </member>
        <member name="P:AI.ML.GradientDecent.Itterations">
            <summary>
            Кол-во иттераций, по умолчанию 30
            </summary>
        </member>
        <member name="M:AI.ML.GradientDecent.#ctor(AI.DataStructs.Algebraic.Vector,System.Func{AI.DataStructs.Algebraic.Vector,System.Collections.Generic.List{AI.DataStructs.Algebraic.Vector},System.Collections.Generic.List{AI.DataStructs.Algebraic.Vector},System.Double},AI.ML.GradientDecentDataset)">
            <summary>
            Создание объекта Градиентный спуск
            </summary>
            <param name="param">Вектор оптимизируемых парамметров</param>
            <param name="function">Целевая функция типа:
            double SF(Vector_парамметры, ListVector_обучающая_выборка_Х, ListVector_обучающая_выборка_Y)</param>
            <param name="gdd">Обучающая выборка</param>
        </member>
        <member name="M:AI.ML.GradientDecent.DecentIter">
            <summary>
            Одна иттерация спуска
            </summary>
        </member>
        <member name="M:AI.ML.GradientDecent.Decent">
            <summary>
            Синхронное выполнение градиентного спуска
            </summary>
        </member>
        <member name="M:AI.ML.GradientDecent.AsyncDecent">
            <summary>
            Асинхронное выполнение градиентного спуска
            </summary>
        </member>
        <member name="M:AI.ML.GradientDecent.PartialDerivatives(AI.DataStructs.Algebraic.Vector,System.Collections.Generic.List{AI.DataStructs.Algebraic.Vector},System.Collections.Generic.List{AI.DataStructs.Algebraic.Vector},System.Func{AI.DataStructs.Algebraic.Vector,System.Collections.Generic.List{AI.DataStructs.Algebraic.Vector},System.Collections.Generic.List{AI.DataStructs.Algebraic.Vector},System.Double})">
            <summary>
            Частные производные
            </summary>
            <param name="param">Начальный вектор параметров(точка)</param>
            <param name="function">Целевая функция(принимает вектор параметров, выдает результирующее значение)</param>
             <param name="inp"> Вектора входа</param>
              <param name="ideal"> Целевые выходы</param>
            <returns>Возвращает вектор частных производных</returns>
        </member>
        <member name="T:AI.ML.HMM.HMM">
            <summary>
            Дискретная Марковская цепь
            </summary>
        </member>
        <member name="F:AI.ML.HMM.HMM.stateMatrix">
            <summary>
            Матрица состояний
            </summary>
        </member>
        <member name="F:AI.ML.HMM.HMM.stateAlter">
            <summary>
            Обратная матрица состояний (1-matr_state)
            </summary>
        </member>
        <member name="F:AI.ML.HMM.HMM.states">
            <summary>
            Состояния
            </summary>
        </member>
        <member name="M:AI.ML.HMM.HMM.#ctor">
            <summary>
            Марковская цепь
            </summary>
        </member>
        <member name="M:AI.ML.HMM.HMM.Train(System.Int32[])">
            <summary>
            Обучение
            </summary>
            <param name="trainSeq">Изучаемая последовательность</param>
        </member>
        <member name="M:AI.ML.HMM.HMM.GetMax(System.Double[0:,0:])">
            <summary>
            Максимальная вероятность перехода
            </summary>
            <param name="matrix">Матрица состояний</param>
        </member>
        <member name="M:AI.ML.HMM.HMM.Generate(System.Int32,System.Int32)">
            <summary>
            Генерация текста
            </summary>
            <param name="num">Число шагов</param>
            <param name="begin">Первое слово</param>
        </member>
        <member name="T:AI.ML.HMM.MChWords">
            <summary>
            Марковская цепь
            </summary>
        </member>
        <member name="F:AI.ML.HMM.MChWords.stateMatrix">
            <summary>
            Матрица состояний
            </summary>
        </member>
        <member name="F:AI.ML.HMM.MChWords.stateAlter">
            <summary>
            Обратная матрица состояний (1-matr_state)
            </summary>
        </member>
        <member name="M:AI.ML.HMM.MChWords.#ctor">
            <summary>
            Марковская цепь
            </summary>
        </member>
        <member name="M:AI.ML.HMM.MChWords.Train(System.String)">
            <summary>
            Обучение
            </summary>
            <param name="TrainText">Обучающая выборка (Текст)</param>
        </member>
        <member name="M:AI.ML.HMM.MChWords.GetMax(System.Double[0:,0:])">
            <summary>
            Максимальная вероятность перехода
            </summary>
            <param name="matrix">Матрица состояний</param>
        </member>
        <member name="M:AI.ML.HMM.MChWords.Generate(System.Int32,System.String)">
            <summary>
            Генерация текста
            </summary>
            <param name="num">Число шагов</param>
            <param name="begin">Первое слово</param>
        </member>
        <member name="T:AI.ML.HMM.KMeanHMM">
            <summary>
            Скрытая марковская модель с выделением состояний на основе алгоритма k-средних
            </summary>
        </member>
        <member name="P:AI.ML.HMM.KMeanHMM.KMean">
            <summary>
            Алгоритм выделения состояний на основе алгоритма k-средних
            </summary>
        </member>
        <member name="M:AI.ML.HMM.KMeanHMM.#ctor(System.Int32)">
            <summary>
            Скрытая марковская модель с выделением состояний на основе алгоритма k-средних
            </summary>
        </member>
        <member name="M:AI.ML.HMM.KMeanHMM.GetTransitionMatrix(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Получение матрицы вероятностей переходов между состояниями
            </summary>
            <param name="seq">Последовательность векторов</param>
        </member>
        <member name="M:AI.ML.HMM.KMeanHMM.GetTransitionVector(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Получение вектора вероятностей переходов между состояниями
            </summary>
            <param name="seq">Последовательность векторов</param>
        </member>
        <member name="M:AI.ML.HMM.KMeanHMM.Train(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Model training
            </summary>
            <param name="seqInp">Последовательность векторов</param>
        </member>
        <member name="M:AI.ML.HMM.KMeanHMM.TrainHMM(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Обучение только Марковской модели(без кластеризации)
            </summary>
            <param name="seqInp">Последовательность векторов</param>
        </member>
        <member name="M:AI.ML.HMM.KMeanHMM.Generate(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Генерация последовательности состояний
            </summary>
            <param name="start">Вектор начала</param>
            <param name="len">Длинна последовательности</param>
        </member>
        <member name="T:AI.ML.HMM.MCFast">
            <summary>
            Марковская цепь (Быстрый алгоритм)
            </summary>
        </member>
        <member name="P:AI.ML.HMM.MCFast.StartToken">
            <summary>
            Токен начала
            </summary>
        </member>
        <member name="P:AI.ML.HMM.MCFast.EndToken">
            <summary>
            Токен окончания
            </summary>
        </member>
        <member name="P:AI.ML.HMM.MCFast.NGram">
            <summary>
            Глубина моделирования
            </summary>
        </member>
        <member name="P:AI.ML.HMM.MCFast.ProbabilityVector">
            <summary>
            Вектор вероятностей
            </summary>
        </member>
        <member name="M:AI.ML.HMM.MCFast.#ctor">
            <summary>
            Быстрые марковские цепи
            </summary>
        </member>
        <member name="M:AI.ML.HMM.MCFast.Train(System.Int32[],System.Boolean)">
            <summary>
            Обучение модели
            </summary>
            <param name="trainSeq">Тренировочная последовательность</param>
            <param name="addStart">Добавлять ли старт вначале</param>
        </member>
        <member name="M:AI.ML.HMM.MCFast.SetLimitationsWList(System.Int32[])">
            <summary>
            Белый список токенов
            </summary>
        </member>
        <member name="M:AI.ML.HMM.MCFast.Generate(System.Int32)">
            <summary>
            Генерация текста
            </summary>
            <param name="num">Число токенов</param>
            <returns>Сгенерированная строка</returns>
        </member>
        <member name="M:AI.ML.HMM.MCFast.Generate(System.Int32,System.Int32[])">
            <summary>
            Генерация текста
            </summary>
            <param name="num">число слов</param>
            <param name="tokens">начальное состояние</param>
            <returns>сгенерированная строка</returns>
        </member>
        <member name="M:AI.ML.HMM.MCFast.Generate(System.Int32,System.Int32[],System.Random)">
            <summary>
            Генерация текста
            </summary>
            <param name="num">число слов</param>
            <param name="tokens">начальное состояние</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
            <returns>сгенерированная строка</returns>
        </member>
        <member name="M:AI.ML.HMM.MCFast.SeqToVector(System.Int32[])">
            <summary>
            Преобразование последовательности в вектор + изменение модели
            </summary>
            <param name="seq">Последовательность</param>
            <returns>вектор</returns>
        </member>
        <member name="M:AI.ML.HMM.MCFast.Save(System.String)">
            <summary>
            Сохранение Марковской модели в файл
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.HMM.MCFast.Save(System.IO.Stream)">
            <summary>
            Сохранение Марковской модели в поток
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.ML.HMM.MCFast.Load(System.String)">
            <summary>
            Загрузка марковской модели из файла
            </summary>
            <param name="path">Путь до файла</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.HMM.MCFast.Load(System.IO.Stream)">
            <summary>
            Загрузка марковской модели из потока
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.HMM.MCFast.CalculateProbabilityNGramm(System.Collections.Generic.List{System.Int32})">
            <summary>
            Вычисление вероятностей токенов
            </summary>
            <param name="start">Начальная последовательность</param>
        </member>
        <member name="T:AI.ML.HMM.MCFast.McMapElement">
            <summary>
            Элемент карты марковской цепи
            </summary>
        </member>
        <member name="F:AI.ML.HMM.MCFast.McMapElement.KeyStart">
            <summary>
            Ключ начала n-gramm
            </summary>
        </member>
        <member name="F:AI.ML.HMM.MCFast.McMapElement.KeyEnd">
            <summary>
            Ключ завершения n-gramm
            </summary>
        </member>
        <member name="M:AI.ML.HMM.MCFast.McMapElement.#ctor(System.Int32[],System.Int32)">
            <summary>
            Элемент карты марковской цепи
            </summary>
            <param name="keyStart">Ключ начала n-gramm</param>
            <param name="keyEnd">Ключ завершения n-gramm</param>
        </member>
        <member name="T:AI.ML.HMM.MCFastModel">
            <summary>
            Блок для сохранения
            </summary>
        </member>
        <member name="P:AI.ML.HMM.MCFastModel.Model">
            <summary>
            N-грамма
            </summary>
        </member>
        <member name="P:AI.ML.HMM.MCFastModel.Probability">
            <summary>
            Вероятность
            </summary>
        </member>
        <member name="M:AI.ML.HMM.MCFastModel.#ctor(System.Int32[],System.Double)">
            <summary>
            Создание параметров для хранения марковской цепи
            </summary>
            <param name="model">Модель</param>
            <param name="probability">Вероятность</param>
        </member>
        <member name="T:AI.ML.HMM.MCNextToken">
            <summary>
            Слово
            </summary>
        </member>
        <member name="P:AI.ML.HMM.MCNextToken.Value">
            <summary>
            Токен
            </summary>
        </member>
        <member name="P:AI.ML.HMM.MCNextToken.Probability">
            <summary>
            Вероятность
            </summary>
        </member>
        <member name="M:AI.ML.HMM.MCNextToken.#ctor(System.Int32,System.Double)">
            <summary>
            Слово
            </summary>
        </member>
        <member name="T:AI.ML.LinearModelTools.Margin">
            <summary>
            Работа с отступами
            </summary>
        </member>
        <member name="M:AI.ML.LinearModelTools.Margin.GetMargin(System.Single,System.Single)">
            <summary>
            Вычислить отступ
            </summary>
            <param name="ideal"></param>
            <param name="outp"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.LinearModelTools.Margin.GetMargin(System.Double,System.Double)">
            <summary>
            Вычислить отступ
            </summary>
        </member>
        <member name="M:AI.ML.LinearModelTools.Margin.GetMargin(System.Double,AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Вычислить отступ
            </summary>
        </member>
        <member name="M:AI.ML.LinearModelTools.Margin.OutputLinModel(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Выход линейной модели
            </summary>
        </member>
        <member name="M:AI.ML.LinearModelTools.Margin.GetSupportVector(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector,System.Double,System.Int32)">
            <summary>
            Получить опорные векторы
            </summary>
            <param name="ideal"></param>
            <param name="inp"></param>
            <param name="w"></param>
            <param name="b"></param>
            <param name="supportVectorsCount"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.LinearModelTools.Margin.GetMarginWithGradient(System.Double,AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double)">
            <summary>
            Отступ с градиентами
            </summary>
            <param name="ideal"></param>
            <param name="inp"></param>
            <param name="param"></param>
            <param name="bias"></param>
            <param name="C"></param>
            <param name="minMargin"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.LinearModelTools.Margin.GetAverageMarginWithGradient(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Средний отступ с градиентами (по всей выборке)
            </summary>
        </member>
        <member name="T:AI.ML.LinearModelTools.GradientMargin`2">
            <summary>
            Отступ с графдиентами
            </summary>
            <typeparam name="T1">Тип градиента</typeparam>
            <typeparam name="T2">Тип отступа</typeparam>
        </member>
        <member name="P:AI.ML.LinearModelTools.GradientMargin`2.GradientW">
            <summary>
            Градиенты вектора признаков
            </summary>
        </member>
        <member name="P:AI.ML.LinearModelTools.GradientMargin`2.GradientBias">
            <summary>
            Градиенты веса смещения
            </summary>
        </member>
        <member name="P:AI.ML.LinearModelTools.GradientMargin`2.Margin">
            <summary>
            Отступ
            </summary>
        </member>
        <member name="T:AI.ML.LinearModelTools.MarginVector">
            <summary>
            Отступ и вектор признаков
            </summary>
        </member>
        <member name="P:AI.ML.LinearModelTools.MarginVector.Margin">
            <summary>
            Отступ
            </summary>
        </member>
        <member name="P:AI.ML.LinearModelTools.MarginVector.Features">
            <summary>
            Вектор признаков
            </summary>
        </member>
        <member name="T:AI.ML.MatrixUtils.EigenValuesVectors">
            <summary>
            Алгоритм вычисления собственных чисел и векторов
            </summary>
        </member>
        <member name="P:AI.ML.MatrixUtils.EigenValuesVectors.Eigenvalues">
            <summary>
            Собственные числа
            </summary>
        </member>
        <member name="P:AI.ML.MatrixUtils.EigenValuesVectors.Eps">
            <summary>
            Ошибка
            </summary>
        </member>
        <member name="P:AI.ML.MatrixUtils.EigenValuesVectors.IsConvergence">
            <summary>
            Сошелся ли алгоритм
            </summary>
        </member>
        <member name="P:AI.ML.MatrixUtils.EigenValuesVectors.Eigenvectors">
            <summary>
            Собственные векторы
            </summary>
        </member>
        <member name="M:AI.ML.MatrixUtils.EigenValuesVectors.#ctor(AI.DataStructs.Algebraic.Matrix,System.Int32,System.Double)">
            <summary>
            Алгоритм вычисления собственных чисел и векторов
            </summary>
        </member>
        <member name="M:AI.ML.MatrixUtils.EigenValuesVectors.GetEigenvectorsStatic(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Получить собственные векторы
            </summary>
            <param name="a"></param>
            <param name="eigenvalues"></param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.MatrixUtils.FeaturesExtractorMaper">
            <summary>
            Экстрактор признаков (создает карту признаков)
            </summary>
        </member>
        <member name="M:AI.ML.MatrixUtils.FeaturesExtractorMaper.#ctor">
            <summary>
            Экстрактор признаков (создает карту признаков)
            </summary>
        </member>
        <member name="M:AI.ML.MatrixUtils.FeaturesExtractorMaper.#ctor(System.Func{AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Vector})">
            <summary>
            Экстрактор признаков (создает карту признаков)
            </summary>
        </member>
        <member name="M:AI.ML.MatrixUtils.FeaturesExtractorMaper.CreateMap(AI.DataStructs.Algebraic.Matrix,System.Int32,System.Int32)">
            <summary>
            Формирование карты
            </summary>
            <param name="img"></param>
            <param name="sizeH"></param>
            <param name="sizeW"></param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.MatrixUtils.GramSchmidtProcedure">
            <summary>
            Процедура ортагонализации Грама-Шмидта
            </summary>
        </member>
        <member name="M:AI.ML.MatrixUtils.GramSchmidtProcedure.GetProj(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Matrix,System.Int32)">
            <summary>
            Проекция столбца матрицы a, на столбец b
            </summary>
            <param name="a">Вектор-столбец</param>
            <param name="b">Матрица 2</param>
            <param name="colB">Столбец в матрице 2</param>
        </member>
        <member name="M:AI.ML.MatrixUtils.GramSchmidtProcedure.GetVectorCol(AI.DataStructs.Algebraic.Matrix,System.Int32)">
            <summary>
            Вернуть вектор столбец
            </summary>
            <param name="a">Матрица</param>
            <param name="colA">Индекс вектора</param>
        </member>
        <member name="M:AI.ML.MatrixUtils.GramSchmidtProcedure.WriteColum(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Записать столбец
            </summary>
            <param name="a"></param>
            <param name="col"></param>
            <param name="indexCol"></param>
        </member>
        <member name="M:AI.ML.MatrixUtils.GramSchmidtProcedure.Ortogonize(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Ортогонализация
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.MatrixUtils.GramSchmidtProcedure.GetNormalBasis(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Получить ортонормированный базис
            </summary>
            <param name="a">Базис</param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.MatrixUtils.Maper">
            <summary>
            Формирователь карт
            </summary>
        </member>
        <member name="M:AI.ML.MatrixUtils.Maper.#ctor">
            <summary>
            Формирователь карт
            </summary>
        </member>
        <member name="M:AI.ML.MatrixUtils.Maper.#ctor(System.Func{AI.DataStructs.Algebraic.Matrix,System.Double})">
            <summary>
            Формирователь карт
            </summary>
            <param name="transformFunction">Функция преобразования региона(кропа), в число</param>
        </member>
        <member name="M:AI.ML.MatrixUtils.Maper.CreateMap(AI.DataStructs.Algebraic.Matrix,System.Int32,System.Int32)">
            <summary>
            Формирование карты
            </summary>
            <param name="img"></param>
            <param name="sizeH"></param>
            <param name="sizeW"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.MatrixUtils.Maper.CreateMap1D(AI.DataStructs.Algebraic.Matrix,System.Int32,System.Int32)">
            <summary>
            Создание одномерного массива меток
            </summary>
        </member>
        <member name="T:AI.ML.MatrixUtils.QR">
            <summary>
            QR разложение
            </summary>
        </member>
        <member name="M:AI.ML.MatrixUtils.QR.GetQ(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Получение матрицы Q
            </summary>
        </member>
        <member name="M:AI.ML.MatrixUtils.QR.GetR(AI.DataStructs.Algebraic.Matrix,AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Получение верхне треугольной матрицы
            </summary>
            <param name="a"></param>
            <param name="q"></param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.AbsUnit">
            <summary>
            Активационная функция в виде модуля
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.AbsUnit.Numerator">
            <summary>
            Числитель генератора случайных чисел
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.AbsUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход
            </summary>
            <param name="x">Тензор входных данных</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.AbsUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="x">Тензор входных данных</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.AbsUnit.ToString">
            <summary>
            Активационная функция name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.ArcTanUnit">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.ArcTanUnit.Numerator">
            <summary>
            Числитель генератора случайных чисел
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.ArcTanUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход
            </summary>
            <param name="x">Тензор входных данных</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.ArcTanUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.ArcTanUnit.ToString">
            <summary>
            Активационная функция name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.EliotSigUnit">
            <summary>
            Активационная функция EliotSig
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.EliotSigUnit.Numerator">
            <summary>
            Числитель генератора случайных чисел
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.EliotSigUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход
            </summary>
            <param name="x">Тензор входных данных</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.EliotSigUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.EliotSigUnit.ToString">
            <summary>
            Активационная функция name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.GaussianRbfUnit">
            <summary>
            Радиально-базисная активационная функция
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.GaussianRbfUnit.Numerator">
            <summary>
            Числитель генератора случайных чисел
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.GaussianRbfUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход
            </summary>
            <param name="x">Тензор входных данных</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.GaussianRbfUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.GaussianRbfUnit.ToString">
            <summary>
            Активационная функция name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation">
            <summary>
            Интерфейс актив. функций
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation.Numerator">
            <summary>
            Числитель генератора случайных чисел
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.LinearUnit">
            <summary>
            Линейная активационная функция
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.LinearUnit.Numerator">
            <summary>
            Числитель генератора случайных чисел
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.LinearUnit.#ctor">
            <summary>
            Линейная активационная функция
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.LinearUnit.Forward(System.Single)">
            <summary>
            Прямой проход
            </summary>
            <param name="x">Аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.LinearUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.LinearUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход(производная)
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.LinearUnit.ToString">
            <summary>
            Активационная функция name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.PLU">
            <summary>
            Активационная функция PLU (двусторонний ограничитель)
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.PLU.Numerator">
            <summary>
            Числитель генератора случайных чисел
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.PLU.#ctor">
            <summary>
            Активационная функция PLU (двусторонний ограничитель)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.PLU.#ctor(System.Single,System.Single)">
            <summary>
            Активационная функция PLU (двусторонний ограничитель)
            </summary>
            <param name="slope">Наклон за линейным участком</param>
            <param name="max">Максимальное значение линейного участка</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.PLU.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход
            </summary>
            <param name="x">Тензор входных данных</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.PLU.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="x">Тензор входных данных</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.PLU.ToString">
            <summary>
            Активационная функция name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.ReLU">
            <summary>
            Активация ReLU
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.ReLU.Numerator">
            <summary>
            Числитель генератора случайных чисел
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.ReLU.#ctor">
            <summary>
            Активация ReLU
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.ReLU.#ctor(System.Single)">
            <summary>
            Активация ReLU
            </summary>
            <param name="slope">Наклон при x меньше 0 </param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.ReLU.#ctor(System.Double)">
            <summary>
            Активация ReLU
            </summary>
            <param name="slope">Наклон при x меньше 0 </param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.ReLU.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход
            </summary>
            <param name="x">Тензор входных данных</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.ReLU.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="x">Тензор входных данных</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.ReLU.ToString">
            <summary>
            Имя актив ф.-ии
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit">
            <summary>
            Сигмоидальная функция активации [ y(x) = a*sigm(x+eps)]
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit.Numerator">
            <summary>
            Числитель генератора случайных чисел
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit.Epsilon">
            <summary>
            Параметр смещения y(x) = a*sigm(b*x+eps), по-умолчанию равен eps = 0
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit.Alpha">
            <summary>
            Параметр масштаба y(x) = a*sigm(b*x+eps), по-умолчанию равен a = 1
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit.Beta">
            <summary>
            Параметр наклона y(x) = a*sigm(b*x+eps)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit.#ctor">
            <summary>
            Сигмоидальная функция активации [ y(x) = a*sigm(b*x+eps)]
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход(производная)
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit.ToString">
            <summary>
            Имя функции
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidWithBCE">
            <summary>
            Сигмоидальная активационная функция, предполагается, что это выходной слой и функция потерь - бинарная перексрестная энтропия
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidWithBCE.Numerator">
            <summary>
            Числитель генератора случайных чисел
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidWithBCE.#ctor">
            <summary>
            Сигмоидальная активационная функция, предполагается, что это выходной слой и функция потерь - бинарная перексрестная энтропия
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidWithBCE.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidWithBCE.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход(производная)
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidWithBCE.ToString">
            <summary>
            Имя функции
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.SineUnit">
            <summary>
            Синусоидальная активационная фукция
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.SineUnit.Numerator">
            <summary>
            Числитель генератора случайных чисел
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SineUnit.#ctor">
            <summary>
            Синусоидальная активационная фукция
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SineUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход
            </summary>
            <param name="x">Тензор входных данных</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SineUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="x">Тензор входных данных</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SineUnit.ToString">
            <summary>
            Активационная функция name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.SoftmaxUnit">
            <summary>
            Софтмакс активация
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.SoftmaxUnit.Numerator">
            <summary>
            Числитель генератора случайных чисел
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SoftmaxUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход
            </summary>
            <param name="x">Тензор входных данных</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SoftmaxUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="x">Тензор входных данных</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SoftmaxUnit.ToString">
            <summary>
            Имя функции активации
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.SqnlUnit">
            <summary>
            SQN Активация
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.SqnlUnit.Numerator">
            <summary>
            Числитель генератора случайных чисел
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SqnlUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SqnlUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход(производная)
            </summary>
            <param name="x">Тензор аргумента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SqnlUnit.ToString">
            <summary>
            Активационная функция name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.SQRBFUnit">
            <summary>
            Радиально-базискная функция активации
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.SQRBFUnit.Numerator">
            <summary>
            Числитель генератора случайных чисел
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SQRBFUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход
            </summary>
            <param name="x">Тензор входных данных</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SQRBFUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.SQRBFUnit.ToString">
            <summary>
            Активационная функция name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Activations.TanhUnit">
            <summary>
            Активационная функция гиперболический тангенс
            y(x) = a*th(b*x)
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.TanhUnit.Numerator">
            <summary>
            Числитель генератора случайных чисел
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.TanhUnit.Beta">
            <summary>
            Параметр наклона y(x) = a*th(b*x), по-умолчанию равен b = 1, но есть рекомендация 2/3 [С. Хайкин. "Нейронные сети 2е изд. исп." стр. 247-248]
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Activations.TanhUnit.Alpha">
            <summary>
            Параметр масштаба y(x) = a*th(b*x), по-умолчанию равен a = 1, но есть рекомендация 1.7159 [С. Хайкин. "Нейронные сети 2е изд. исп." стр. 247-248]
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.TanhUnit.#ctor">
            <summary>
            Активационная функция гиперболический тангенс
            y(x) = a*th(b*x)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.TanhUnit.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход
            </summary>
            <param name="x">Тензор входных данных</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.TanhUnit.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="x">Тензор входных данных</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Activations.TanhUnit.ToString">
            <summary>
            Активационная функция name
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent">
            <summary>
            Набор данных для нерекуррентной нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.#ctor(AI.DataStructs.Shapes.Shape,AI.DataStructs.Shapes.Shape,AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss)">
            <summary>
            Набор данных для нерекуррентной нейронной сети
            </summary>
            <param name="inputShape"></param>
            <param name="outputShape"></param>
            <param name="loss"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.#ctor(AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss,System.Double)">
            <summary>
            Набор данных для нерекуррентной нейронной сети
            </summary>
            <param name="inputs">Входы</param>
            <param name="outputs">Выходы (целевые значения)</param>
            <param name="loss">Функция ошибки</param>
            <param name="valSplit">Часть выборки для валидации</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.#ctor(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[],AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[],AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss,System.Double)">
            <summary>
            Набор данных для нерекуррентной нейронной сети
            </summary>
            <param name="inputs">Входы</param>
            <param name="outputs">Выходы (целевые значения)</param>
            <param name="loss">Функция ошибки</param>
            <param name="valSplit">Часть выборки для валидации</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddTrainingSample(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Добавить один пример в обучающую выборку
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddTrainingSample(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Добавить один пример в обучающую выборку
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddValidationSample(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Добавить один пример в валидационную выборку
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddValidationSample(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Добавить один пример в валидационную выборку
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddTestingSample(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Добавить один пример в тестовую выборку
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddTestingSample(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Добавить один пример в тестовую выборку
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddTrainingRange(AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Добавить массив примеров в обучающую выборку
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddTrainingRange(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[],AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[])">
            <summary>
            Добавить массив примеров в обучающую выборку
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddValidationRange(AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Добавить массив примеров в валидационную выборку
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddValidationRange(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[],AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[])">
            <summary>
            Добавить массив примеров в валидационную выборку
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddTestingRange(AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Добавить массив примеров в тестовую выборку
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.AddTestingRange(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[],AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[])">
            <summary>
            Добавить массив примеров в тестовую выборку
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.Merge(AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent)">
            <summary>
            Добавить все образцы из датасета "anotherSet" в текущий
            </summary>
            <param name="anotherSet"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.Save(System.String)">
            <summary>
            Сохранить датасет в файл
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.Save(System.IO.Stream)">
            <summary>
            Сохранить датасет в поток
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.Load(System.String)">
            <summary>
            Загрузить датасет из файла
            </summary>
            <param name="path">Путь до файла</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetNoRecurrent.Load(System.IO.Stream)">
            <summary>
            Загрузить датасет из потока
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent">
            <summary>
            Набор данных для рекуррентных нейронных сетей
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.#ctor(AI.DataStructs.Shapes.Shape,AI.DataStructs.Shapes.Shape,AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss)">
            <summary>
            Набор данных для рекуррентных нейронных сетей
            </summary>
            <param name="inputShape"></param>
            <param name="outputShape"></param>
            <param name="loss"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.#ctor(System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[],System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[],AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss,System.Double)">
            <summary>
            Набор данных для рекуррентных нейронных сетей
            </summary>
            <param name="inputs">Входы</param>
            <param name="outputs">Выходы (целевые значения)</param>
            <param name="loss">Функция ошибки</param>
            <param name="valSplit">Часть выборки для валидации</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.#ctor(System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}}[],System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}}[],AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss,System.Double)">
            <summary>
            Набор данных для рекуррентных нейронных сетей
            </summary>
            <param name="inputs">Входы</param>
            <param name="outputs">Выходы (целевые значения)</param>
            <param name="loss">Функция ошибки</param>
            <param name="valSplit">Часть выборки для валидации</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddTrainingSample(System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue},System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue})">
            <summary>
            Добавить один пример в обучающую выборку
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddTrainingSample(System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}},System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}})">
            <summary>
            Добавить один пример в обучающую выборку
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddValidationSample(System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue},System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue})">
            <summary>
            Добавить один пример в валидационную выборку
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddValidationSample(System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}},System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}})">
            <summary>
            Добавить один пример в валидационную выборку
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddTestingSample(System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue},System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue})">
            <summary>
            Добавить один пример в тестовую выборку
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddTestingSample(System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}},System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}})">
            <summary>
            Добавить один пример в тестовую выборку
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddTrainingRange(System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[],System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[])">
            <summary>
            Добавить массив примеров в обучающую выборку
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddTrainingRange(System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}}[],System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}}[])">
            <summary>
            Добавить массив примеров в обучающую выборку
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddValidationRange(System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[],System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[])">
            <summary>
            Добавить массив примеров в валидационную выборку
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddValidationRange(System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}}[],System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}}[])">
            <summary>
            Добавить массив примеров в валидационную выборку
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddTestingRange(System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[],System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[])">
            <summary>
            Добавить массив примеров в тестовую выборку
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.AddTestingRange(System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}}[],System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}}[])">
            <summary>
            Добавить массив примеров в тестовую выборку
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.Merge(AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent)">
            <summary>
            Добавить все образцы из датасета "anotherSet" в текущий
            </summary>
            <param name="anotherSet"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.Save(System.String)">
            <summary>
            Сохранить датасет в файл
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.Save(System.IO.Stream)">
            <summary>
            Сохранить датасет в поток
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.Load(System.String)">
            <summary>
            Загрузить датасет из файла
            </summary>
            <param name="path">Путь до файла</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetRecurrent.Load(System.IO.Stream)">
            <summary>
            Загрузить датасет из потока
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle">
            <summary>
            Датасет для нерекуррентной сети-автокодировщика
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.#ctor(AI.DataStructs.Shapes.Shape,AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss)">
            <summary>
            Набор данных для нерекуррентной нейронной сети
            </summary>
            <param name="inputShape"></param>
            <param name="loss"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.#ctor(AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss,System.Double)">
            <summary>
            Набор данных для нерекуррентной нейронной сети
            </summary>
            <param name="data"></param>
            <param name="loss"></param>
            <param name="valSplit"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.#ctor(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[],AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss,System.Double)">
            <summary>
            Набор данных для нерекуррентной нейронной сети
            </summary>
            <param name="data"></param>
            <param name="loss"></param>
            <param name="valSplit"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddTrainingSample(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Добавить один пример в обучающую выборку
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddTrainingSample(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Добавить один пример в обучающую выборку
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddValidationSample(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Добавить один пример в валидационную выборку
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddValidationSample(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Добавить один пример в валидационную выборку
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddTestingSample(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Добавить один пример в тестовую выборку
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddTestingSample(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Добавить один пример в тестовую выборку
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddTrainingRange(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Добавить массив примеров в обучающую выборку
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddTrainingRange(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[])">
            <summary>
            Добавить массив примеров в обучающую выборку
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddvalidationRange(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Добавить массив примеров в валидационную выборку
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddValidationRange(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[])">
            <summary>
            Добавить массив примеров в валидационную выборку
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddTestingRange(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Добавить массив примеров в тестовую выборку
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.AddTestingRange(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[])">
            <summary>
            Добавить массив примеров в тестовую выборку
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.Merge(AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle)">
            <summary>
            Добавить все образцы из датасета "anotherSet" в текущий
            </summary>
            <param name="anotherSet"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.Save(System.String)">
            <summary>
            Сохранить датасет в файл
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.Save(System.IO.Stream)">
            <summary>
            Сохранить датасет в поток
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.Load(System.String)">
            <summary>
            Загрузить датасет из файла
            </summary>
            <param name="path">Путь до файла</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.DataSetSingle.Load(System.IO.Stream)">
            <summary>
            Загрузить датасет из потока
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet">
            <summary>
            Набор данных для задач цифровой обработки сигналов (ЦОС)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.#ctor(AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss)">
            <summary>
            Набор данных для задач цифровой обработки сигналов (ЦОС)
            </summary>
            <param name="loss"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.#ctor(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[],AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss,System.Double)">
            <summary>
            Набор данных для задач цифровой обработки сигналов (ЦОС)
            </summary>
            <param name="inputs">Входы</param>
            <param name="outputs">Выходы (целевые значения)</param>
            <param name="loss">Функция ошибки</param>
            <param name="valSplit">Часть выборки для валидации</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.AddTrainingSample(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Добавить один пример в обучающую выборку
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.AddValidationSample(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Добавить один пример в валидационную выборку
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.AddTestingSample(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Добавить один пример в тестовую выборку
            </summary>
            <param name="input"></param>
            <param name="output"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.AddTrainingRange(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Добавить массив примеров в обучающую выборку
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.AddValidationRange(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Добавить массив примеров в валидационную выборку
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.AddTestingRange(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Добавить массив примеров в тестовую выборку
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.Merge(AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet)">
            <summary>
            Добавить все образцы из датасета "anotherSet" в текущий
            </summary>
            <param name="anotherSet"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.Save(System.String)">
            <summary>
            Сохранить датасет в файл
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.Save(System.IO.Stream)">
            <summary>
            Сохранить датасет в поток
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.Load(System.String)">
            <summary>
            Загрузить датасет из файла
            </summary>
            <param name="path">Путь до файла</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataSets.SignalProcessingDataSet.Load(System.IO.Stream)">
            <summary>
            Загрузить датасет из потока
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSequence">
            <summary>
            Данные последовательности
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSequence.Steps">
            <summary>
            Элементы последовательности
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSequence.#ctor(AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataStep[])">
            <summary>
            Данные последовательности
            </summary>
            <param name="steps">Массив шагов</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet">
            <summary>
            Набор данных для обучения нейронки
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.InputShape">
            <summary>
            Размерность входных данных
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.OutputShape">
            <summary>
            Размерность выходных данных
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.LossFunction">
            <summary>
            Функция ошибки
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.TrainingInternal">
            <summary>
            Обучающая выборка
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.Training">
            <summary>
            Обучающая выборка
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.ValidationInternal">
            <summary>
            Проверка внутренней памяти подвыборки
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.Validation">
            <summary>
            Валидационная подвыборка
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.HasValidationData">
            <summary>
            Есть ли валидационная подвыборка
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.TestingInternal">
            <summary>
            Тестовая подвыборка internal storage
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.Testing">
            <summary>
            Тестовая подвыборка
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.HasTestingData">
            <summary>
            Есть ли тестовая подвыборка
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSet.#ctor(AI.DataStructs.Shapes.Shape,AI.DataStructs.Shapes.Shape,AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss)">
            <summary>
            Инициализировать набор данных с заданной входной и выходной формой и потерями
            </summary>
            <param name="inputShape"></param>
            <param name="outputShape"></param>
            <param name="loss"></param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataStep">
            <summary>
            Данные элемента последовательности
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataStep.Input">
            <summary>
            Тензор входных данных
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataStep.TargetOutput">
            <summary>
            Ideal output tensor
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataStep.#ctor(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Данные элемента последовательности
            </summary>
            <param name="input">Тензор входных данных</param>
            <param name="targetOutput">Тензор выходных данных</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataStep.#ctor(System.Double[],System.Double[])">
            <summary>
            Данные элемента последовательности
            </summary>
            <param name="input">Вход</param>
            <param name="targetOutput">Выход</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataStep.#ctor(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Данные элемента последовательности
            </summary>
            <param name="input">Тензор входных данных</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataStep.#ctor(System.Double[])">
            <summary>
            Данные элемента последовательности
            </summary>
            <param name="input">Вход</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet">
            <summary>
            Интерфейс набор обучающих данных
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet.InputShape">
            <summary>
            Размерность входных данных
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet.OutputShape">
            <summary>
            Размерность выходных данных
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet.LossFunction">
            <summary>
            Функция ошибки
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet.Training">
            <summary>
            Обучающая выборка
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet.Validation">
            <summary>
            Валидационная подвыборка
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet.HasValidationData">
            <summary>
            Есть ли валидационная подвыборка
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet.Testing">
            <summary>
            Тестовая подвыборка
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet.HasTestingData">
            <summary>
            Есть ли тестовая подвыборка
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Events.EpochPassedEventArgs">
            <summary>
            Параметры события эпохи обучения
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.EpochPassedEventArgs.TrainingArgs">
            <summary>
            Параметры события обучения
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.EpochPassedEventArgs.CurrentEpochNumber">
            <summary>
            Номер эпохи обучения
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.EpochPassedEventArgs.TrainingLoss">
            <summary>
            Ошибка на тренировочном наборе данных
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.EpochPassedEventArgs.ValidationLoss">
            <summary>
            Ошибка на валидационном наборе данных
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.EpochPassedEventArgs.HasValidationLoss">
            <summary>
            Имеется ли функция ошибки на валидации
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.EpochPassedEventArgs.ValidationMetrics">
            <summary>
            Качество на валидационной выборке
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.EpochPassedEventArgs.Metrics">
            <summary>
            Метрика
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.EpochPassedEventArgs.HasValidationMetrics">
            <summary>
            Имеется ли валидационная метрика
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.EpochPassedEventArgs.TestLoss">
            <summary>
            Ошибка на тестовой выборке
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.EpochPassedEventArgs.HasTestLoss">
            <summary>
            Имеется ли функция ошибки на тестовой выборке
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Events.IReporter">
            <summary>
            Интерфейс отчета
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.IReporter.ReportType">
            <summary>
            Тип отчета
            </summary>
        </member>
        <member name="E:AI.ML.NeuralNetwork.CoreNNW.Events.IReporter.ReportElementCreated">
            <summary>
            Событие отчета
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementEventArgs">
            <summary>
            Элемент отчета об обучении
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementEventArgs.ReportElementType">
            <summary>
            Тип элемента отчета об обучении
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementEventArgs.Message">
            <summary>
            Сообщение
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementEventArgs.#ctor(AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType,System.String)">
            <summary>
            Элемент отчета об обучении
            </summary>
            <param name="type"></param>
            <param name="message"></param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType">
            <summary>
            Тип элемента отчета об обучении
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType.TrainingStarted">
            <summary>
            Начало обучения
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType.TrainingFinished">
            <summary>
            Окончание обучения
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType.TrainingStopped">
            <summary>
            Остановка обучения
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType.TrainingCancelled">
            <summary>
            Начало обучения
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType.EpochPassed">
            <summary>
            Пройденные эпохи
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType.CheckPointSaved">
            <summary>
            Сохранение чекпоинта
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType.Value">
            <summary>
            Значение
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType.#ctor(System.String)">
            <summary>
            Создание элемента отчета
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType.op_Equality(AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType,AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType)">
            <summary>
            Равенство
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType.op_Inequality(AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType,AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType)">
            <summary>
            Не равенство
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType.ToString">
            <summary>
            Строковое представление
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType.Equals(System.Object)">
            <summary>
            Равенство
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType.Equals(AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType)">
            <summary>
            Равенство
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Events.ReportElementType.GetHashCode">
            <summary>
            Хэш-код
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Events.ReportType">
            <summary>
            Тип отчета(обучение)
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Events.ReportType.ConsoleReport">
            <summary>
            Вывод отчета в консоль
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Events.ReportType.EventReport">
            <summary>
            Создание событий с отчетом об обучении
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Events.ReportType.None">
            <summary>
            Не выводить отчет
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Events.TrainingEventArgs">
            <summary>
            Аргументы обучения
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.TrainingEventArgs.TrainingEpoches">
            <summary>
            Число эпох
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.TrainingEventArgs.BatchSize">
            <summary>
            Размер подвыборки
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.TrainingEventArgs.LearningRate">
            <summary>
            Скорость обучения
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.TrainingEventArgs.Model">
            <summary>
            Нейронная сеть
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.TrainingEventArgs.Data">
            <summary>
            Обучающая выборка
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Events.TrainingEventArgs.MinLoss">
            <summary>
            Минимальная ошибка
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Events.TrainingEventArgs.#ctor(System.Int32,System.Int32,System.Single,AI.ML.NeuralNetwork.CoreNNW.INetwork,AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet,System.Single)">
            <summary>
            Аргументы обучения
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.INetwork">
            <summary>
            Интерфейс нейронной сети
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.INetwork.InputShape">
            <summary>
            Форма входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.INetwork.OutputShape">
            <summary>
            Форма выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.INetwork.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.INetwork.Layers">
            <summary>
            Список слоев
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.INetwork.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Входные данные</param>
            <param name="g">Граф автоматического дифференцирования</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.INetwork.Forward(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Входные данные</param>
            <param name="g">Граф автоматического дифференцирования</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.INetwork.ResetState">
            <summary>
            Сброс состояния рекуррентной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.INetwork.GetParameters">
            <summary>
            Обучаемые параметры
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.INetwork.AddNewLayer(AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer)">
            <summary>
            Добавление нового слоя в НС
            </summary>
            <param name="layer">Новый слой</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.INetwork.AddNewLayer(AI.DataStructs.Shapes.Shape3D,AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer)">
            <summary>
            Добавление нового слоя в НС
            </summary>
            <param name="inputShape">Форма входа</param>
            <param name="layer">Новый слой</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.INetwork.OnlyUse">
            <summary>
            Только для использования (удаляет кэши важные для обучения, делает сеть в 4раза меньше)
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer">
            <summary>
            Нелинейный активационный слой
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.TrainableParameters">
            <summary>
            Число обучаемых параметров (0)
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов (0)
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.ActivationFunction">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.#ctor(AI.DataStructs.Shapes.Shape3D,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Слой активации
            </summary>
            <param name="shapeInp">Размерность входа</param>
            <param name="activation">Активационная функция</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.#ctor(AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Слой активации
            </summary>
            <param name="activation">Активационная функция</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход слоя
            </summary>
            <param name="input">Входной тензор</param>
            <param name="g">Граф автоматического дифференцирования</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ActivationLayer.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate">
            <summary>
            Агрегирующий слой, считает взвешенное среднее всех выходов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.#ctor">
            <summary>
            Агрегирующий слой, считает среднее всех выходов
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.#ctor(AI.DataStructs.Shapes.Shape3D)">
            <summary>
            Агрегирующий слой, считает среднее всех выходов
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.InitWeights(System.Random)">
            <summary>
            Генерация весовых коэффициентов
            </summary>
            <param name="random">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.GetParameters">
            <summary>
            Возвращает обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.ToString">
            <summary>
            Перевод в строку
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Agregate.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.IActivatableLayer">
            <summary>
            Слой с активационной функции
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.IActivatableLayer.ActivationFunction">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer">
            <summary>
            Интерфейс слоя нейронной сети
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILearningLayer">
            <summary>
            Обучаемый слой
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILearningLayer.InitWeights(System.Random)">
            <summary>
            Инициализация слоя
            </summary>
            <param name="random">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILearningLayer.GetParameters">
            <summary>
            Возвращает обучаемые параметры
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.IRandomizableLayer">
            <summary>
            Слой, для работы которого требуется рандомизатор
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.IRandomizableLayer.Random">
            <summary>
            Генератор псевдослучайных чисел
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.IRecurrentLayer">
            <summary>
            Интерфейс рекуррентного слоя
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Base.IRecurrentLayer.ResetState">
            <summary>
            Сброс состояния нейронной сети
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization">
            <summary>
             BatchReNormalization (Нормализация входов при онлайн-обучении)
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.#ctor">
            <summary>
             BatchReNormalization (Нормализация входов при онлайн-обучении)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.InitWeights(System.Random)">
            <summary>
            Генерация весовых коэффициентов
            </summary>
            <param name="random">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.GetParameters">
            <summary>
            Возвращает обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.ToString">
            <summary>
            Описание слоя
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.BatchReNormalization.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer">
            <summary>
            Полносвязный комплексный слой
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.WRe">
            <summary>
            Весовые коэффициенты
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.WIm">
            <summary>
            Весовые коэффициенты
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.BiasRe">
            <summary>
            Вес смещения реальной и мнимой части
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.BiasIm">
            <summary>
            Вес смещения реальной и мнимой части
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.ActivationFunction">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,System.Random)">
            <summary>
            Полносвязный комплексный слой
            </summary>
            <param name="inputShape">Размерность входа</param>
            <param name="outputDimension">Число выходов</param>
            <param name="f">Активационная функция</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.#ctor(System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Полносвязный слой
            </summary>
            <param name="outputDimension">Число выходов</param>
            <param name="f">Активационная функция</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.GetParameters">
            <summary>
            Возвращает обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.InitWeights(System.Random)">
            <summary>
            Генерация весовых коэффициентов
            </summary>
            <param name="random">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ComplexLayers.FeedComplexLayer.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D">
            <summary>
            Одномерный сверточный слой
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.IsSame">
            <summary>
            Сохраняется ли размер ввода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.InputShape">
            <summary>
            Размерность и форма входного тензора
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.ActivationFunction">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Int32,System.Random,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Одномерный сверточный слой
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.#ctor(System.Int32,System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Одномерный сверточный слой
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.InitWeights(System.Random)">
            <summary>
            Инициализация слоя
            </summary>
            <param name="random"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.GetParameters">
            <summary>
            Обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.Conv1D.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D">
            <summary>
            Одномерный апсемплинг с бикубической интерполяцией
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D.InputShape">
            <summary>
            Размерность и форма входного тензора
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D.#ctor(System.Int32)">
            <summary>
            Одномерный апсемплинг с бикубической интерполяцией
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32)">
            <summary>
            Одномерный апсемплинг с бикубической интерполяцией
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D.ToString">
            <summary>
            Описание слоя
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvDeconv.UpSampling1D.OnlyUse">
            <summary>
            Только использование
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer">
            <summary>
            Сверточный слой
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.FilterStrucuture">
            <summary>
            Структура фильтра
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.StrideX">
            <summary>
            Шаг по оси X
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.StrideY">
            <summary>
            Шаг по оси Y
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.PaddingX">
            <summary>
            Дополнение нулями по оси X
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.PaddingY">
            <summary>
            Дополнение нулями по оси Y
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.IsSame">
            <summary>
            Сохраняется ли размер ввода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.Numerator">
            <summary>
            Числитель генератора случайных чисел
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.ActivationFunction">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.Bias">
            <summary>
            Вес смещения
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.Filters">
            <summary>
            Тензоры фильтров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.InputShape">
            <summary>
            Размерность и форма входного тензора
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.#ctor(AI.DataStructs.Shapes.Shape3D,AI.ML.NeuralNetwork.CoreNNW.Layers.FilterStruct,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,System.Random)">
            <summary>
            Сверточный слой
            </summary>
            <param name="inputShape"> Размерность и форма входного тензора </param>
            <param name="filterStruct">Структура фильтров</param>
            <param name="func">Активационная функция</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.#ctor(AI.ML.NeuralNetwork.CoreNNW.Layers.FilterStruct,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Сверточный слой
            </summary>
            <param name="filterStruct">Структура фильтров</param>
            <param name="func">Активационная функция</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.#ctor(AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,System.Int32,System.Int32,System.Int32)">
            <summary>
            Сверточный слой
            </summary>
            <param name="func">Активационная функция</param>
            <param name="filterCount">Число фильтров</param>
            <param name="height">Высота фильтра</param>
            <param name="width">Ширина фильтра</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.GeneratorW(System.Random,System.Double)">
            <summary>
            Генерация весовых коэффициентов
            </summary>
            <param name="random">Генератор псевдо-случайных чисел</param>
            <param name="addDenumInSqrt">Добавление значения под корень знаменателя</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.InitWeights(System.Random)">
            <summary>
            Инициализация слоя
            </summary>
            <param name="random"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.RestOutShape">
            <summary>
            Обновление размера выхода
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.GetParameters">
            <summary>
            Возвращает обучаемые параметры
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ConvolutionalLayer.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterStruct">
            <summary>
            Структура фильтра сверточной сети
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterStruct.FilterW">
            <summary>
            Ширина фильтра
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterStruct.FilterH">
            <summary>
            Высота фильтра
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterStruct.FilterCount">
            <summary>
            Число фильтров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterStruct.Volume">
            <summary>
            Число параметров фильтра
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterStruct.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Структура фильтра сверточной сети
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten">
            <summary>
            Слой который преобразует тензор в вектор
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.InputShape">
            <summary>
            Размерность и форма входного тензора
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.ActivationFunction">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.#ctor(AI.DataStructs.Shapes.Shape3D)">
            <summary>
            Слой который преобразует тензор в вектор
            </summary>
            <param name="inputShape"> Размерность и форма входного тензора </param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.#ctor(AI.DataStructs.Shapes.Shape3D,System.Single)">
            <summary>
            Слой который преобразует тензор в вектор
            </summary>
            <param name="inputShape"> Размерность и форма входного тензора </param>
            <param name="gain">Усиление градиента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.#ctor">
            <summary>
            Слой который преобразует тензор в вектор
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Flatten.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D">
            <summary>
            Одномерный слой подвыборки
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D.InputShape">
            <summary>
            Размерность и форма входного тензора
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32)">
            <summary>
            Одномерный слой подвыборки
            </summary>
            <param name="inputShape"> Размерность и форма входного тензора </param>
            <param name="k">Восколько раз сжать карту признаков</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D.#ctor(System.Int32)">
            <summary>
            Одномерный слой подвыборки
            </summary>
            <param name="k">Восколько раз сжать карту признаков</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPool1D.OnlyUse">
            <summary>
            Только использование (облегчает сеть) 
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling">
            <summary>
            Макспуллинг
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling.InputShape">
            <summary>
            Размерность и форма входного тензора
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Int32)">
            <summary>
            Слой подвыборки
            </summary>
            <param name="inputShape"> Размерность и форма входного тензора </param>
            <param name="h">Восколько раз сжать по высоте</param>
            <param name="w">Восколько раз сжать по ширине</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling.#ctor(System.Int32,System.Int32)">
            <summary>
            Слой подвыборки 
            </summary>
            <param name="h">Восколько раз сжать по Высота</param>
            <param name="w">Восколько раз сжать по Ширина</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling.ToString">
            <summary>
            Описание слоя
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.MaxPooling.OnlyUse">
            <summary>
            Только использование (облегчает сеть) 
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape">
            <summary>
            Слой изменения формы тензора
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.InputShape">
            <summary>
            Размерность и форма входного тензора
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.TrainableParameters">
            <summary>
            Число тренировочных параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.AddDenInSqrt">
            <summary>
            Добавление в знаменатель
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.#ctor(AI.DataStructs.Shapes.Shape3D,AI.DataStructs.Shapes.Shape3D)">
            <summary>
            Слой изменения формы тензора
            </summary>
            <param name="inputShape">Начальная форма</param>
            <param name="newShape">Новая форма</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.#ctor(AI.DataStructs.Shapes.Shape3D,AI.DataStructs.Shapes.Shape3D,System.Single)">
            <summary>
            Слой изменения формы тензора
            </summary>
            <param name="inputShape">Начальная форма</param>
            <param name="newShape">Новая форма</param>
            <param name="gain">Усиление градиента</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.#ctor(AI.DataStructs.Shapes.Shape3D)">
            <summary>
            Слой изменения формы тензора
            </summary>
            <param name="newShape">Новая форма</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ReShape.OnlyUse">
            <summary>
            Только использование, без обучения
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic">
            <summary>
            Апсемплинг с бикубической интерполяцией
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic.InputShape">
            <summary>
            Размерность и форма входного тензора
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Int32)">
            <summary>
            Апсемплинг с бикубической интерполяцией
            </summary>
            <param name="inputShape"> Размерность и форма входного тензора </param>
            <param name="h">Увеличение разрешения по высоте</param>
            <param name="w">Увеличение разрешения по ширине</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic.#ctor(System.Int32,System.Int32)">
            <summary>
            Апсемплинг с бикубической интерполяцией
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic.ToString">
            <summary>
            Описание слоя
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.UpSampling2DBicubic.OnlyUse">
            <summary>
            Модификация "только для использования" ( в 4 раза легче )
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer">
            <summary>
            Слой копирования
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.ActivationFunction">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.#ctor(System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Слой копирования
            </summary>
            <param name="count">Число копий</param>
            <param name="act">Нелинейная функция</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32)">
            <summary>
            Слой копирования
            </summary>
            <param name="inpShape">Размерность входа</param>
            <param name="count">Число копмрований</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.CopyistLayer.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.Dropout">
            <summary>
            Слой Dropout
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Dropout.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Dropout.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Dropout.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Dropout.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.Dropout.Random">
            <summary>
            Генератор случайных
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Dropout.#ctor(System.Single)">
            <summary>
            Слой Dropout
            </summary>
            <param name="dropProb">Вероятность разъединения с нейроном</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Dropout.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Dropout.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.Dropout.ToString">
            <summary>
            Описание слоя
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer">
            <summary>
            Полносвязный слой
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.W">
            <summary>
            Матрица весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.Bias">
            <summary>
            Вектор смещения гиперплоскости (поляризация нейронов)
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.ActivationFunction">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.AddDenInSqrt">
            <summary>
            Добавление к знаменателю
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.TrainableParameters">
            <summary>
            Количество параметров обучения
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.#ctor(System.Int32,System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,System.Random)">
            <summary>
            Полносвязный слой
            </summary>
            <param name="inputDimension">Размерность входа</param>
            <param name="outputDimension">Размерность выхода</param>
            <param name="f">Активационная функция</param>
            <param name="rnd">Генератор псевдослучайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,System.Random)">
            <summary>
            Полносвязный слой
            </summary>
            <param name="inputShape">Размерность входа</param>
            <param name="outputDimension">Размерность выхода</param>
            <param name="f">Активационная функция</param>
            <param name="rnd">Генератор псевдослучайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.#ctor(System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Полносвязный слой
            </summary>
            <param name="outputDimension">Размерность выхода</param>
            <param name="f">Активационная функция</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход слоя
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автодифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.GetParameters">
            <summary>
            Получение обучаемых параметров
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.InitWeights(System.Random)">
            <summary>
            Генерация новых коэффициентов
            </summary>
            <param name="random">Генератор псевдослучайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FeedForwardLayer.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.GroupLayer">
            <summary>
            Слой для работы с группами входов
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GroupLayer.#ctor(System.Int32,System.Int32)">
            <summary>
            Слой для работы с группами входов
            </summary>
            <param name="countGroupe">Число групп</param>
            <param name="outpEachGroupe">Число выходов в каждой группе</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GroupLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer">
            <summary>
            Линейный слой без смещения
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.ActivationFunction">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.#ctor(System.Int32,System.Int32,System.Double,System.Random)">
            <summary>
            Линейный слой без смещения
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Double,System.Random)">
            <summary>
            Линейный слой без смещения
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.#ctor(System.Int32)">
            <summary>
            Линейный слой без смещения
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.GetParameters">
            <summary>
            Возвращает обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.InitWeights(System.Random)">
            <summary>
            Генерация весовых коэффициентов
            </summary>
            <param name="random">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.ToString">
            <summary>
            Описание слоя
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LinearLayer.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.NonSeqBlockNet">
            <summary>
            Непоследовательный блок
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.NonSeqBlockNet.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.NonSeqBlockNet.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.NonSeqBlockNet.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.NonSeqBlockNet.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.NonSeqBlockNet.ActivationFunction">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.NonSeqBlockNet.#ctor">
            <summary>
            Непоследовательный блок
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.NonSeqBlockNet.#ctor(AI.DataStructs.Shapes.Shape3D,AI.DataStructs.Shapes.Shape3D,System.Collections.Generic.List{AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer})">
            <summary>
            Непоследовательный блок
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.NonSeqBlockNet.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.NonSeqBlockNet.ResetState">
            <summary>
            Сброс состояния слоя нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.NonSeqBlockNet.GetParameters">
            <summary>
            Получение обучаемых параметров
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.NonSeqBlockNet.InitWeights(System.Random)">
            <summary>
            Генерация весовых коэфициентов
            </summary>
            <param name="random">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.NonSeqBlockNet.ToString">
            <summary>
            Описание слоя
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.NonSeqBlockNet.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerL">
            <summary>
            Облегченный контроллер
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerL.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerL.function">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerL.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerL.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerL.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerL.#ctor(System.Int32,System.Int32,System.Double,System.Random)">
            <summary>
            Облегченный контроллер
            </summary>
            <param name="inputDimension">Размерность входа</param>
            <param name="outputDimension">Размерность выхода</param>
            <param name="initParamsStdDev">Среднеквадратичное отклонение</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerL.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Double,System.Random)">
            <summary>
            Облегченный контроллер
            </summary>
            <param name="inputShape">Размерность входа</param>
            <param name="outputDimension">Размерность выхода</param>
            <param name="initParamsStdDev">Среднеквадратичное отклонение</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerL.#ctor(System.Int32)">
            <summary>
            Облегченный контроллер
            </summary>
            <param name="outputDimension">Размерность выхода</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerL.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerL.ResetState">
            <summary>
            Сброс состояния нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerL.GetParameters">
            <summary>
            Возвращает обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerL.Generate(AI.DataStructs.Shapes.Shape3D,System.Random)">
            <summary>
            Генерация случ. весов для сети
            </summary>
            <param name="inpShape"></param>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerL.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerL.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerL.InitWeights(System.Random)">
            <summary>
            Инициализация слоя
            </summary>
            <param name="random">ГПСЧ</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerLResNet">
            <summary>
            Облегченный контроллер
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerLResNet.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerLResNet.function">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerLResNet.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerLResNet.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerLResNet.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerLResNet.FeatureCodeLen">
            <summary>
            Число признаков для кодирования кода позиции
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerLResNet.PositionEncoder">
            <summary>
            Метод кодирования позиции
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerLResNet.#ctor(System.Int32,System.Double,System.Random,System.Int32)">
            <summary>
            Облегченный контроллер
            </summary>
            <param name="inputDimension">Размерность входа</param>
            <param name="initParamsStdDev">Среднеквадратичное отклонение</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
            <param name="posSize">Длинна вектора, для кодирования позиции</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerLResNet.#ctor(AI.DataStructs.Shapes.Shape3D,System.Double,System.Random,System.Int32)">
            <summary>
            Облегченный контроллер
            </summary>
            <param name="inputShape">Размерность входа</param>
            <param name="initParamsStdDev">Среднеквадратичное отклонение</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
            <param name="posSize">Длинна вектора, для кодирования позиции</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerLResNet.#ctor(System.Int32)">
            <summary>
            Облегченный контроллер
            </summary>
            <param name="posSize">Длинна вектора, для кодирования позиции</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerLResNet.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerLResNet.ResetState">
            <summary>
            Сброс состояния нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerLResNet.GetParameters">
            <summary>
            Возвращает обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerLResNet.Generate(AI.DataStructs.Shapes.Shape3D,System.Random)">
            <summary>
            Генерация случ. весов для сети
            </summary>
            <param name="inpShape"></param>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerLResNet.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerLResNet.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.ControllerLResNet.InitWeights(System.Random)">
            <summary>
            Генерация весовых коэффициентов
            </summary>
            <param name="random">ГПСЧ</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer">
            <summary>
            Слой для создания и обучения векторов встранивания
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.ActivationFunction">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.#ctor(System.Int32,System.Int32)">
            <summary>
            Слой для создания и обучения векторов встранивания
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.#ctor(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Слой для создания и обучения векторов встранивания
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.InitWeights(System.Random)">
            <summary>
            Инициализация слоя
            </summary>
            <param name="random"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.GetParameters">
            <summary>
            Возвращает обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.ResetState">
            <summary>
            Сброс состояния нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.EmbedingLayer.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell">
            <summary>
            Обучаемый БИХ-фильтр
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.para">
            <summary>
            Основные параметры слоя
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.inputs">
            <summary>
            Основные параметры слоя
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.outputs">
            <summary>
            Основные параметры слоя
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.bias">
            <summary>
            Основные параметры слоя
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.outp">
            <summary>
            Основные параметры слоя
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.AddDenInSqrt">
            <summary>
            Добавление для расчета весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.ActivationFunction">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.Random">
            <summary>
            ГПСЧ для инициализации слоя
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.A">
            <summary>
            a - Коэффициенты фильтра
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.B">
            <summary>
            b - Коэффициенты фильтра
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.#ctor(System.Int32,System.Int32)">
            <summary>
            Обучаемый нейрофильтр
            </summary>
            <param name="aL">Коэф. а</param>
            <param name="bL">Коэф. б</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.#ctor(System.Int32,System.Int32,System.Random)">
            <summary>
            Обучаемый нейрофильтр
            </summary>
            <param name="aL">Коэф. а</param>
            <param name="bL">Коэф. б</param>
            <param name="random">Random</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход (фильтрация)
            </summary>
            <param name="input"></param>
            <param name="g"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.GetParameters">
            <summary>
            Получение параметров
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.InitWeights(System.Random)">
            <summary>
            Not used
            </summary>
            <param name="random"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.ResetState">
            <summary>
            Сброс состояния слоя нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterCell.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer">
            <summary>
            Обучаемый банк фильтров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.ActivationFunction">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.TrainableParameters">
            <summary>
            Teachable parameters
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.FilterCells">
            <summary>
            Фильтры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.#ctor(AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,System.Int32,System.Int32)">
            <summary>
            Обучаемый банк фильтров
            </summary>
            <param name="activation">Активационная функция</param>
            <param name="aL">Коэф. а</param>
            <param name="bL">Коэф. б</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.#ctor(System.Int32,System.Int32)">
            <summary>
            Обучаемый банк фильтров
            </summary>
            <param name="aL">Коэф. а</param>
            <param name="bL">Коэф. б</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.#ctor(System.Int32,System.Int32,System.Int32,System.Random)">
            <summary>
            Обучаемый банк фильтров
            </summary>
            <param name="countF"></param>
            <param name="aL"></param>
            <param name="bL"></param>
            <param name="random"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прохождение банка
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.InitWeights(System.Random)">
            <summary>
            Инициализация
            </summary>
            <param name="random"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.GetParameters">
            <summary>
            Получение обучаемых параметров
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.ResetState">
            <summary>
            Сброс состояния слоя нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.FilterLayer.OnlyUse">
            <summary>
            Только для использования
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer">
            <summary>
            Слой GRU
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.TrainableParameters">
            <summary>
            Обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.#ctor(System.Int32,System.Int32,System.Random)">
            <summary>
            Слой GRU
            </summary>
            <param name="inputDimension">Размерность входа</param>
            <param name="outputDimension">Размерность выхода</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Random)">
            <summary>
            Слой GRU
            </summary>
            <param name="inputShape">Размерность входа</param>
            <param name="outputDimension">Размерность выхода</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.#ctor(System.Int32)">
            <summary>
            Слой GRU
            </summary>
            <param name="outputDimension">Размерность выхода</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.ResetState">
            <summary>
            Сброс состояния нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.GetParameters">
            <summary>
            Возвращает обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.InitWeights(System.Random)">
            <summary>
            Генерация случ. весов для сети
            </summary>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRULayer.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression">
            <summary>
            Слой GRU
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.TrainableParameters">
            <summary>
            Обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.#ctor(System.Int32,System.Int32,System.Random)">
            <summary>
            Слой GRU
            </summary>
            <param name="inputDimension">Размерность входа</param>
            <param name="outputDimension">Размерность выхода</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Random)">
            <summary>
            Слой GRU
            </summary>
            <param name="inputShape">Размерность входа</param>
            <param name="outputDimension">Размерность выхода</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.#ctor(System.Int32)">
            <summary>
            Слой GRU
            </summary>
            <param name="outputDimension">Размерность выхода</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.ResetState">
            <summary>
            Сброс состояния нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.GetParameters">
            <summary>
            Возвращает обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.InitWeights(System.Random)">
            <summary>
            Генерация случ. весов для сети
            </summary>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.GRURegression.OnlyUse">
            <summary>
            Только использование
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer">
            <summary>
            LSTM слой
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.#ctor(System.Int32,System.Int32,System.Double,System.Random)">
            <summary>
            LSTM слой
            </summary>
            <param name="inputDimension">Размерность входа</param>
            <param name="outputDimension">Размерность выхода</param>
            <param name="initParamsStdDev">Среднеквадратичное отклонение</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Double,System.Random)">
            <summary>
            LSTM слой
            </summary>
            <param name="inputShape">Размерность входа</param>
            <param name="outputDimension">Размерность выхода</param>
            <param name="initParamsStdDev">Среднеквадратичное отклонение</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.#ctor(System.Int32)">
            <summary>
            LSTM слой
            </summary>
            <param name="outputDimension">Размерность выхода</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.ResetState">
            <summary>
            Сброс состояния нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.GetParameters">
            <summary>
            Возвращает обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.InitWeights(System.Random)">
            <summary>
            Генерация случ. весов для сети
            </summary>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayer.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1">
            <summary>
            Слой LSTM (inpGate = 1.0 - forgetGate)
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.#ctor(System.Int32,System.Int32,System.Double,System.Random)">
            <summary>
            Слой LSTM (inpGate = 1.0 - forgetGate)
            </summary>
            <param name="inputDimension">Размерность входа</param>
            <param name="outputDimension">Размерность выхода</param>
            <param name="initParamsStdDev">Среднеквадратичное отклонение</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Double,System.Random)">
            <summary>
            Слой LSTM (inpGate = 1.0 - forgetGate)
            </summary>
            <param name="inputShape">Размерность входа</param>
            <param name="outputDimension">Размерность выхода</param>
            <param name="initParamsStdDev">Среднеквадратичное отклонение</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.#ctor(System.Int32)">
            <summary>
            Слой LSTM (inpGate = 1.0 - forgetGate)
            </summary>
            <param name="outputDimension">Размерность выхода</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.ResetState">
            <summary>
            Сброс состояния нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.GetParameters">
            <summary>
            Возвращает обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.InitWeights(System.Random)">
            <summary>
            Генерация случ. весов для сети
            </summary>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerL1.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection">
            <summary>
            Соединения с "глазками" слоя долговременной кратковременной памяти (LSTM)
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.#ctor(System.Int32,System.Int32,System.Double,System.Random)">
            <summary>
            Соединения с "глазками" слоя долговременной кратковременной памяти (LSTM)
            </summary>
            <param name="inputDimension">Размерность входа</param>
            <param name="outputDimension">Размерность выхода</param>
            <param name="initParamsStdDev">Среднеквадратичное отклонение</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Double,System.Random)">
            <summary>
            Соединения с "глазками" слоя долговременной кратковременной памяти (LSTM)
            </summary>
            <param name="inputShape">Размерность входа</param>
            <param name="outputDimension">Размерность выхода</param>
            <param name="initParamsStdDev">Среднеквадратичное отклонение</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.#ctor(System.Int32)">
            <summary>
            Соединения с "глазками" слоя долговременной кратковременной памяти (LSTM)
            </summary>
            <param name="outputDimension">Размерность выхода</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.ResetState">
            <summary>
            Сброс состояния нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.GetParameters">
            <summary>
            Возвращает обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.InitWeights(System.Random)">
            <summary>
            Генерация случ. весов для сети
            </summary>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.LSTMLayerPeepholeConnection.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.NeuralСontroller">
            <summary>
            Нейросетевой контроллер
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.NeuralСontroller.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.NeuralСontroller.function">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.NeuralСontroller.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.NeuralСontroller.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.NeuralСontroller.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.NeuralСontroller.#ctor(System.Int32,System.Int32,System.Double,System.Random)">
            <summary>
            Нейросетевой контроллер
            </summary>
            <param name="inputDimension">Размерность входа</param>
            <param name="outputDimension">Размерность выхода</param>
            <param name="initParamsStdDev">Среднеквадратичное отклонение</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.NeuralСontroller.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,System.Double,System.Random)">
            <summary>
            Нейросетевой контроллер
            </summary>
            <param name="inputShape">Размерность входа</param>
            <param name="outputDimension">Размерность выхода</param>
            <param name="initParamsStdDev">Среднеквадратичное отклонение</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.NeuralСontroller.#ctor(System.Int32)">
            <summary>
            Нейросетевой контроллер
            </summary>
            <param name="outputDimension">Размерность выхода</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.NeuralСontroller.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.NeuralСontroller.ResetState">
            <summary>
            Сброс состояния нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.NeuralСontroller.GetParameters">
            <summary>
            Возвращает обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.NeuralСontroller.Generate(AI.DataStructs.Shapes.Shape3D,System.Random)">
            <summary>
            Генерация случ. весов для сети
            </summary>
            <param name="inpShape"></param>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.NeuralСontroller.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.NeuralСontroller.ToString">
            <summary>
            Описание слоя
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.NeuralСontroller.InitWeights(System.Random)">
            <summary>
            Инициализация весовых коэффициентов случайными числами
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer">
            <summary>
            Простая рекурентная сеть
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.AddDenInSqrt">
            <summary>
            Добавление значения в знаменатель под корень при инициализации весов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.ActivationFunction">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.#ctor(System.Int32,System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,System.Double,System.Random)">
            <summary>
            Простая рекурентная сеть
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.#ctor(AI.DataStructs.Shapes.Shape3D,System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,System.Double,System.Random)">
            <summary>
            Простая рекурентная сеть
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.#ctor(System.Int32,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Простая рекурентная сеть
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="g">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.ResetState">
            <summary>
            Сброс состояния нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.GetParameters">
            <summary>
            Возвращает обучаемые параметры
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.InitWeights(System.Random)">
            <summary>
            Генерация весовых коэффициентов
            </summary>
            <param name="random">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.ToString">
            <summary>
            Описание слоя
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Layers.RNNLayer.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Loss.CrossEntropyWithSoftmax">
            <summary>
            Расчет ошибки кросс-энтропии при условии, что на выходе Softmax
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.CrossEntropyWithSoftmax.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="actualOutput">Реальный вызод</param>
            <param name="targetOutput">Целевой(идеальный) выход</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.CrossEntropyWithSoftmax.Measure(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Значение ошибки
            </summary>
            <param name="actualOutput">Реальный вызод</param>
            <param name="targetOutput">Целевой(идеальный) выход</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss">
            <summary>
            Интерфейс функции ошибки
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="actualOutput"></param>
            <param name="targetOutput"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.ILoss.Measure(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Значение ошибки
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Loss.Loss4Pow">
            <summary>
            Ошибка 4я степень, для контрастирования выбросов
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.Loss4Pow.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="actualOutput">Реальный вызод</param>
            <param name="targetOutput">Целевой(идеальный) выход</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.Loss4Pow.Measure(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Значение ошибки
            </summary>
            <param name="actualOutput">Реальный вызод</param>
            <param name="targetOutput">Целевой(идеальный) выход</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Loss.LossArgMax">
            <summary>
            Аргмакс (нереализован)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.LossArgMax.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="actualOutput">Реальный вызод</param>
            <param name="targetOutput">Целевой(идеальный) выход</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.LossArgMax.Measure(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Значение ошибки
            </summary>
            <param name="actualOutput">Реальный вызод</param>
            <param name="targetOutput">Целевой(идеальный) выход</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Loss.CrossEntropy">
            <summary>
            Перекрестная энтропия
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.CrossEntropy.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="actualOutput">Реальный вызод</param>
            <param name="targetOutput">Целевой(идеальный) выход</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.CrossEntropy.Measure(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Значение ошибки
            </summary>
            <param name="actual">Реальный вызод</param>
            <param name="target">Целевой(идеальный) выход</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Loss.LossMeanSqrSqrt">
            <summary>
            Средний квадрат отклонения
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.LossMeanSqrSqrt.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="actualOutput">Реальный вызод</param>
            <param name="targetOutput">Целевой(идеальный) выход</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.LossMeanSqrSqrt.Measure(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Значение ошибки
            </summary>
            <param name="actualOutput">Реальный вызод</param>
            <param name="targetOutput">Целевой(идеальный) выход</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Loss.LossMSE">
            <summary>
            Средний квадрат ошибки
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.LossMSE.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="actualOutput">Реальный вызод</param>
            <param name="targetOutput">Целевой(идеальный) выход</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.LossMSE.Measure(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Значение ошибки
            </summary>
            <param name="actualOutput">Реальный вызод</param>
            <param name="targetOutput">Целевой(идеальный) выход</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Loss.LossSumOfSquares">
            <summary>
            Сумма квадратов отклонения
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.LossSumOfSquares.Backward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Обратный проход
            </summary>
            <param name="actualOutput">Реальный вызод</param>
            <param name="targetOutput">Целевой(идеальный) выход</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Loss.LossSumOfSquares.Measure(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Значение ошибки
            </summary>
            <param name="actualOutput">Реальный вызод</param>
            <param name="targetOutput">Целевой(идеальный) выход</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Models.IBackwardRun">
            <summary>
            Интерфейс для запуска расчета производных по цепному правилу
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Models.IBackwardRun.StartCalc">
            <summary>
            Запуск расчета производных
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph">
            <summary>
            Граф автоматического дифференцирования
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.IsBackward">
            <summary>
            Просчитывать ли обратный проход со взятием производных
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.Backprop">
            <summary>
            Элементы (собранные делегаты) для обратного прохода
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.Backward">
            <summary>
            Обратный проход (дифференцирование)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.Restart(System.Boolean)">
            <summary>
            Перезапуск
            </summary>
            <param name="isBacward">Выполнять ли обратны проход</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.Copyist(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32)">
            <summary>
            Копирование тензора
            </summary>
            <param name="value">Тензор</param>
            <param name="count">Число копий</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.ScalarProduct(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Скалярное произведение векторов
            </summary>
            <param name="v1">Первый вектор</param>
            <param name="v2">Второй вектор</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.ConcatinateVectors(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Конкатенация двух векторов
            </summary>
            <param name="v1">Первый вектор</param>
            <param name="v2">Второй вектор</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.ConcatinateVectors(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Конкатенация (последовательное соединение) векторов
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.DeConcatinateOne(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Нарезка вектора по одному элементу
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.Activate(AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Активационная функция
            </summary>
            <param name="function">Активационная, нелинейная функция</param>
            <param name="t">Тензор, на котором применить активацию</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.AddCicleBuff(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32)">
            <summary>
            Добавить элемент
            </summary>
            <param name="old">Буфер старых значений</param>
            <param name="inp">Добавляемый элемент</param>
            <param name="len">Емкость буфера</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.Mul(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Перемножение матриц
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.MulMV(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Умножение матрицы на вектор-столбец
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.Add(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Сумма 2х тензоров
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.AddN(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Сумма тензора и числа
            </summary>
            <param name="tensor">Тензор</param>
            <param name="number">Число</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.Add(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Сумма 3х тензоров
            </summary>
            <param name="t1">Tensor #1</param>
            <param name="t2">Tensor #2</param>
            <param name="t3">Tensor #3</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.OneMinus(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            1-m
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.Subtract(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Вычитание
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.MulMatrixByNumber(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Single)">
            <summary>
            Умножение на число
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.MulMatrixByNumber(System.Single,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Умножение на число
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.Invers(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Инверсия -m
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.AdamarMul(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Поэлементное(адамарово) произведение тензоров
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.Convolution(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Свертка без нейрона смещения
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.Convolution(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Свертка
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.MaxPooling(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32,System.Int32)">
            <summary>
            Подвыборка 2D
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.ReShape(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.DataStructs.Shapes.Shape3D,System.Single)">
            <summary>
            Изменение формы тензора
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.UnPooling(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32,System.Int32)">
            <summary>
            UnPooling 2D
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.Upsampling2DBicubic(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32,System.Int32)">
            <summary>
            Апсемплинг с бикубической интерполяцией
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.DropOut(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Single,System.Single,System.Random)">
            <summary>
            Dropout
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.ImRealCross(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Смешивание реальной и мнимой частей для создания новой реальной и мнимой частей
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.DeepJoin(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Соединение глубины тензора
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.DeepSplit(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32)">
            <summary>
            Разделение тензора по глубине
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.FeedForwardLayer(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Полносвязный слой
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.FeedforwardLinLayer(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Линейный полносвязный слой
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph.GRULayer(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit,AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit,AI.ML.NeuralNetwork.CoreNNW.Activations.TanhUnit)">
            <summary>
            Слой gru
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Models.Runnable">
            <summary>
            Класс для запуска расчета производных по цепному правилу
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Models.Runnable.StartCalc">
            <summary>
            Запуск расчета
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.NNValue">
            <summary>
            Основной класс для хранения данных о нейронной сети может быть векторои, матрицей или же тензором 3-го ранга.
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNValue.Data">
            <summary>
            Массив элементов, данные нейросети
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNValue.DifData">
            <summary>
            Массив частных производных
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNValue.StepCache">
            <summary>
            Массив кэша оптимизаторов использующих один момент
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNValue.StepCache2">
            <summary>
            Массив кэша оптимизаторов использующих два момента, например Адам
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNValue.Shape">
            <summary>
            Форма тензора
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNValue.Item(System.Int32)">
            <summary>
            Получить элемент по индексу
            </summary>
            <param name="i">Индекс</param>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNValue.Item(System.Int32,System.Int32)">
            <summary>
            Получение элемента по индексу высоты и ширины
            </summary>
            <param name="h">Индекс высоты</param>
            <param name="w">Индекс ширины</param>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNValue.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Получение элемента по индексу высоты, ширины и глубины
            </summary>
            <param name="h">Индекс высоты</param>
            <param name="w">Индекс ширины</param>
            <param name="d">Индекс глубины</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Создание основного класса как тензора 3-го ранга
            </summary>
            <param name="height">Ширина</param>
            <param name="width">Ширина</param>
            <param name="depth">Глубина</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.#ctor(AI.DataStructs.Shapes.Shape3D)">
            <summary>
            Создание основного класса как тензора 3-го ранга
            </summary>
            <param name="shape">Форма тензора</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.#ctor(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Создать переменную нейронной сети на базе алгебраической структуры
            </summary>
            <param name="algebraicStructure"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.#ctor(System.Double)">
            <summary>
            Создание одномерной переменной нейронной сети с заданным значением
            </summary>
            <param name="value">Значение</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.op_Division(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Double)">
            <summary>
            Деление тензора ПРОИЗВОДНЫХ на число
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Like0">
            <summary>
            Аналогичный тензор (такая же форма, заполненная нулями)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.ToTensor">
            <summary>
            Перевод в AI Тензор
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.ToMatrix">
            <summary>
            Перевод в AI Матрицу
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.ToVector">
            <summary>
            Перевод в AI Вектор
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.ToTxts">
            <summary>
            Перевод матрицы в массив строк
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.ToTxtsNoInfo">
            <summary>
            Перевод матрицы в массив строк
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Gauss(System.Random)">
            <summary>
            Гауссово распределение
            </summary>
            <returns>Возвращает норм. распред величину СКО = 1, M = 0</returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Clone">
            <summary>
            Клонирование тензора
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.ResetDw">
            <summary>
            Сброс производных
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.ResetStepCache">
            <summary>
            Сброс кэша
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Transpose(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Транспонирование
            </summary>
            <param name="m">Матрица</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Random(System.Int32,System.Int32,System.Double,System.Random)">
            <summary>
            Заполнение тензора случайными числами
            </summary>
            <param name="h">Ширина</param>
            <param name="w"> Высота</param>
            <param name="initParamsStdDev">Среднеквадратичное отклонение</param>
            <param name="rnd">Генератор псевдослуч. чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Random(System.Int32,System.Int32,System.Int32,System.Double,System.Random)">
            <summary>
            Заполнение тензора случайными числами
            </summary>
            <param name="h">Ширина</param>
            <param name="w"> Высота</param>
            <param name="d">Глубина</param>
            <param name="initParamsStdDev">Среднеквадратичное отклонение</param>
            <param name="rnd">Генератор псевдослуч. чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.RandomR(System.Int32,System.Int32,System.Int32,System.Double,System.Random)">
            <summary>
            Заполнение тензора случайными числами
            </summary>
            <param name="h">Ширина</param>
            <param name="w"> Высота</param>
            <param name="d">Глубина</param>
            <param name="initParamsStdDev">Среднеквадратичное отклонение</param>
            <param name="rnd">Генератор псевдослуч. чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Ident(System.Int32)">
            <summary>
            Создание единичной матрицы
            </summary>
            <param name="dim">Размерность матрицы</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Uniform(System.Int32,System.Int32,System.Double)">
            <summary>
            Создание матрицы заполненной одним числом
            </summary>
            <param name="h"> Высота</param>
            <param name="w">Ширина</param>
            <param name="s">Число</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Uniform(AI.DataStructs.Shapes.Shape3D,System.Double)">
            <summary>
            Создание тензора заполненного одним значением
            </summary>
            <param name="shape">Форма тензора</param>
            <param name="s">Значение</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Ones(System.Int32,System.Int32)">
            <summary>
            Заполнение тензора единицами
            </summary>
            <param name="h"> Высота</param>
            <param name="w">Ширина</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Ones(AI.DataStructs.Shapes.Shape3D)">
            <summary>
            Заполнение тензора единицами
            </summary>
            <param name="shape"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Ones(System.Int32)">
            <summary>
            Заполнение тензора единицами
            </summary>
            <param name="h"> Высота</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.NegativeOnes(System.Int32,System.Int32)">
            <summary>
            Заполнение тензора -1
            </summary>
            <param name="h"> Высота</param>
            <param name="w">Ширина</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.ReShape(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.DataStructs.Shapes.Shape3D)">
            <summary>
            Изменение формы тензора
            </summary>
            <param name="value"></param>
            <param name="newShape"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">Содержит исключение "Изменение формы невозможно, т.к. объемы не совпадают"</exception>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.SaveAsText(System.String)">
            <summary>
            Сохранение тензора в текстовом формате
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.SaveAsTextNoInfo(System.String)">
            <summary>
            Сохранение без тензора без описания
            </summary>
            <param name="path">Путь для сохранения</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Save(System.String)">
            <summary>
            Сохранить NNValue в файл
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Save(System.IO.Stream)">
            <summary>
            Сохранить NNValue в поток
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.GetBytes">
            <summary>
            Представить массивом байт
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Load(System.String)">
            <summary>
            Загрузить из файла
            </summary>
            <param name="path">Путь до файла</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.Load(System.IO.Stream)">
            <summary>
            Загрузить из потока
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.FromBytes(System.Byte[])">
            <summary>
            Инициализировать тензор массивом байт
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.FromDataStream(AI.DataStructs.InMemoryDataStream)">
            <summary>
            Прочитать тензор из потока
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.OnlyUse">
            <summary>
            Модификация (только использование), убирает массивы кэшей и данные производных
            что облегчает модель в 4 раза
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.InitTrainData">
            <summary>
            Добавляет массивы кэшей и данные производных, если те были удалены(например вследствии вызова метода OnlyUse() ), что позволяет снова учить сеть
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.ToString">
            <summary>
            Вывод тензора в строку
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNValue.ToString(System.Globalization.NumberFormatInfo)">
            <summary>
            Вывод тензора в строку
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.NNW">
            <summary>
            Нейронная сеть
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNW.Layers">
            <summary>
            List of network layers
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNW.InputShape">
            <summary>
            Размерность входа
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNW.OutputShape">
            <summary>
            Размерность выхода
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNW.TrainableParameters">
            <summary>
            Число обучаемых параметров
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.#ctor(System.Int32)">
            <summary>
            Нейронная сеть
            </summary>
            <param name="seed">seed для генератора псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.#ctor(System.Collections.Generic.List{AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer})">
            <summary>
            Нейронная сеть
            </summary>
            <param name="layers">Список слоев</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.AddNewLayer(AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer)">
            <summary>
            Добавление НОВОГО слоя в нейронную сеть (веса перезаписываются)
            </summary>
            <param name="layer">Слой</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.AddNewLayer(AI.DataStructs.Shapes.Shape3D,AI.ML.NeuralNetwork.CoreNNW.Layers.Base.ILayer)">
            <summary>
            Добавление НОВОГО слоя в нейронную сеть (веса перезаписываются)
            </summary>
            <param name="inpShape">Форма тензора входа</param>
            <param name="layer">Слой</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="graph">Граф атодифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.Forward(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Прямой проход
            </summary>
            <param name="input">Вход</param>
            <param name="graph">Граф атодифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.ResetState">
            <summary>
            Сброс состояния (необходим для рекуррентных нейронных сетей)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.GetParameters">
            <summary>
            Получение тренируемых параметров сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.OnlyUse">
            <summary>
            Только использование, удаляются все кэши и производные, сеть становится, примерно, в 4 раза легче
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.Save(System.String)">
            <summary>
            Сохранение сети в файл
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.Save(System.IO.Stream)">
            <summary>
            Сохранение сети в поток
            </summary>
            <param name="stream">Поток</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.Load(System.String)">
            <summary>
            Загрузка сети из файла
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNW.Load(System.IO.Stream)">
            <summary>
            Загрузка сети из потока
            </summary>
            <param name="stream">Поток</param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU">
            <summary>
            Граф автоматического дифференцирования реализация для ЦП
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.IsBackward">
            <summary>
            Просчитывать ли обратный проход со взятием производных
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.Backprop">
            <summary>
            Элементы (собранные делегаты) для обратного прохода (функции расчета градиента)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.#ctor">
            <summary>
            Граф автоматического дифференцирования реализация для ЦП
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.#ctor(System.Boolean)">
            <summary>
            Граф автоматического дифференцирования реализация для ЦП
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.Backward">
            <summary>
            Обратный проход (дифференцирование)
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.Restart(System.Boolean)">
            <summary>
            Перезапуск графа
            </summary>
            <param name="isBacward">Просчитывать ли обратный проход со взятием производных</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.Copyist(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32)">
            <summary>
            Копирование тензора
            </summary>
            <param name="value">Тензор</param>
            <param name="count">Число копий</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.ScalarProduct(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Скалярное произведение векторов
            </summary>
            <param name="v1">Первый вектор</param>
            <param name="v2">Второй вектор</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.AddCicleBuff(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32)">
            <summary>
            Добавить элемент
            </summary>
            <param name="old">Буфер старых значений</param>
            <param name="inp">Добавляемый элемент</param>
            <param name="len">Емкость буфера</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.ConcatinateVectors(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Конкатенация (последовательное соединение) векторов
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.DeConcatinateOne(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Нарезка вектора по одному элементу
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.ConcatinateVectors(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Конкатенация двух векторов
            </summary>
            <param name="v1">Первый вектор</param>
            <param name="v2">Второй вектор</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.Activate(AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Активационная функция
            </summary>
            <param name="function">Function activation</param>
            <param name="t">Тензор, на котором применить активацию</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.Mul(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Перемножение матриц
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.MulMV(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Умножение матрицы на вектор-столбец
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.Add(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Сумма 2х тензоров
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.Add(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Сумма 3х тензоров
            </summary>
            <param name="t1">Tensor #1</param>
            <param name="t2">Tensor #2</param>
            <param name="t3">Tensor #3</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.OneMinus(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            1-m
            </summary>
            <param name="m">Тензор входных данных</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.Subtract(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Вычитание
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.MulMatrixByNumber(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Single)">
            <summary>
            Умножение на число
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.MulMatrixByNumber(System.Single,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Умножение на число
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.Invers(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Инверсия -m
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.AdamarMul(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Поэлементное(адамарово) произведение тензоров
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.Convolution(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Свертка без нейрона смещения
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.Convolution(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Свертка
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.MaxPooling(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32,System.Int32)">
            <summary>
            Подвыборка 2D
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.ReShape(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.DataStructs.Shapes.Shape3D,System.Single)">
            <summary>
            Изменение формы тензора
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.UnPooling(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32,System.Int32)">
            <summary>
            UnPooling 2D
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.Upsampling2DBicubic(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32,System.Int32)">
            <summary>
            Апсемплинг с бикубической интерполяцией
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.AddN(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Сумма тензора и числа
            </summary>
            <param name="tensor">Тензор</param>
            <param name="number">Число</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.DropOut(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Single,System.Single,System.Random)">
            <summary>
            Dropout
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.DeepSplit(AI.ML.NeuralNetwork.CoreNNW.NNValue,System.Int32)">
            <summary>
            Разделение тензора на несколько тензоров по глубине
            </summary>
            <param name="data">Тензор входа</param>
            <param name="countLayersInSlice">Количество слоев в одном срезе</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.ImRealCross(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Смешивание реальной и мнимой частей для создания новой реальной и мнимой частей
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.DeepJoin(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Соединение глубины тензора
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.FeedForwardLayer(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Activations.IActivation)">
            <summary>
            Полносвязный слой
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.GRULayer(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit,AI.ML.NeuralNetwork.CoreNNW.Activations.SigmoidUnit,AI.ML.NeuralNetwork.CoreNNW.Activations.TanhUnit)">
            <summary>
            Слой gru
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.NNWGraphCPU.FeedforwardLinLayer(AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue,AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Линейный полносвязный слой
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Train.CheckPoints.DirectoryCheckPointSaver">
            <summary>
            Директория для сохранения чекпоинтов нейросети
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.CheckPoints.DirectoryCheckPointSaver.DirectoryPath">
            <summary>
            Путь до директории
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.CheckPoints.DirectoryCheckPointSaver.#ctor(System.String)">
            <summary>
            Директория для сохранения чекпоинтов нейросети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.CheckPoints.DirectoryCheckPointSaver.Save(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single)">
            <summary>
            Сохранение чекпоинта в папку
            </summary>
            <param name="net"></param>
            <param name="val"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.CheckPoints.DirectoryCheckPointSaver.ToString">
            <summary>
            Перевод в строку
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Train.CheckPoints.FileCheckPointSaver">
            <summary>
            Сохранение чекпоинта нейронной сети в файл
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.CheckPoints.FileCheckPointSaver.FilePath">
            <summary>
            Путь до файла
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.CheckPoints.FileCheckPointSaver.#ctor(System.String)">
            <summary>
            Сохранение чекпоинта нейронной сети в файл
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.CheckPoints.FileCheckPointSaver.Save(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single)">
            <summary>
            Сохранение нейросети
            </summary>
            <param name="net"></param>
            <param name="val"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.CheckPoints.FileCheckPointSaver.ToString">
            <summary>
            Строковое представление
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Train.CheckPoints.ICheckPointSaver">
            <summary>
            Интерфейс создания чекпоинтов
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.CheckPoints.ICheckPointSaver.Save(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single)">
            <summary>
            Сохранение нейронной сети
            </summary>
            <param name="net">Нейросеть</param>
            <param name="val">Метрика на валидационной выборке</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Train.ITrainer">
            <summary>
            Интерфейс учителя
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.ITrainer.Train(System.Int32,System.Int32,System.Single,AI.ML.NeuralNetwork.CoreNNW.INetwork,AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet,System.Single)">
            <summary>
            Обучение нейронной сети
            </summary>
            <param name="epochesToPass">Число эпох</param>
            /// <param name="batchSize">Размер подвыборки</param>
            <param name="learningRate">Скорость обучения</param>
            <param name="network">Нейронная сеть</param>
            <param name="data">Выборка</param>
            <param name="minLoss">Минимальное значение ошибки</param>
            <returns>Ошибка</returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.ITrainer.TrainAsync(System.Int32,System.Int32,System.Single,AI.ML.NeuralNetwork.CoreNNW.INetwork,AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet,System.Single,System.Threading.CancellationToken)">
            <summary>
            Асинхронное обучение нейронной сети
            </summary>
            <param name="epochesToPass">Число эпох</param>
            <param name="batchSize">Размер подвыборки</param>
            <param name="learningRate">Скорость обучения</param>
            <param name="network">Нейронная сеть</param>
            <param name="data">Выборка</param>
            <param name="minLoss">Минимальное значение ошибки</param>
            <param name="cancellationToken">Токен завершения</param>
            <returns>Ошибка</returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer">
            <summary>
            Класс "учителя" для нейронной сети
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.L1Regularization">
            <summary>
            Коэффициент регуляризации L1, если он равен 0 то обучение без L1 регуляризации
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.L2Regularization">
            <summary>
            Коэффициент регуляризации L2, если он равен 0 то обучение без L2 регуляризации
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.Optimizer">
            <summary>
            Метод обучения SGD, Adam и др.
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.GradientClipValue">
            <summary>
            Ограничение градиента, по-умолчанию 3
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.Info">
            <summary>
            Обучение нейронной сети information
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.IsBusy">
            <summary>
            True, если в настоящее время обучается другая модель
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.DoOverfitStop">
            <summary>
            Стоит ли прекращать обучение при переобучении
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.DoCheckPointSave">
            <summary>
            Стоит ли делать промежуточные сохранение
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.CheckPointSaver">
            <summary>
            Метод создания промежуточных сохранений
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.MetricsMin">
            <summary>
            Минимальное значение для метрик, уменьшающееся по мере повышения качества модели.
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.MetricsMax">
            <summary>
            Максимальное значение для метрики, которое увеличивается с повышением качества модели.
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.Metrics">
            <summary>
            Метрика
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.ReportType">
            <summary>
            Тип отчета
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.ControlFunction">
            <summary>
            Функция, управляющая обучением нейронной сети. Если она оценивается как «истина», обучение будет остановлено.
            Функция следующего вида "bool Function (INetwork network, TrainInfo info, float bestVal)"
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.#ctor">
            <summary>
            Создание "учителя" для нейронной сети
            </summary> 
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.#ctor(AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph)">
            <summary>
            Создание "учителя" для нейронной сети
            </summary> 
            <param name="graph">Граф автоматического дифференцирования</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.#ctor(AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph,AI.ML.NeuralNetwork.CoreNNW.Optimizers.IOptimizer)">
            <summary>
            Создание "учителя" для нейронной сети
            </summary> 
            <param name="graph">Граф автоматического дифференцирования</param>
            <param name="optimizer">Оптимизатор</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.#ctor(AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph,AI.ML.NeuralNetwork.CoreNNW.Optimizers.IOptimizer,System.Int32)">
            <summary>
            Создание "учителя" для нейронной сети
            </summary> 
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.Train(System.Int32,System.Int32,System.Single,AI.ML.NeuralNetwork.CoreNNW.INetwork,AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet,System.Single)">
            <summary>
            Обучение нейронной сети
            </summary>
            <param name="epochesToPass">Число эпох</param>
            <param name="batchSize">Размер подвыборки</param>
            <param name="learningRate">Скорость обучения</param>
            <param name="network">Нейронная сеть</param>
            <param name="data">Выборка</param>
            <param name="minLoss">Минимальное значение ошибки</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.TrainAsync(System.Int32,System.Int32,System.Single,AI.ML.NeuralNetwork.CoreNNW.INetwork,AI.ML.NeuralNetwork.CoreNNW.DataStructs.IDataSet,System.Single,System.Threading.CancellationToken)">
            <summary>
            Обучение нейронной сети
            </summary>
            <param name="epochesToPass">Число эпох</param>
            <param name="batchSize">Размер подвыборки</param>
            <param name="learningRate">Скорость обучения</param>
            <param name="network">Нейронная сеть</param>
            <param name="data">Выборка</param>
            <param name="minLoss">Минимальное значение ошибки</param>
            <param name="cancellationToken">Токен для отмены асинхронной операции</param>
        </member>
        <member name="E:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.ReportElementCreated">
            <summary>
            Вызывается при создании нового элемента отчета
            </summary>
        </member>
        <member name="E:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.EpochPassed">
            <summary>
            Вызывается при прохождении эпохи обучения
            </summary>
        </member>
        <member name="E:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.TrainingStarted">
            <summary>
            Вызывается в начале обучения
            </summary>
        </member>
        <member name="E:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.TrainingFinished">
            <summary>
            Вызывается в конце обучения
            </summary>
        </member>
        <member name="E:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.TrainingStopped">
            <summary>
            Вызывается, когда обучение сети останавливается без завершения всех эпох
            </summary>
        </member>
        <member name="E:AI.ML.NeuralNetwork.CoreNNW.Train.Trainer.TrainingCancelled">
            <summary>
            Вызовы, когда обучение сети отменяется токеном
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Train.TrainInfo">
            <summary>
            Информация об обучении нейронной сети
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.TrainInfo.ValidationLoss">
            <summary>
            Ошибка валидации
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.TrainInfo.TrainLoss">
            <summary>
            Ошибка обучения
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Train.TrainInfo.TestLoss">
            <summary>
            Ошибка на тестовой выборке
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Train.TrainInfo.#ctor">
            <summary>
            Данные обучения нейронной сети
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adadelta">
            <summary>
            Adadelta
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adadelta.Reset">
            <summary>
            Сброс параметров обучения нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adadelta.UpdateModelParams(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Обновление параметров модели
            </summary>
            <param name="network">Нейронная сеть</param>
            <param name="learningRate">Скорость обучения</param>
            <param name="gradClip">Максимальное значение градиента по модулю</param>
            <param name=" gradG">Усиление градиента</param>
            <param name="L1">Коэф. L1 регуляризации</param>
            <param name="L2"> Regularization coefficient L2 </param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adagrad">
            <summary>
            Adagrad
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adagrad.Reset">
            <summary>
            Сброс параметров обучения нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adagrad.UpdateModelParams(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Обновление параметров модели
            </summary>
            <param name="network">Нейронная сеть</param>
            <param name="learningRate">Скорость обучения</param>
            <param name="gradClip">Максимальное значение градиента по модулю</param>
            <param name="kG">Усиление градиента</param>
            <param name="L1">Коэф. L1 регуляризации</param>
            <param name="L2"> Regularization coefficient L2 </param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adam">
            <summary>
            Adam
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adam.#ctor(System.Single,System.Single)">
            <summary>
            Adam
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adam.UpdateModelParams(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Обновление параметров модели
            </summary>
            <param name="network">Нейронная сеть</param>
            <param name="learningRate">Скорость обучения</param>
            <param name="gradClip">Максимальное значение градиента по модулю</param>
            <param name="kG">Усиление градиента</param>
            <param name="L1">Коэф. L1 регуляризации</param>
            <param name="L2">Коэф. L2 регуляризации</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adam.Reset">
            <summary>
            Сброс параметров обучения нейронной сети
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adamax">
            <summary>
            Adamax
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adamax.#ctor">
            <summary>
            Adamax
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adamax.UpdateModelParams(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Обновление параметров модели
            </summary>
            <param name="network">Нейронная сеть</param>
            <param name="learningRate">Скорость обучения</param>
            <param name="gradClip">Максимальное значение градиента по модулю</param>
            <param name="kG">Усиление градиента</param>
            <param name="L1">Коэф. L1 регуляризации</param>
            <param name="L2">Коэф. L2 регуляризации</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Adamax.Reset">
            <summary>
            Сброс параметров обучения нейронной сети
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Optimizers.IOptimizer">
            <summary>
            Оптимизатор
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.IOptimizer.UpdateModelParams(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Обновление параметров
            </summary>
            <param name="network">Нейронная сеть</param>
            <param name="learningRate">Скорость обучения</param>
            <param name="gradClip"> Максимальное значение градиента</param>
            <param name="gradGain">Усиление градиента (множитель)</param>
            <param name="L1">L1 регуляризация</param>
            <param name="L2">L2 регуляризация</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.IOptimizer.Reset">
            <summary>
            Сброс параметров обучения
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Nesterov">
            <summary>
            Метод Нестерова
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Nesterov.#ctor">
            <summary>
            Метод Нестерова
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Nesterov.#ctor(System.Single)">
            <summary>
            Метод Нестерова
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Nesterov.UpdateModelParams(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Обновление параметров модели
            </summary>
            <param name="network">Нейронная сеть</param>
            <param name="learningRate">Скорость обучения</param>
            <param name="gradClip">Максимальное значение градиента по модулю</param>
            <param name="kG">Усиление градиента</param>
            <param name="L1">Коэф. L1 регуляризации</param>
            <param name="L2">Коэф. L2 регуляризации</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.Nesterov.Reset">
            <summary>
            Сброс параметров обучения нейронной сети
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Optimizers.RMSProp">
            <summary>
             RMSProp
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Optimizers.RMSProp.DecayRate">
            <summary>
            Momentum
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Optimizers.RMSProp.SmoothEpsilon">
            <summary>
             Коэф. сглаживания
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.RMSProp.UpdateModelParams(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Обновление параметров модели
            </summary>
            <param name="network">Нейронная сеть</param>
            <param name="learningRate">Скорость обучения</param>
            <param name="gradClip">Максимальное значение градиента по модулю</param>
            <param name="kG">Усиление градиента</param>
            <param name="L1">Коэф. L1 регуляризации</param>
            <param name="L2">Коэф. L2 регуляризации</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.RMSProp.Reset">
            <summary>
            Сброс параметров обучения нейронной сети
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Optimizers.SGD">
            <summary>
            Стохастический градиентный спуск (SGD)
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.CoreNNW.Optimizers.SGD.Momentum">
            <summary>
            Momentum
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.SGD.#ctor">
            <summary>
            Стохастический градиентный спуск (SGD), moment = 0
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.SGD.#ctor(System.Single)">
            <summary>
            Стохастический градиентный спуск (SGD)
            </summary>
            <param name="momentum">Moment</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.SGD.Reset">
            <summary>
            Сброс параметров обучения
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.SGD.UpdateModelParams(AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Обновление параметров
            </summary>
            <param name="network">Нейронная сеть</param>
            <param name="learningRate">Скорость обучения</param>
            <param name="gradClip"> Максимальное значение градиента</param>
            <param name="gradGain">Усиление градиента (множитель)</param>
            <param name="L1">L1 регуляризация</param>
            <param name="L2">L2 регуляризация</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Optimizers.SGD.ToString">
            <summary>
            String representation
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Utilities.Metrics">
            <summary>
            Метрики
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Utilities.Metrics.Precision">
            <summary>
            Точность - для оценки классификации 
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Utilities.Metrics.Recall">
            <summary>
            Полнота - для оценки классификации 
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Utilities.Metrics.F1">
            <summary>
            Среднее геометрическое точности и полноты (f1) - для оценки классификации 
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Utilities.Metrics.Accuracy">
            <summary>
            Точность по всем классам (в случае дисбаланса классов малоинформативна) - для оценки классификации 
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Utilities.Metrics.MAE">
            <summary>
            MAE - для оценки регрессии 
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Utilities.Metrics.MAPE">
            <summary>
            MAPE - для оценки регрессии 
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Utilities.Metrics.MSE">
            <summary>
            Средний квадрат ошибки - для оценки регрессии 
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Utilities.Metrics.RMSE">
            <summary>
            Средне квадратичное значение ошибки - для оценки регрессии 
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Utilities.Metrics.RMSLE">
            <summary>
            RMLE (target[i]>-1, output[i]>-1 for all i \in [0; N-1]) - для оценки регрессии 
            </summary>
        </member>
        <member name="F:AI.ML.NeuralNetwork.CoreNNW.Utilities.Metrics.R2">
            <summary>
            Коэффициент корреляции Пирсона в квадрате - для оценки регрессии 
            </summary>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Utilities.NNValueConverter">
            <summary>
            Конвертер из значения нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Utilities.NNValueConverter.NNValueToClass(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Тензор нейронной сети превращает в int (индекс максимального элемента)
            </summary>
            <param name="value">Тензор нейронки</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Utilities.NNValueConverter.NNValuesToClasses(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Массив тензоров нейронной сети превращает в массив int (индекс максимального элемента)
            </summary>
            <param name="nNValues">Массив тензоров </param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Utilities.OverfitDetector">
            <summary>
            Детектор определяющий переобучение нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Utilities.OverfitDetector.IsOverfit(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Проверка на переобучение
            </summary>
            <param name="valLoss">История изменения валидационного лосса</param>
            <param name="trainLoss">История изменения тренировочного лосса</param>
        </member>
        <member name="T:AI.ML.NeuralNetwork.CoreNNW.Utilities.Tester">
            <summary>
            Тестирование нейронной сети
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.CoreNNW.Utilities.Tester.Test(AI.ML.NeuralNetwork.CoreNNW.Models.INNWGraph,AI.ML.NeuralNetwork.CoreNNW.INetwork,System.Collections.Generic.IEnumerable{AI.ML.NeuralNetwork.CoreNNW.DataStructs.DataSequence},AI.ML.NeuralNetwork.CoreNNW.Utilities.Metrics)">
            <summary>
            Тестирование
            </summary>
            <param name="g">Граф вычислений</param>
            <param name="net">Нейронная сеть</param>
            <param name="dataset">Набор данных для теста</param>
            <param name="tests">Тест, который следует выполнить</param>
            <returns></returns>
        </member>
        <member name="T:AI.ML.NeuralNetwork.NeuralNetworkManager">
            <summary>
            Менеджер нейронных сетей, класс для облегчения работы с нейросетями 
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.Model">
            <summary>
            Нейросеть
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.Graph">
            <summary>
            Граф атоматического дифференцирования
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.Optimizer">
            <summary>
            Метод оптимизации
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.Loss">
            <summary>
            Функция ошибки
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.LearningRate">
            <summary>
            Скорость обучения
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.L1Regularization">
            <summary>
            L1 регуляризация
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.L2Regularization">
            <summary>
            L2 регуляризация
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.GradientClipValue">
            <summary>
            Ограничение градиентов
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.ValSplit">
            <summary>
            Какая часть выборки идет на валидацию модели
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.BatchSize">
            <summary>
            Размер батча
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.EpochesToPass">
            <summary>
            Число эпох
            </summary>
        </member>
        <member name="P:AI.ML.NeuralNetwork.NeuralNetworkManager.MinLoss">
            <summary>
            Минимальная ошибка после которой останавливается обучение
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.#ctor">
            <summary>
            Менеджер нейронных сетей, класс для облегчения работы с нейросетями 
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.#ctor(System.String)">
            <summary>
            Менеджер нейронных сетей, класс для облегчения работы с нейросетями 
            </summary>
            <param name="path">Путь до сохраненной нейронной сети</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.#ctor(AI.ML.NeuralNetwork.CoreNNW.NNW)">
            <summary>
            Менеджер нейронных сетей, класс для облегчения работы с нейросетями 
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.Forward(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход нейронной сети
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.Forward(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Прямой проход нейронной сети
            </summary>
            <param name="algebraicStructure"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardVector(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход нейронной сети
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardVector(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Прямой проход нейронной сети
            </summary>
            <param name="algebraicStructure"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardMatrix(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход нейронной сети
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardMatrix(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Прямой проход нейронной сети
            </summary>
            <param name="algebraicStructure"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardTensor(AI.ML.NeuralNetwork.CoreNNW.NNValue)">
            <summary>
            Прямой проход нейронной сети
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardTensor(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Прямой проход нейронной сети
            </summary>
            <param name="algebraicStructure"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardRecurrent(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Прямой проход рекуррентной нейронной сети
            </summary>
            <param name="inputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardRecurrent(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[])">
            <summary>
            Прямой проход рекуррентной нейронной сети
            </summary>
            <param name="inputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardRecurrentVector(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Прямой проход рекуррентной нейронной сети
            </summary>
            <param name="inputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardRecurrentVector(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[])">
            <summary>
            Прямой проход рекуррентной нейронной сети
            </summary>
            <param name="inputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardRecurrentMatrix(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Прямой проход рекуррентной нейронной сети
            </summary>
            <param name="inputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardRecurrentMatrix(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[])">
            <summary>
            Прямой проход рекуррентной нейронной сети
            </summary>
            <param name="inputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardRecurrentTensor(AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Прямой проход рекуррентной нейронной сети
            </summary>
            <param name="inputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.ForwardRecurrentTensor(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[])">
            <summary>
            Прямой проход рекуррентной нейронной сети
            </summary>
            <param name="inputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNet(AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.NNValue[])">
            <summary>
            Обучение нейронной сети
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNetAsync(AI.ML.NeuralNetwork.CoreNNW.NNValue[],AI.ML.NeuralNetwork.CoreNNW.NNValue[],System.Threading.CancellationToken)">
            <summary>
            Обучение нейронной сети
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNet(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[],AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[])">
            <summary>
            Обучение нейронной сети
            </summary>
            <param name="inputs"></param>
            <param name="outputs"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNetAsync(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[],AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}[],System.Threading.CancellationToken)">
            <summary>
            Обучение нерекуррентной сети в асинхронном режиме
            </summary>
            <param name="inputs">Данные входа</param>
            <param name="outputs">Целевые переменные</param>
            <param name="cancellationToken">Окончание обучения </param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNetSignal(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Обучение нейронной сети для работы с сигналами
            </summary>
            <param name="inputs">Массив входных одномерных сигналов</param>
            <param name="outputs">Массив входных одномерных сигналов(Целевые значения)</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNetSignalAsync(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[],System.Threading.CancellationToken)">
            <summary>
            Асинхронное обучение нейронной сети для работы с сигналами
            </summary>
            <param name="inputs">Массив входных одномерных сигналов</param>
            <param name="outputs">Массив входных одномерных сигналов(Целевые значения)</param>
            <param name="cancellationToken">Окончание обучения</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNet(System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[],System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[])">
            <summary>
            Обучение рекуррентной нейронной сети для работы с сигналами
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNetAsync(System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[],System.Collections.Generic.IReadOnlyList{AI.ML.NeuralNetwork.CoreNNW.NNValue}[],System.Threading.CancellationToken)">
            <summary>
            Асинхронное обучение рекуррентной нейронной сети для работы с сигналами
            </summary>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNet(System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}}[],System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}}[])">
            <summary>
            Обучение нейронной сети
            </summary>
            <param name="inputs">Входы</param>
            <param name="outputs">Выходы (целевые значения)</param>
        </member>
        <member name="M:AI.ML.NeuralNetwork.NeuralNetworkManager.TrainNetAsync(System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}}[],System.Collections.Generic.IReadOnlyList{AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double}}[],System.Threading.CancellationToken)">
            <summary>
            Асинхронное обучение рекуррентной нейронной сети для работы с сигналами
            </summary>
        </member>
        <member name="T:AI.ML.Regression.IMultyRegression`1">
            <summary>
            Интерфейс регрессии с многими выходами
            </summary>
        </member>
        <member name="M:AI.ML.Regression.IMultyRegression`1.Train(`0[],AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Обучение регрессии
            </summary>
            <param name="data">Входные векторы(признаки)</param>
            <param name="targets">Выходные векторы(целевые значения)</param>
        </member>
        <member name="M:AI.ML.Regression.IMultyRegression`1.Predict(`0)">
            <summary>
            Предсказание на базе модели
            </summary>
            <param name="data">Вектор признаков</param>
        </member>
        <member name="T:AI.ML.Regression.IRegression">
            <summary>
            Интерфейс регрессии с одним выходом
            </summary>
        </member>
        <member name="M:AI.ML.Regression.IRegression.Train(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучение регрессии
            </summary>
            <param name="data">Входные векторы(признаки)</param>
            <param name="targets">Выходной вектор(целевые значения)</param>
        </member>
        <member name="M:AI.ML.Regression.IRegression.Predict(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Предсказание на базе модели
            </summary>
            <param name="data">Вектор признаков</param>
        </member>
        <member name="T:AI.ML.Regression.KNNCorR">
            <summary>
            Регрессионный метод к ближайших соседей (Корреляционная метрика)
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNCorR.K">
            <summary>
            Число соседей
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNCorR.FixedH">
            <summary>
            Фиксирована ли ширина окна
            </summary>
        </member>
        <member name="F:AI.ML.Regression.KNNCorR.isMutation">
            <summary>
            Инициировать ли мутацию соседей
            </summary>
        </member>
        <member name="F:AI.ML.Regression.KNNCorR.mutCount">
            <summary>
            Число мутирующих соседей
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNCorR.Dist">
            <summary>
            Функция измерения расстояния
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNCorR.Reg">
            <summary>
            Данные регрессии
            </summary>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.#ctor">
            <summary>
            Регрессионный метод к ближайших соседей
            </summary>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.#ctor(System.String)">
            <summary>
            Регрессионный метод к ближайших соседей
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.#ctor(AI.ML.Regression.StructRegres)">
            <summary>
            Регрессия (Метод k-ближ. соседей)
            </summary>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.Save(System.String)">
            <summary>
            Сохранение регрессионной модели
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.Open(System.String)">
            <summary>
            Загрузка регрессионной модели
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.Train(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Добавление данных
            </summary>
            <param name="tData">Вектор центроида</param>
            <param name="targ">Зависимая (целевая) переменная</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.AddData(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Добавление данных для обучения
            </summary>
            <param name="tData">Вектор входных данных</param>
            <param name="targ">Выход</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.Train(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучение регрессии
            </summary>
            <param name="tData">Данные входа (x)</param>
            <param name="targs">Целевые выходы</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.Train(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучение регрессии
            </summary>
            <param name="tData">Данные входа (x)</param>
            <param name="targs">Целевые выходы</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.Predict(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Предсказания моделью
            </summary>
            <param name="inp">Вектор входных данных</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.ImpObj">
            <summary>
            Расчет распределения важности объектов для прогноза
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.OnlyImp(System.Int32)">
            <summary>
            Оставляет только важные для прогнозирования объекты
            </summary>
            <param name="n">Количество объектов, которые необходимо сохранить</param>
        </member>
        <member name="M:AI.ML.Regression.KNNCorR.PredictV(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Предсказание вектора
            </summary>
            <param name="inp">Вектор входных данных</param>
        </member>
        <member name="T:AI.ML.Regression.KnnMultyRegr">
            <summary>
            Регрессия (Метод k-ближ. соседей)
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KnnMultyRegr.K">
            <summary>
            Число соседей
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KnnMultyRegr.H">
            <summary>
            Ширина окна
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KnnMultyRegr.FixedH">
            <summary>
            Фиксирована ли ширина окна
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KnnMultyRegr.IsNadrMethod">
            <summary>
            Используется ли окно Парзена
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KnnMultyRegr.KernelWindow">
            <summary>
            Ядро окна
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KnnMultyRegr.Dist">
            <summary>
            Функция измерения расстояния
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KnnMultyRegr.Reg">
            <summary>
            Набор данных
            </summary>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.#ctor">
            <summary>
            Регрессия (Метод ближайшего соседа)
            </summary>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.RbfK(System.Double)">
            <summary>
            Радиально-базисное ядро для окна Парзена
            </summary>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.#ctor(System.String)">
            <summary>
            Регрессия (Метод ближайшего соседа)
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.#ctor(AI.ML.Regression.StructRegresMulty)">
            <summary>
            Регрессия (Метод ближайшего соседа)
            </summary>
            <param name="reg"> Данные для регрессии</param>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.Save(System.String)">
            <summary>
            Сохранение
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.Open(System.String)">
            <summary>
            Загрузка
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.ToData(System.Int32,System.Double@)">
            <summary>
            Перевод в double
            </summary>
            <param name="i">Индекс</param>
            <param name="R">Вес окна (возвращаемый параметр)</param>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.Train(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Добавление класса
            </summary>
            <param name="tData">Центральный вектор</param>
            <param name="targ">Зависимая переменная</param>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.Train(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Обучение регрессии
            </summary>
            <param name="tData">Входные данные</param>
            <param name="targs">Данные выходов</param>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.Train(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Обучение регрессии
            </summary>
            <param name="tData">Входные данные</param>
            <param name="targs">Данные выходов</param>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.Predict(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прогнозируемый вектор
            </summary>
            <param name="inp">Вектор входных данных</param>
        </member>
        <member name="M:AI.ML.Regression.KnnMultyRegr.PredictV(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Предсказание
            </summary>
            <param name="inp">Вектор входа</param>
        </member>
        <member name="T:AI.ML.Regression.KNNReg">
            <summary>
            Регрессия (Метод k-ближ. соседей)
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNReg.K">
            <summary>
            Число соседей
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNReg.H">
            <summary>
            Ширина окна
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNReg.FixedH">
            <summary>
            Фиксирована ли ширина окна
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNReg.IsNadrMethod">
            <summary>
            Используется ли окно Парзена
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNReg.KernelWindow">
            <summary>
            Ядро окна
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNReg.Dist">
            <summary>
            Функция измерения расстояния
            </summary>
        </member>
        <member name="P:AI.ML.Regression.KNNReg.Reg">
            <summary>
            Данные для регрессии
            </summary>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.#ctor">
            <summary>
            Регрессия (Метод k-ближ. соседей)
            </summary>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.RbfK(System.Double)">
            <summary>
            Радиально-базисное ядро
            </summary>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.#ctor(System.String)">
            <summary>
            Регрессия (Метод k-ближ. соседей)
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.#ctor(AI.ML.Regression.StructRegres)">
            <summary>
            Регрессия (Метод k-ближ. соседей)
            </summary>
            <param name="reg">Набор данных</param>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.Save(System.String)">
            <summary>
            Сохранение
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.Open(System.String)">
            <summary>
            Загрузка
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.ToData(System.Int32,System.Double@)">
            <summary>
            Перевод в double
            </summary>
            <param name="i">Индекс</param>
            <param name="R">Вес окна</param>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.Rang(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Ранжирование
            </summary>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.Train(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Добавление класса
            </summary>
            <param name="tData">Центральный вектор</param>
            <param name="targ">Зависимая переменная</param>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.Train(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучение регрессии
            </summary>
            <param name="tData">Входные данные</param>
            <param name="targs">Данные выходов</param>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.Train(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучение регрессии
            </summary>
            <param name="tData">Входные данные</param>
            <param name="targs">Данные выходов</param>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.Predict(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Возращает вектор, его длинна - Number of classes, на номере нужного класса стоит 1
            </summary>
            <param name="inp">Вектор входных данных</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.Regression.KNNReg.PredictV(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прогноз вектора значений
            </summary>
            <param name="inp">Вектор входных данных</param>
        </member>
        <member name="T:AI.ML.Regression.LinearRegressionModel">
            <summary>
            Модель для линейной регрессии хранит k и b   
            f(x) = k*x+b;
            </summary>
        </member>
        <member name="P:AI.ML.Regression.LinearRegressionModel.k">
            <summary>
            Тангенс угла наклона
            </summary>
        </member>
        <member name="P:AI.ML.Regression.LinearRegressionModel.b">
            <summary>
            Смещение относительно (0;0)
            </summary>
        </member>
        <member name="T:AI.ML.Regression.LinearRegression">
            <summary>
            Линейная регрессия
            </summary>
        </member>
        <member name="P:AI.ML.Regression.LinearRegression.Lrm">
            <summary>
            Параметры линейной регрессии
            </summary>
        </member>
        <member name="M:AI.ML.Regression.LinearRegression.#ctor(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучающая выборка
            </summary>
            <param name="X">Вектор X(независимая переменная)</param>
            <param name="Y">Вектор Y(зависимая переменная)</param>
        </member>
        <member name="M:AI.ML.Regression.LinearRegression.ToString">
            <summary>
            Вывод в строку
            </summary>
            <returns>Строка типа: f(x) = k*x+(b)</returns>
        </member>
        <member name="M:AI.ML.Regression.LinearRegression.Predict(System.Double)">
            <summary>
            Прогнозирование с помощью линейной модели
            </summary>
            <param name="x">Независимая переменная</param>
            <returns>Зависимая переменная</returns>
        </member>
        <member name="M:AI.ML.Regression.LinearRegression.Predict(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прогнозирование с помощью линейной модели
            </summary>
            <param name="X">Вектор независимых переменных</param>
            <returns>Вектор зависимых переменных</returns>
        </member>
        <member name="T:AI.ML.Regression.MultipleRegression">
            <summary>
            Множественная линейная регрессия
            </summary>
        </member>
        <member name="P:AI.ML.Regression.MultipleRegression.Parammetrs">
            <summary>
            Параметры модели
            </summary>
        </member>
        <member name="M:AI.ML.Regression.MultipleRegression.#ctor(System.Boolean)">
            <summary>
            Множественная линейная регрессия
            </summary>
            <param name="isScale">Стоит ли применить масштабирование к данным</param>
        </member>
        <member name="M:AI.ML.Regression.MultipleRegression.#ctor(System.String)">
            <summary>
            Множественная линейная регрессия
            </summary>
            <param name="path">Путь до модели</param>
        </member>
        <member name="M:AI.ML.Regression.MultipleRegression.Predict(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прогноз
            </summary>
            <param name="vect">Вектор входных данных</param>
            <returns>Выход</returns>
        </member>
        <member name="M:AI.ML.Regression.MultipleRegression.Predict(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Прогноз
            </summary>
            <param name="inp">Вектора входа</param>
            <returns>Вектор выхода</returns>
        </member>
        <member name="M:AI.ML.Regression.MultipleRegression.SaveModel(System.String)">
            <summary>
            Сохранение модели
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Regression.MultipleRegression.LoadModel(System.String)">
            <summary>
            Загрузка модели
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.ML.Regression.MultipleRegression.Train(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучение множественной регрессии
            </summary>
            <param name="data">Признаки</param>
            <param name="targets">Целевые выходы</param>
        </member>
        <member name="M:AI.ML.Regression.MultipleRegression.TrainGrad(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Обучение градиентным спуском (Эластик)
            </summary>
        </member>
        <member name="M:AI.ML.Regression.MultipleRegression.DataPrepaire(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Пред. обработка
            </summary>
            <param name="data"></param>
            <param name="targets"></param>
        </member>
        <member name="T:AI.ML.Regression.PolynomialRegression">
            <summary>
            Полиномиальная регрессия
            </summary>
        </member>
        <member name="M:AI.ML.Regression.PolynomialRegression.#ctor(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Полиномиальная регрессия
            </summary>
        </member>
        <member name="M:AI.ML.Regression.PolynomialRegression.Predict(System.Double)">
            <summary>
            Прогноз
            </summary>
            <param name="inp">Значение незав. переменной</param>
        </member>
        <member name="M:AI.ML.Regression.PolynomialRegression.Predict(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Прогноз
            </summary>
            <param name="vect">Значения незав. переменных</param>
        </member>
        <member name="T:AI.ML.Regression.StructRegr">
            <summary>
             Набор данных регрессии item
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegr.Target">
            <summary>
            Значение целевой переменной
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegr.Features">
            <summary>
            Вектор признаков
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegr.R">
            <summary>
            Расстояние
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegr.Params">
            <summary>
            Дополнительные опции
            </summary>
        </member>
        <member name="T:AI.ML.Regression.StructRegres">
            <summary>
            Набор данных регрессии
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegres.Classes">
            <summary>
            Данные
            </summary>
        </member>
        <member name="T:AI.ML.Regression.StructRegresMulty">
            <summary>
            Набор данных для регрессионных алгоритмов
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegresMulty.Classes">
            <summary>
            Данные
            </summary>
        </member>
        <member name="T:AI.ML.Regression.StructRegrMulty">
            <summary>
            Структура для хранения регрессионных данных
            </summary>
        </member>
        <member name="F:AI.ML.Regression.StructRegrMulty._targ">
            <summary>
            Целевой вектор
            </summary>
        </member>
        <member name="F:AI.ML.Regression.StructRegrMulty._centGiperSfer">
            <summary>
            Координата центра гиперсферы
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegrMulty.Targets">
            <summary>
            Целевой вектор
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegrMulty.CentGiperSfer">
            <summary>
            Координата центра гиперсферы
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegrMulty.R">
            <summary>
            Расстояние
            </summary>
        </member>
        <member name="P:AI.ML.Regression.StructRegrMulty.Params">
            <summary>
            Дополнительные опции
            </summary>
        </member>
        <member name="T:AI.ML.SeqAnalyze.ClassifierS2V">
            <summary>
            Классификатор на базе алгоритма S2V
            </summary>
        </member>
        <member name="P:AI.ML.SeqAnalyze.ClassifierS2V.Treshold">
            <summary>
            Порог принадлежности к классу для многоклассового классификатора (по умолчанию 0.5)
            </summary>
        </member>
        <member name="P:AI.ML.SeqAnalyze.ClassifierS2V.Item(System.Int32[])">
            <summary>
            Добавление/просмотр правила
            </summary>
            <param name="ints">Вход</param>
            <returns></returns>
        </member>
        <member name="P:AI.ML.SeqAnalyze.ClassifierS2V.CountRules">
            <summary>
            Число правил
            </summary>
        </member>
        <member name="P:AI.ML.SeqAnalyze.ClassifierS2V.States2Vector">
            <summary>
            Регрессор
            </summary>
        </member>
        <member name="F:AI.ML.SeqAnalyze.ClassifierS2V.NumCl">
            <summary>
            Число классов
            </summary>
        </member>
        <member name="M:AI.ML.SeqAnalyze.ClassifierS2V.#ctor(System.Int32,System.Int32,System.Double,AI.ML.SeqAnalyze.S2VClType)">
            <summary>
            Классификатор на базе алгоритма S2V
            </summary>
            <param name="nCl">Число классов</param>
            <param name="max_n_gramm">Максимальная длинна n-граммы</param>
            <param name="top_p">Значение до которого должна дойти интегральное значение важности после сортировки</param>
            <param name="s2VClType">Тип классификатора, одноклассовый/многоклассовый</param>
        </member>
        <member name="M:AI.ML.SeqAnalyze.ClassifierS2V.Train(System.Collections.Generic.IEnumerable{System.Int32[]},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Обучение классификатора
            </summary>
        </member>
        <member name="M:AI.ML.SeqAnalyze.ClassifierS2V.CreateClassifierS2V(System.Collections.Generic.List{System.Int32[]}[],System.Int32,System.Double,System.Double,AI.ML.SeqAnalyze.S2VClType)">
            <summary>
            Создание классификатора 
            (cls - массив правил, каждый элемент массива содержит список индикаторов класса, 
            число классов равно длинне массива)
            </summary>
            <param name="cls">массив правил, каждый элемент массива содержит список индикаторов класса, 
            число классов равно длинне массива</param>
            <param name="max_n_gramm">Максимальная длинна n-граммы</param>
            <param name="membership_cl_coef"></param>
            <param name="top_p">Значение до которого должна дойти интегральное значение важности после сортировки</param>
            <param name="s2VClType">Тип классификатора, одноклассовый/многоклассовый</param>
        </member>
        <member name="M:AI.ML.SeqAnalyze.ClassifierS2V.ClassifyProbVector(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Получение вектора вероятностей принадлежности к классу
            </summary>
            <param name="input">Вход (Последовательность состояний)</param>
        </member>
        <member name="M:AI.ML.SeqAnalyze.ClassifierS2V.Classify(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Классификация, -1 означает, что запрос аномальный и классификатор не может его классифицировать 
            </summary>
            <param name="input">Вход (Последовательность состояний)</param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.SeqAnalyze.ClassifierS2V.AddRuleCl(System.Int32[],System.Int32,System.Double)">
            <summary>
            Добавление правила для классификатора
            </summary>
            <param name="states"></param>
            <param name="cl_mark"></param>
            <param name="gain"></param>
        </member>
        <member name="T:AI.ML.SeqAnalyze.S2VClType">
            <summary>
            Тип классификатора s2v
            </summary>
        </member>
        <member name="F:AI.ML.SeqAnalyze.S2VClType.OneClassPredict">
            <summary>
            Предсказание одного класса по входу
            </summary>
        </member>
        <member name="F:AI.ML.SeqAnalyze.S2VClType.MultyClassPredict">
            <summary>
            Предсказание многих классов по входу
            </summary>
        </member>
        <member name="T:AI.ML.SeqAnalyze.States2Vector">
            <summary>
            Регрессор, превращающий состояния в вектор
            </summary>
        </member>
        <member name="P:AI.ML.SeqAnalyze.States2Vector.CountRules">
            <summary>
            Число правил
            </summary>
        </member>
        <member name="P:AI.ML.SeqAnalyze.States2Vector.VectorDimention">
            <summary>
            Размерность вектора ассоциаций
            </summary>
        </member>
        <member name="P:AI.ML.SeqAnalyze.States2Vector.Item(System.Int32[])">
            <summary>
            Установка / чтение правила
            </summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="F:AI.ML.SeqAnalyze.States2Vector.MaxNGramm">
            <summary>
            Максимальный размер контекста
            </summary>
        </member>
        <member name="F:AI.ML.SeqAnalyze.States2Vector.TopP">
            <summary>
            Значение до которого должна дойти интегральное значение важности после сортировки
            </summary>
        </member>
        <member name="P:AI.ML.SeqAnalyze.States2Vector.Activation">
            <summary>
            Активационная функция
            </summary>
        </member>
        <member name="M:AI.ML.SeqAnalyze.States2Vector.#ctor(System.Int32,System.Double)">
            <summary>
            Регрессор, превращающий состояния в вектор
            </summary>
        </member>
        <member name="M:AI.ML.SeqAnalyze.States2Vector.Predict(System.Int32[])">
            <summary>
            Прогнозирование вектора по массиву состояний
            </summary>
            <param name="data">Масив состояний</param>
        </member>
        <member name="M:AI.ML.SeqAnalyze.States2Vector.PredictWithListCount(System.Int32[])">
            <summary>
            Прогнозирование вектора по массиву состояний
            </summary>
            <param name="inp">Масив состояний</param>
        </member>
        <member name="M:AI.ML.SeqAnalyze.States2Vector.Train(System.Int32[][],AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Обучение
            </summary>
            <param name="data">Массивы состояний</param>
            <param name="y">Целевые векторы</param>
        </member>
        <member name="M:AI.ML.SeqAnalyze.States2Vector.CreateS2V(System.Collections.Generic.List{System.Tuple{System.Int32[],AI.DataStructs.Algebraic.Vector}},System.Int32,System.Double)">
            <summary>
            Создает регрессор на базе пользовательских правил (списка)
            </summary>
            <param name="data">Список кортежей (n-грамма, вектор)</param>
            <param name="max_n_gramm">Максимальная длинна n-граммы</param>
            <param name="top_p">Значение до которого должна дойти интегральное значение важности после сортировки</param>
        </member>
        <member name="M:AI.ML.SeqAnalyze.States2Vector.Tuning(System.Int32[][],AI.DataStructs.Algebraic.Vector[],System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Тюнинг (градиентный спуск)
            </summary>
        </member>
        <member name="T:AI.ML.SeqAnalyze.ValueDictRegressor">
            <summary>
            Значение для словаря регрессий
            </summary>
        </member>
        <member name="F:AI.ML.SeqAnalyze.ValueDictRegressor.TargetValue">
            <summary>
            Целевое значение
            </summary>
        </member>
        <member name="F:AI.ML.SeqAnalyze.ValueDictRegressor.TargetValueGrad">
            <summary>
            Градиент целевого значения
            </summary>
        </member>
        <member name="F:AI.ML.SeqAnalyze.ValueDictRegressor.CountActiv">
            <summary>
            Число активаций
            </summary>
        </member>
        <member name="F:AI.ML.SeqAnalyze.ValueDictRegressor.NGram">
            <summary>
            Размер n-граммы
            </summary>
        </member>
        <member name="P:AI.ML.SeqAnalyze.ValueDictRegressor.Importance">
            <summary>
            Коэф. важности
            </summary>
        </member>
        <member name="M:AI.ML.SeqAnalyze.ValueDictRegressor.GetImportance(System.Double)">
            <summary>
            Получить важность n-граммы по компонентам 
            </summary>
        </member>
        <member name="M:AI.ML.SeqAnalyze.ValueDictRegressor.GetVector">
            <summary>
            Получить вектор умноженный на важность элемента
            </summary>
        </member>
        <member name="M:AI.ML.SeqAnalyze.ValueDictRegressor.GetKImportance">
            <summary>
            Получить коэффициент важности
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.ML.SeqAnalyze.ValueDictRegressor.AddGrad(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Добавить градиент
            </summary>
        </member>
        <member name="M:AI.ML.SeqAnalyze.ValueDictRegressor.Upd(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Обновление вектора
            </summary>
            <param name="lr">Скорость обучения</param>
            <param name="l1">L1</param>
            <param name="l2">L2</param>
            <param name="momentum">Момент</param>
        </member>
        <member name="T:AI.ML.SeqPredict.AR">
            <summary>
            Авторегрессионная модель
            </summary>
        </member>
        <member name="M:AI.ML.SeqPredict.AR.#ctor(System.Int32)">
            <summary>
            Авторегрессионная модель
            </summary>
            <param name="windowLenght">Окно предыдущих состояний</param>
        </member>
        <member name="M:AI.ML.SeqPredict.AR.Predict(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Прогноз на n шагов вперед
            </summary>
            <param name="data"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:AI.ML.SeqPredict.AR.PredictTrain(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Метод не реализован
            </summary>
            <param name="data"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:AI.ML.SeqPredict.AR.Train(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучение на базе временного ряда
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:AI.ML.SeqPredict.GRUPredict">
            <summary>
            Предсказание на базе GRU сети
            </summary>
        </member>
        <member name="M:AI.ML.SeqPredict.GRUPredict.#ctor(System.Int32)">
            <summary>
            Предсказание на базе GRU сети
            </summary>
        </member>
        <member name="M:AI.ML.SeqPredict.GRUPredict.Predict(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Предсказать следующие n значений
            </summary>
            <param name="data">Начальные данные</param>
            <param name="n">Насколько шагов предсказать</param>
        </member>
        <member name="M:AI.ML.SeqPredict.GRUPredict.PredictTrain(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Метод не реализован
            </summary>
        </member>
        <member name="M:AI.ML.SeqPredict.GRUPredict.Train(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучение
            </summary>
        </member>
        <member name="T:AI.ML.SeqPredict.ISeqPredict">
            <summary>
            Прогнозирование последовательностей
            </summary>
        </member>
        <member name="M:AI.ML.SeqPredict.ISeqPredict.Train(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучение
            </summary>
            <param name="data">Данные (обучающая последовательность)</param>
        </member>
        <member name="M:AI.ML.SeqPredict.ISeqPredict.Predict(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Прогноз
            </summary>
            <param name="data">Начало последовательности</param>
            <param name="n">На сколько шагов продолжить</param>
        </member>
        <member name="M:AI.ML.SeqPredict.ISeqPredict.PredictTrain(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучение и прогноз на 1
            </summary>
        </member>
        <member name="T:AI.ML.SeqPredict.SeqPrediction">
            <summary>
            Прогнозирование последовательности
            </summary>
        </member>
        <member name="F:AI.ML.SeqPredict.SeqPrediction.regressor">
            <summary>
            Регрессионный алгоритм
            </summary>
        </member>
        <member name="F:AI.ML.SeqPredict.SeqPrediction.window">
            <summary>
            Размер окна
            </summary>
        </member>
        <member name="M:AI.ML.SeqPredict.SeqPrediction.#ctor(AI.ML.Regression.IRegression,System.Int32)">
            <summary>
            Прогнозирование последовательности
            </summary>
            <param name="reg">Алгоритм прогнозирования</param>
            <param name="w">Размер окна</param>
        </member>
        <member name="M:AI.ML.SeqPredict.SeqPrediction.#ctor">
            <summary>
            Прогнозирование последовательности
            </summary>
        </member>
        <member name="M:AI.ML.SeqPredict.SeqPrediction.Train(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Обучение модели
            </summary>
            <param name="data">Последовательность</param>
        </member>
        <member name="M:AI.ML.SeqPredict.SeqPrediction.Predict(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Прогноз
            </summary>
            <param name="data">Известная часть последовательности</param>
            <param name="n">Сколько шагов предсказать</param>
        </member>
        <member name="M:AI.ML.SeqPredict.SeqPrediction.PredictTrain(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Метод не реализован
            </summary>
            <param name="data"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="T:AI.NLP.BoWModel">
            <summary>
            Bag-of-Words (Мешок слов)
            </summary>
        </member>
        <member name="F:AI.NLP.BoWModel.vector">
            <summary>
            Вектор, в котором все 0, кроме позиции слова
            </summary>
        </member>
        <member name="P:AI.NLP.BoWModel.isStop">
            <summary>
            Анализировать ли стоп слова
            </summary>
        </member>
        <member name="P:AI.NLP.BoWModel.isDig">
            <summary>
            Пропускать ли числа
            </summary>
        </member>
        <member name="F:AI.NLP.BoWModel.Len">
            <summary>
            Размерность вектора/словаря
            </summary>
        </member>
        <member name="P:AI.NLP.BoWModel.IsNormalise">
            <summary>
            Нужно ли нормализовать вектор
            </summary>
        </member>
        <member name="M:AI.NLP.BoWModel.#ctor(System.String)">
            <summary>
             Bag-of-Words (Мешок слов)
            </summary>
        </member>
        <member name="M:AI.NLP.BoWModel.GetVector(System.String)">
            <summary>
            Вычислить вектор из текста
            </summary>
            <param name="text">Текст</param>
        </member>
        <member name="M:AI.NLP.BoWModel.ModelGen(System.String,System.String,System.Boolean)">
            <summary>
            Генерация/создание модели
            </summary>
        </member>
        <member name="T:AI.NLP.ProbabilityDictionary">
            <summary>
            Вероятностный словарь
            </summary>
        </member>
        <member name="P:AI.NLP.ProbabilityDictionary.pDictionary">
            <summary>
            Вероятностный словарь
            </summary>
        </member>
        <member name="P:AI.NLP.ProbabilityDictionary.IsDigitDel">
            <summary>
            Удалять ли цифры
            </summary>
        </member>
        <member name="P:AI.NLP.ProbabilityDictionary.IsStem">
            <summary>
            Использовать ли стеммер
            </summary>
        </member>
        <member name="F:AI.NLP.ProbabilityDictionary.stop">
            <summary>
            Слова не несущие смысла
            </summary>
        </member>
        <member name="P:AI.NLP.ProbabilityDictionary.StopWords">
            <summary>
            Слова не несущие смысла при стат. анализе
            </summary>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionary.#ctor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Вероятностный словарь
            </summary>
            <param name="isStopDel">Удалять ли стоп-слова</param>
            <param name="isDigitDel">Удалять ли числа</param>
            <param name="isStem">Делать ли стеммеризацию</param>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionary.Run(System.String)">
            <summary>
            Данные вероятностного словаря
            </summary>
            <param name="text">Текст</param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionary.GetWordsRunAll(System.String)">
            <summary>
            Запуск генерации словаря с выводом всех слов
            </summary>
            <param name="text">Текст для генерации</param>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionary.GetWordsRun(System.String,System.Int32)">
            <summary>
            Запуск генерации словаря с выводом определенного числа слов
            </summary>
            <param name="text">Текст для генерации</param>
            <param name="numW">Число слов</param>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionary.DigialPredickat(System.String)">
            <summary>
            Возвращает true если в сторке есть цифры
            </summary>
            <param name="str">Строка</param>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionary.Analis">
            <summary>
            Анализ текста
            </summary>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionary.ToString(System.Int32)">
            <summary>
            Переводит частотный словарь в строку
            </summary>
            <param name="index">До какого индекса</param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionary.GetWords(System.String)">
            <summary>
            Получение слов
            </summary>
            <param name="text">Текст</param>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionary.GetWords(System.String,System.Boolean)">
            <summary>
            Получение слов
            </summary>
            <param name="text"></param>
            <param name="IsStem"></param>
            <returns></returns>
        </member>
        <member name="T:AI.NLP.ProbabilityDictionaryData`1">
            <summary>
            Данные вероятностного словаря
            </summary>
        </member>
        <member name="P:AI.NLP.ProbabilityDictionaryData`1.Word">
            <summary>
            Слово
            </summary>
        </member>
        <member name="P:AI.NLP.ProbabilityDictionaryData`1.Probability">
            <summary>
            Вероятность встретить это слово
            </summary>
        </member>
        <member name="T:AI.NLP.ProbabilityDictionaryHash">
            <summary>
            Вероятностный словарь
            </summary>
        </member>
        <member name="P:AI.NLP.ProbabilityDictionaryHash.pDictionary">
            <summary>
            Вероятностный словарь 
            </summary>
        </member>
        <member name="P:AI.NLP.ProbabilityDictionaryHash.IsStem">
            <summary>
            Применять ли стеммер
            </summary>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionaryHash.#ctor(System.Boolean)">
            <summary>
            Вероятностный словарь
            </summary>
            <param name="isStem">Делать ли стеммеризацию</param>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionaryHash.Run(System.String)">
            <summary>
            Данные вероятностного словаря
            </summary>
            <param name="text">Текст</param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.ProbabilityDictionaryHash.Analis">
            <summary>
            Анализ текста
            </summary>
        </member>
        <member name="T:AI.NLP.Stemmers.StemmerRus">
            <summary>
            Стемер русского языка
            </summary>
        </member>
        <member name="M:AI.NLP.Stemmers.StemmerRus.TransformingWordsArray(System.String[])">
            <summary>
            Стемминг массива слов
            </summary>
            <param name="words">Массив слов</param>
        </member>
        <member name="M:AI.NLP.Stemmers.StemmerRus.TransformingWord(System.String)">
            <summary>
            стемминг
            </summary>
            <param name="word">слово</param>
            <returns>приставка+корень</returns>
        </member>
        <member name="T:AI.NLP.Stemmers.WordEndingsRU">
            <summary>
            Получение окончаний слов (для русских слов)
            </summary>
        </member>
        <member name="M:AI.NLP.Stemmers.WordEndingsRU.Endings(System.String)">
            <summary>
            Получение окончаний слов
            </summary>
            <param name="text">Текст входа</param>
        </member>
        <member name="T:AI.NLP.StringExtention">
            <summary>
            Методы расширения для строк
            </summary>
        </member>
        <member name="M:AI.NLP.StringExtention.Concatinate(System.String[],System.String)">
            <summary>
            Объединение строк
            </summary>
            <param name="strings"></param>
            <param name="sep"></param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.StringExtention.Split(System.String,System.String)">
            <summary>
            Разделение по строке
            </summary>
            <param name="text">Текст</param>
            <param name="strSpliter">Строка-разделитель</param>
        </member>
        <member name="M:AI.NLP.StringExtention.Remove(System.String,System.String[])">
            <summary>
            Удаление символов
            </summary>
            <param name="text">Текст</param>
            <param name="delStrs">Подстроки, которые будут удалены</param>
        </member>
        <member name="M:AI.NLP.StringExtention.ReReplace(System.String,System.String,System.String)">
            <summary>
            Замена с использованием регулярных выражений
            </summary>
            <param name="text">Текст</param>
            <param name="pattern">Патерн для замены</param>
            <param name="new_string">На что заменить патерн</param>
        </member>
        <member name="M:AI.NLP.StringExtention.ReTransform(System.String,System.String,System.Func{System.String,System.String})">
            <summary>
            Преобразование с использованием регулярных выражений
            </summary>
            <param name="text">Текст</param>
            <param name="pattern">Патерн для преобразования</param>
            <param name="transformer">Функция преобразования текста совпадающего с патерном</param>
        </member>
        <member name="M:AI.NLP.StringExtention.Diff(System.String,System.String)">
            <summary>
            Находит разность между строками, например "привет" - "ве" = "прит"
            </summary>
            <param name="text1">Строка из которой вычитаем</param>
            <param name="text2">Строка которую вычитаем</param>
        </member>
        <member name="T:AI.NLP.TextStandard">
            <summary>
            Стандартизация текста
            </summary>
        </member>
        <member name="M:AI.NLP.TextStandard.Normalize(System.String,System.Boolean)">
            <summary>
             Стандартизация входного текста
            </summary>
            <param name="input">Входной текст</param>
            <param name="isLower">Переводить ли текст в нижний регистр</param>
        </member>
        <member name="M:AI.NLP.TextStandard.OnlyCharsAndDigit(System.String,System.Boolean)">
            <summary>
            В запросе остаются только буквы, цифры и знаки пробела
            </summary>
            <param name="input">Входной текст</param>
            <param name="isLower">Переводить ли в нижний регистр</param>
        </member>
        <member name="M:AI.NLP.TextStandard.OnlyChars(System.String,System.Boolean)">
            <summary>
            В запросе остаются только буквы и знаки пробела
            </summary>
            <param name="input">Входной текст</param>
            <param name="isLower">Переводить ли в нижний регистр</param>
        </member>
        <member name="M:AI.NLP.TextStandard.OnlyRusChars(System.String)">
            <summary>
            В запросе остаются только буквы и знаки пробела
            </summary>
            <param name="input">Входной текст</param>
        </member>
        <member name="M:AI.NLP.TextStandard.NoDoubleWord(System.String)">
            <summary>
            Удаляет повторы слов
            </summary>
            <param name="input">Входной текст</param>
        </member>
        <member name="M:AI.NLP.TextStandard.GetWords(System.String,System.Func{System.String,System.String},System.Func{System.String,System.String},System.Func{System.String,System.Boolean})">
            <summary>
            Выдает множество слов
            </summary>
            <param name="input">Входной текст</param>
            <param name="preprocessingString">Обработчик текста</param>
            <param name="preprocessingWord">Обработчик слов</param>
            <param name="appendWord">Добавалять ли слово в список</param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.TextStandard.SimTextDice(System.Collections.Generic.HashSet{System.String},System.Collections.Generic.HashSet{System.String})">
            <summary>
            Сходство текстов на базе множеств
            </summary>
        </member>
        <member name="M:AI.NLP.TextStandard.SimTextDiceAsymmetric(System.Collections.Generic.HashSet{System.String},System.Collections.Generic.HashSet{System.String})">
            <summary>
            Асимvетричное сходство текстов на базе множеств
            </summary>
        </member>
        <member name="T:AI.NLP.TextSummarization">
            <summary>
            Суммаризация
            </summary>
        </member>
        <member name="M:AI.NLP.TextSummarization.#ctor">
            <summary>
            Суммаризация
            </summary>
        </member>
        <member name="M:AI.NLP.TextSummarization.Summarization(System.String,System.Int32)">
            <summary>
            Суммаризация текста
            </summary>
            <param name="text">Текст</param>
            <param name="num">Кол-во предложений для описания текста</param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.TextSummarization.GetSeqs(System.String)">
            <summary>
            Выдает предложения
            </summary>
            <param name="text">Текст</param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.TextSummarization.Step1(System.String)">
            <summary>
            Первый шаг алгоритма (составление вероятностных словарей)
            </summary>
            <param name="text">Текст</param>
        </member>
        <member name="T:AI.NLP.DataSummText">
            <summary>
            Данные предложений
            </summary>
        </member>
        <member name="P:AI.NLP.DataSummText.W">
            <summary>
            Вес
            </summary>
        </member>
        <member name="P:AI.NLP.DataSummText.Str">
            <summary>
            Содержание
            </summary>
        </member>
        <member name="M:AI.NLP.DataSummText.#ctor(System.String,System.Double)">
            <summary>
            Данные предложений
            </summary>
            <param name="str">строка</param>
            <param name="w">вес</param>
        </member>
        <member name="T:AI.NLP.TextTokenizer">
            <summary>
            Токенизатор (ТoDo: удалить и перенести функционал в токенизатор AI.DataPrepaire)
            </summary>
        </member>
        <member name="P:AI.NLP.TextTokenizer.IsLower">
            <summary>
            Whether to convert text to lowercase
            </summary>
        </member>
        <member name="P:AI.NLP.TextTokenizer.IsStem">
            <summary>
            Whether to stem the text
            </summary>
        </member>
        <member name="P:AI.NLP.TextTokenizer.DelChars">
            <summary>
            Deleted characters
            </summary>
        </member>
        <member name="P:AI.NLP.TextTokenizer.Separaters">
            <summary>
            Characters or strings to separate words
            </summary>
        </member>
        <member name="P:AI.NLP.TextTokenizer.Count">
            <summary>
            Вектор выхода dimention
            </summary>
        </member>
        <member name="P:AI.NLP.TextTokenizer.WordCount">
            <summary>
            Number of words in the frequency dictionary
            </summary>
        </member>
        <member name="F:AI.NLP.TextTokenizer.Words">
            <summary>
            Слова
            </summary>
        </member>
        <member name="M:AI.NLP.TextTokenizer.#ctor(System.Boolean,System.Boolean,System.Char[],System.String[])">
            <summary>
            Class for tokenizing text
            </summary>
            <param name="isLower">Whether to convert text to lowercase</param>
            <param name="isStem">Whether to stem the text</param>
            <param name="deleted">Deleted characters (default [',' ';' '*' '?' '!' '.'])  </param>
            <param name="separaters">Characters or strings to separate words (default ["\t" " " "\n"])</param>
        </member>
        <member name="M:AI.NLP.TextTokenizer.Train(System.String)">
            <summary>
            Обучение модели
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:AI.NLP.TextTokenizer.GetSeq2Tokens(System.String)">
            <summary>
            Токенизация последовательности
            </summary>
            <param name="seq"></param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.TextTokenizer.GetWord2Token(System.String)">
            <summary>
            Токенизация слова
            </summary>
        </member>
        <member name="M:AI.NLP.TextTokenizer.GetWord2OneHot(System.String)">
            <summary>
            Токенизация слова с помощью one-hot
            </summary>
        </member>
        <member name="M:AI.NLP.TextTokenizer.GetDimWithUnKnowWord">
            <summary>
            Получить размерность с неизвестными словами
            </summary>
            <returns></returns>
        </member>
        <member name="T:AI.NLP.TFIDF">
            <summary>
            TF-IDF
            </summary>
        </member>
        <member name="M:AI.NLP.TFIDF.#ctor(System.String[])">
            <summary>
            TF-IDF
            </summary>
            <param name="docs">Массив документов</param>
        </member>
        <member name="M:AI.NLP.TFIDF.TFWord(System.String,System.Int32)">
            <summary>
            tf
            </summary>
            <param name="t"></param>
            <param name="dIndex"></param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.TFIDF.IDFWord(System.String)">
            <summary>
            Idf
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.TFIDF.TF_IDF(System.String,System.Int32)">
            <summary>
            TF-IDF
            </summary>
            <param name="t"></param>
            <param name="dIndex"></param>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.TFIDF.TF_IDF_Str(System.String,System.Int32)">
            <summary>
            Принадлежность строки к определенному документу
            </summary>
            <param name="str">Строка</param>
            <param name="dIndex">Индекс документа</param>
        </member>
        <member name="M:AI.NLP.TFIDF.Search(System.String)">
            <summary>
            Поиск документа
            </summary>
            <param name="req">Запрос</param>
        </member>
        <member name="T:AI.NLP.TFIDFDictionary">
            <summary>
            TF-IDF словарь
            </summary>
        </member>
        <member name="P:AI.NLP.TFIDFDictionary.TfIdf">
            <summary>
            TF-IDF алгоритм
            </summary>
        </member>
        <member name="M:AI.NLP.TFIDFDictionary.#ctor(System.String)">
            <summary>
            Создание словаря tf-idf
            </summary>
            <param name="pathToDir">Путь до директории с документами</param>
        </member>
        <member name="M:AI.NLP.TFIDFDictionary.ToVect(System.String)">
            <summary>
            Преобразование слова в вектор
            </summary>
            <param name="word">Слово</param>
        </member>
        <member name="M:AI.NLP.TFIDFDictionary.Sim(System.String,System.String)">
            <summary>
            Расчет близости слов
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.NLP.TFIDFDictionary.VectorDictionary">
            <summary>
            Составление векторного словаря
            </summary>
        </member>
        <member name="T:AI.Sound">
            <summary>
            Description of Sound.
            </summary>
        </member>
        <member name="F:AI.Sound.chunkID">
            <summary>
            ID
            </summary>
        </member>
        <member name="F:AI.Sound.fileSize">
            <summary>
            Размер файла
            </summary>
        </member>
        <member name="F:AI.Sound.riffType">
            <summary>
            Тип
            </summary>
        </member>
        <member name="F:AI.Sound.fmtID">
            <summary>
            
            </summary>
        </member>
        <member name="F:AI.Sound.fmtSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:AI.Sound.fmtCode">
            <summary>
            
            </summary>
        </member>
        <member name="F:AI.Sound.channels">
            <summary>
            Каналы (число)
            </summary>
        </member>
        <member name="F:AI.Sound.sampleRate">
            <summary>
            Частота дискретизации
            </summary>
        </member>
        <member name="F:AI.Sound.fmtAvgBPS">
            <summary>
            средний битрейт
            </summary>
        </member>
        <member name="F:AI.Sound.fmtBlockAlign">
            <summary>
            
            </summary>
        </member>
        <member name="F:AI.Sound.bitDepth">
            <summary>
            
            </summary>
        </member>
        <member name="F:AI.Sound.dataID">
            <summary>
            
            </summary>
        </member>
        <member name="F:AI.Sound.dataSize">
            <summary>
            
            </summary>
        </member>
        <member name="M:AI.Sound.#ctor">
            <summary>
            Звук
            </summary>
        </member>
        <member name="M:AI.Sound.SoundLoad(System.String)">
            <summary>
            Загрузка звука
            </summary>
            <param name="path">Путь до файла</param>
            <returns></returns>
        </member>
        <member name="M:AI.Sound.SaveVector(System.String,AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Сохранениеvector как звука
            </summary>
            <param name="path">Путь до файла</param>
            <param name="vector"></param>
            <param name="fd"></param>
        </member>
        <member name="T:AI.Statistics.Distributions.IDistribution">
            <summary>
            Интерфейс вероятностных распределений
            </summary>
        </member>
        <member name="M:AI.Statistics.Distributions.IDistribution.CulcProb(AI.DataStructs.Algebraic.Vector,System.Collections.Generic.Dictionary{System.String,AI.DataStructs.Algebraic.Vector})">
            <summary>
            Рассчет функции распределения
            </summary>
            <param name="x">Вход</param>
            <param name="param_dist">Параметры распределения</param>
        </member>
        <member name="M:AI.Statistics.Distributions.IDistribution.CulcProb(System.Double,System.Collections.Generic.Dictionary{System.String,System.Double})">
            <summary>
            Рассчет функции распределения
            </summary>
            <param name="x">Вход</param>
            <param name="param_dist">Параметры распределения</param>
        </member>
        <member name="M:AI.Statistics.Distributions.IDistribution.CulcLogProb(System.Double,System.Collections.Generic.Dictionary{System.String,System.Double})">
            <summary>
            Рассчет логарифма функции распределения
            </summary>
            <param name="x">Вход</param>
            <param name="param_dist">Параметры распределения</param>
        </member>
        <member name="M:AI.Statistics.Distributions.IDistribution.CulcLogProb(AI.DataStructs.Algebraic.Vector,System.Collections.Generic.Dictionary{System.String,AI.DataStructs.Algebraic.Vector})">
            <summary>
            Рассчет логарифма функции распределения
            </summary>
            <param name="x">Вход</param>
            <param name="param_dist">Параметры распределения</param>
        </member>
        <member name="T:AI.Statistics.Distributions.IDistributionWithoutParams">
            <summary>
            Интерфейс функции распределения без параметров
            </summary>
        </member>
        <member name="M:AI.Statistics.Distributions.IDistributionWithoutParams.CulcProb(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Рассчет функции распределения
            </summary>
            <param name="x">Вход</param>
        </member>
        <member name="M:AI.Statistics.Distributions.IDistributionWithoutParams.CulcProb(System.Double)">
            <summary>
            Рассчет функции распределения
            </summary>
            <param name="x">Вход</param>
        </member>
        <member name="M:AI.Statistics.Distributions.IDistributionWithoutParams.CulcLogProb(System.Double)">
            <summary>
            Рассчет логарифма функции распределения
            </summary>
            <param name="x">Вход</param>
        </member>
        <member name="M:AI.Statistics.Distributions.IDistributionWithoutParams.CulcLogProb(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Рассчет логарифма функции распределения
            </summary>
            <param name="x">Вход</param>
        </member>
        <member name="T:AI.Statistics.Distributions.NonCorrelatedGaussian">
            <summary>
            Некоррелированный гауссов процесс
            </summary>
        </member>
        <member name="M:AI.Statistics.Distributions.NonCorrelatedGaussian.CulcLogProb(System.Double,System.Collections.Generic.Dictionary{System.String,System.Double})">
            <summary>
            Рассчет логарифма функции распределения
            </summary>
            <param name="x">Вход</param>
            <param name="param_dist">Параметры распределения, ключевые параметры: "std", "mean"</param>
        </member>
        <member name="M:AI.Statistics.Distributions.NonCorrelatedGaussian.CulcLogProb(AI.DataStructs.Algebraic.Vector,System.Collections.Generic.Dictionary{System.String,AI.DataStructs.Algebraic.Vector})">
            <summary>
            Рассчет логарифма функции распределения
            </summary>
            <param name="x">Вход</param>
            <param name="param_dist">Параметры распределения, ключевые параметры: "std", "mean"</param>
        </member>
        <member name="M:AI.Statistics.Distributions.NonCorrelatedGaussian.CulcProb(AI.DataStructs.Algebraic.Vector,System.Collections.Generic.Dictionary{System.String,AI.DataStructs.Algebraic.Vector})">
            <summary>
            Рассчет функции распределения
            </summary>
            <param name="x">Вход</param>
            <param name="param_dist">Параметры распределения, ключевые параметры: "std", "mean"</param>
        </member>
        <member name="M:AI.Statistics.Distributions.NonCorrelatedGaussian.CulcProb(System.Double,System.Collections.Generic.Dictionary{System.String,System.Double})">
            <summary>
            Рассчет функции распределения
            </summary>
            <param name="x">Вход</param>
            <param name="param_dist">Параметры распределения, ключевые параметры: "std", "mean"</param>
        </member>
        <member name="T:AI.Statistics.FormStatistcs">
            <summary>
            Статистики зависимые только от формы функции
            </summary>
        </member>
        <member name="M:AI.Statistics.FormStatistcs.CrestFactor(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Коэффициент формы (пик-фактор)
            </summary>
            <param name="vector">Вектор входных данных</param>
        </member>
        <member name="T:AI.Statistics.Histogramm">
            <summary>
            Структура гистограммы
            </summary>
        </member>
        <member name="M:AI.Statistics.Histogramm.#ctor">
            <summary>
             Структура гистограммы
            </summary>
        </member>
        <member name="M:AI.Statistics.Histogramm.#ctor(System.Int32)">
            <summary>
             Структура гистограммы
            </summary>
            <param name="n">Число разрядов</param>
        </member>
        <member name="P:AI.Statistics.Histogramm.X">
            <summary>
            Значения столбцов
            </summary>
        </member>
        <member name="P:AI.Statistics.Histogramm.Y">
            <summary>
            Высоты столбцов
            </summary>
        </member>
        <member name="P:AI.Statistics.Histogramm.Name">
            <summary>
            Название гистограммы
            </summary>
        </member>
        <member name="P:AI.Statistics.Histogramm.Info">
            <summary>
            Описание гистограммы
            </summary>
        </member>
        <member name="P:AI.Statistics.Histogramm.XLable">
            <summary>
            Название оси "Х" гистограммы
            </summary>
        </member>
        <member name="P:AI.Statistics.Histogramm.YLables">
            <summary>
            Название оси "У" гистограммы
            </summary>
        </member>
        <member name="M:AI.Statistics.Histogramm.Save(System.String)">
            <summary>
            Сохранение гистограммы
            </summary>
            <param name="path">Путь до файла</param>
        </member>
        <member name="M:AI.Statistics.Histogramm.IntegralValueH(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Сумма значений по строкам
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.Histogramm.IntegralValueHMean(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Средние знач. яркости
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.Histogramm.IntegralValueW(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Сумма значений по строкам
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.Histogramm.IntegralValueWMean(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Средние знач. яркости
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.Histogramm.HarAnd(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Получение характеристики яркости на базе умножения(Эквивалент "И")
            </summary>
            <param name="matrix">Входная матрица</param>
        </member>
        <member name="M:AI.Statistics.Histogramm.HarSumm(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Получение характеристики яркости на базе сложения
            </summary>
            <param name="matrix">Входная матрица</param>
        </member>
        <member name="M:AI.Statistics.Histogramm.HarNorm(AI.DataStructs.Algebraic.Matrix)">
            <summary>
            Получение характеристики яркости на базе вычисления модуля
            </summary>
            <param name="matrix">Входная матрица</param>
        </member>
        <member name="M:AI.Statistics.Histogramm.Open(System.String)">
            <summary>
            Загрузка гистограммы
            </summary>
            <param name="path">Путь до файла</param>	
        </member>
        <member name="T:AI.Statistics.MixtureModeling.Bayesian">
            <summary>
            Элементы (инструменты) для байесовского вывода
            </summary>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.Bayesian.#ctor(System.Collections.Generic.IEnumerable{AI.Statistics.Distributions.IDistributionWithoutParams},AI.DataStructs.Algebraic.Vector)">
            <summary>
            Элементы (инструменты) для байесовского вывода
            </summary>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.Bayesian.GetIndicators(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Получение индикаторов
            </summary>
            <param name="inps">Входы (одномерное распределение)</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.Bayesian.GetIndicators(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Возвращает индикаторы
            </summary>
            <param name="inps">Входы (многомерное распределение)</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.Bayesian.LogArgmax1D(System.Double)">
            <summary>
            Одномерная плотность вероятности
            </summary>
            <param name="inp">Вход</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.Bayesian.LogArgmaxND(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Многомерная плотность вероятности
            </summary>
            <param name="inp">Вход</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.Bayesian.CalcAposteori(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Рассчет апостериорной вероятности
            </summary>
            <param name="conditionalProbabilities">Вектор условных вероятностей</param>
            <param name="apriori">Вектор априорных вероятностей</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.Bayesian.LogArgmax1D(System.Double,AI.Statistics.Distributions.IDistribution,System.Collections.Generic.Dictionary{System.String,System.Double}[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Моделирует argmax{log[f(x|Theta)] + log(w)}
            </summary>
            <param name="inp"></param>
            <param name="distribution">Родительская функция распределения</param>
            <param name="param_dist">Параметры распределения</param>
            <param name="apriori">Априорное расп</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.Bayesian.LogArgmaxND(AI.DataStructs.Algebraic.Vector,AI.Statistics.Distributions.IDistribution,System.Collections.Generic.Dictionary{System.String,AI.DataStructs.Algebraic.Vector}[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Многомерная плотность вероятности 
            </summary>
            <param name="inp">Вход</param>
            <param name="distribution">Распределения</param>
            <param name="param_dist">Параметры распределений</param>
            <param name="apriori">Вектор априорных вероятностей</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.Bayesian.GetIndicators(AI.DataStructs.Algebraic.Vector,AI.Statistics.Distributions.IDistribution,System.Collections.Generic.Dictionary{System.String,System.Double}[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Расчет индикаторов
            </summary>
            <param name="inps"></param>
            <param name="distribution"></param>
            <param name="param_dist"></param>
            <param name="apriori"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.Bayesian.GetIndicators(AI.DataStructs.Algebraic.Vector[],AI.Statistics.Distributions.IDistribution,System.Collections.Generic.Dictionary{System.String,AI.DataStructs.Algebraic.Vector}[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Возвращает индикаторы
            </summary>
            <param name="inps">Входы</param>
            <param name="distribution">Распределения</param>
            <param name="param_dist">Параметры распределений</param>
            <param name="apriori">Вектор априорных вероятностей</param>
        </member>
        <member name="T:AI.Statistics.MixtureModeling.MixtureModel">
            <summary>
            Модель смеси распределений
            </summary>
        </member>
        <member name="P:AI.Statistics.MixtureModeling.MixtureModel.IsOneD">
            <summary>
            Одномерная ли смесь
            </summary>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.MixtureModel.#ctor(AI.Statistics.Distributions.IDistribution,System.Collections.Generic.IEnumerable{System.Collections.Generic.Dictionary{System.String,System.Double}},AI.DataStructs.Algebraic.Vector)">
            <summary>
            Модель смеси распределений
            </summary>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.MixtureModel.#ctor(AI.Statistics.Distributions.IDistribution,System.Collections.Generic.IEnumerable{System.Collections.Generic.Dictionary{System.String,AI.DataStructs.Algebraic.Vector}},AI.DataStructs.Algebraic.Vector)">
            <summary>
            Модель смеси распределений
            </summary>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.MixtureModel.CulcLogProb(System.Double)">
            <summary>
            Рассчет логарифма функции распределения
            </summary>
            <param name="x">Вход</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.MixtureModel.CulcLogProb(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Рассчет логарифма функции распределения
            </summary>
            <param name="x">Вход</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.MixtureModel.CulcProb(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Рассчет функции распределения
            </summary>
            <param name="x">Вход</param>
        </member>
        <member name="M:AI.Statistics.MixtureModeling.MixtureModel.CulcProb(System.Double)">
            <summary>
            Рассчет функции распределения
            </summary>
            <param name="x">Вход</param>
        </member>
        <member name="T:AI.Statistics.MonteCarlo.Integration">
            <summary>
            Расчет интеграла методом Монте-Карло
            </summary>
        </member>
        <member name="M:AI.Statistics.MonteCarlo.Integration.CalcIntegral1D(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Взятие одномерного интеграла
            </summary>
            <param name="func">Подъинтегральная функция</param>
            <param name="a">Нижний предел интегрирования</param>
            <param name="b">Верхний предел интегрирования</param>
            <param name="n">Число точек для расчета интеграла</param>
            <param name="iter">Число итераций расчета</param>
            <param name="seed">Зерно</param>
        </member>
        <member name="T:AI.Statistics.MonteCarlo.MCMC_1D">
            <summary>
            Метод Монте-Карло Марковских Цепей (для одномерной плотности)
            </summary>
        </member>
        <member name="P:AI.Statistics.MonteCarlo.MCMC_1D.StepsTrPro">
            <summary>
            Длительность переходного процесса в отсчетах
            </summary>
        </member>
        <member name="P:AI.Statistics.MonteCarlo.MCMC_1D.Seed">
            <summary>
            Сид генератора случ. чисел
            </summary>
        </member>
        <member name="P:AI.Statistics.MonteCarlo.MCMC_1D.UseSeed">
            <summary>
            Использовать ли сид
            </summary>
        </member>
        <member name="M:AI.Statistics.MonteCarlo.MCMC_1D.#ctor(System.Func{System.Double,System.Double},System.Int32)">
            <summary>
            Метод Монте-Карло Марковских Цепей (для одномерной плотности)
            </summary>
            <param name="distr_log">Логарифм ненормированной функции распределения</param>
            <param name="stepsTrPro">Длительность переходного процесса в отсчетах</param>
        </member>
        <member name="M:AI.Statistics.MonteCarlo.MCMC_1D.AcceptProb(System.Double,System.Double)">
            <summary>
            Вероятность принятия значения (перех. ядро цепи Маркова)
            </summary>
            <param name="old_value">Старое значение</param>
            <param name="new_value">Новое значение</param>
        </member>
        <member name="M:AI.Statistics.MonteCarlo.MCMC_1D.Generate(System.Int32,System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            Генерция выборки
            </summary>
            <param name="len">Длинна выборки</param>
            <param name="start">Начальное значение</param>
            <param name="decorelate">Премешивать ли выборку</param>
            <param name="min">Минимальное значение</param>
            <param name="max">Максимальное значение</param>
        </member>
        <member name="T:AI.Statistics.MonteCarlo.SimulatedAnnealing">
            <summary>
            Метод имитации отжига
            </summary>
        </member>
        <member name="P:AI.Statistics.MonteCarlo.SimulatedAnnealing.LastLoss">
            <summary>
            Предыдущая ошибка
            </summary>
        </member>
        <member name="P:AI.Statistics.MonteCarlo.SimulatedAnnealing.T">
            <summary>
            Температура
            </summary>
        </member>
        <member name="P:AI.Statistics.MonteCarlo.SimulatedAnnealing.Kt">
            <summary>
            Коэффициент уменьшения температуры
            </summary>
        </member>
        <member name="M:AI.Statistics.MonteCarlo.SimulatedAnnealing.#ctor(System.Double,System.Int32)">
            <summary>
            Метод имитации отжига
            </summary>
        </member>
        <member name="M:AI.Statistics.MonteCarlo.SimulatedAnnealing.IsAccept(System.Double)">
            <summary>
            Принимаем ли новое решение
            </summary>
        </member>
        <member name="T:AI.Statistics.Quantile">
            <summary>
            Квантили
            </summary>
        </member>
        <member name="P:AI.Statistics.Quantile.SortVec">
            <summary>
            Сортированный вектор
            </summary>
        </member>
        <member name="M:AI.Statistics.Quantile.#ctor(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Квантили
            </summary>
            <param name="structureDouble">Алгебраическая структура</param>
        </member>
        <member name="M:AI.Statistics.Quantile.GetQuantile(System.Double)">
            <summary>
            Расчет нужного квантиля (0-1)
            </summary>
            <param name="q">Квантиль</param>
        </member>
        <member name="M:AI.Statistics.Quantile.FastQuantile(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},System.Double)">
            <summary>
            Быстрый расчет квантиля, не требует сортировки всего массива, работает через QSearch
            </summary>
            <param name="structure">Входные данные</param>
            <param name="q">Квантиль</param>
            <returns></returns>
        </member>
        <member name="T:AI.Statistics.QuickSelection`1">
            <summary>
            Методы быстрого поиска, за линейное время
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:AI.Statistics.QuickSelection`1.Selection(`0[],System.Int32)">
            <summary>
            Выбор на основе быстрой сортировки(находит порядковую статистику за линейное время)
            </summary>
        </member>
        <member name="T:AI.Statistics.RandomItemSelection">
            <summary>
            Случайный выбор
            </summary>
        </member>
        <member name="M:AI.Statistics.RandomItemSelection.GetElement``1(AI.DataStructs.Algebraic.Vector,``0[],System.Random)">
            <summary>
            Случайный выбор элемента по заданному распределению
            </summary>
            <param name="distributionFunction">Дискретная функция распределния</param>
            <param name="arrayStates">Массив элементов</param>
            <param name="random">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.Statistics.RandomItemSelection.GetIndex(AI.DataStructs.Algebraic.Vector,System.Random,System.Double)">
            <summary>
            Случайный выбор индекса по заданному распределению
            </summary>
        </member>
        <member name="T:AI.Statistics.Statistic">
            <summary>
            Класс содержит методы для статистического анализа. А также генераторы псевдослучайных чисел.
            </summary>
        </member>
        <member name="P:AI.Statistics.Statistic.STD">
            <summary>
            Оценка средне-квадратичного отклонение (СКО)
            </summary>
        </member>
        <member name="P:AI.Statistics.Statistic.MinValue">
            <summary>
             Минимальное значение
            </summary>
        </member>
        <member name="P:AI.Statistics.Statistic.MaxValue">
            <summary>
             Максимальное значение
            </summary>
        </member>
        <member name="P:AI.Statistics.Statistic.Variance">
            <summary>
            Оценка дисперсии
            </summary>
        </member>
        <member name="P:AI.Statistics.Statistic.Expected">
            <summary>
            Оценка мат. ожидания
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.#ctor(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Создает объект класса Statistic, принимает вектор входных значений случайной величины
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.UniformDistribution(System.Int32)">
            <summary>
            Генератор псевдо-случайных чисел с равномерным распределением
            </summary>
            <param name="n">Длинна вектора</param>
            <returns>Возвращает вектор случайных чисел</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.UniformDistribution(System.Int32,System.Random)">
            <summary>
            Генератор псевдо-случайных чисел с равномерным распределением
            </summary>
            <param name="n">Длинна вектора</param>
            <param name="random">Генератор псевдо-случайных чисел</param>
            <returns>Возвращает вектор случайных чисел</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.Gauss(System.Random)">
            <summary>
            Гауссовское распределение
            </summary>
            <returns>Возвращает норм. распред величину СКО = 1, M = 0</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.Gauss2(System.Random,System.Int32)">
            <summary>
            Гауссовское распределение
            </summary>
            <returns>Возвращает норм. распред величину СКО = 1, M = 0</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNormP(System.Int32,System.Int32)">
            <summary>
            Генератор псевдо-случайных чисел с нормальным распределением
            </summary>
            <param name="n">Длинна вектора</param>
            <param name="iter">Число итераций</param>
            <returns>Возвращает вектор случайных чисел</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNormP(System.Int32,System.Random,System.Int32)">
            <summary>
            Генератор псевдо-случайных чисел с нормальным распределением
            </summary>
            <param name="n">Длинна вектора</param>
            <param name="random">Генератор псевдо-случайных чисел</param>
            <param name="iter">Число итераций</param>
            <returns>Возвращает вектор случайных чисел</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNorm(System.Int32)">
            <summary>
            Генератор псевдо-случайных чисел с нормальным распределением
            </summary>
            <param name="n">Длинна вектора</param>
            <returns>Возвращает вектор случайных чисел</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNorm(System.Int32,System.Random)">
            <summary>
            Генератор псевдо-случайных чисел с нормальным распределением
            </summary>
            <param name="n">Длинна вектора</param>
            <param name="rnd">Генератор псевдо-случайных чисел</param>
            <returns>Возвращает вектор случайных чисел</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.UniformDistribution(System.Int32,System.Int32)">
            <summary>
            Cоздает матрицу с равномерно распределенными значениями
            размерности m на n
            </summary>
            <param name="m">Количество строк</param>
            <param name="n">Количество столбцов</param>
        </member>
        <member name="M:AI.Statistics.Statistic.UniformDistribution(System.Int32,System.Int32,System.Random)">
            <summary>
            Cоздает матрицу с равномерно распределенными значениями
            размерности m на n
            </summary>
            <param name="m">Количество строк</param>
            <param name="n">Количество столбцов</param>
            <param name="random">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.Statistics.Statistic.UniformDistribution(System.Int32,System.Int32,System.Int32)">
            <summary>
            Тензор
            </summary>
            <param name="h"> Высота</param>
            <param name="w">Ширина</param>
            <param name="d">Глубина</param>
        </member>
        <member name="M:AI.Statistics.Statistic.UniformDistribution(System.Int32,System.Int32,System.Int32,System.Random)">
            <summary>
            Тензор
            </summary>
            <param name="h"> Высота</param>
            <param name="w">Ширина</param>
            <param name="d">Глубина</param>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNorm(System.Int32,System.Int32,System.Int32)">
            <summary>
            Тензор
            </summary>
            <param name="h"> Высота</param>
            <param name="w">Ширина</param>
            <param name="d">Глубина</param>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNorm(System.Int32,System.Int32,System.Random)">
            <summary>
            Cоздает матрицу с нормально распределенными значениями
            размерности m на n
            </summary>
            <param name="m">Количество строк</param>
            <param name="n">Количество столбцов</param>
            <param name="rn">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNorm(System.Int32,System.Int32,System.Int32,System.Random)">
            <summary>
            Тензор
            </summary>
            <param name="h"> Высота</param>
            <param name="w">Ширина</param>
            <param name="d">Глубина</param>
            <param name="random">Генератор псевдо-случайных чисел</param>
        </member>
        <member name="M:AI.Statistics.Statistic.MaximalValue(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
             Максимальное значение
            </summary>
            <param name="array">Значения</param>
        </member>
        <member name="M:AI.Statistics.Statistic.MinimalValue(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
             Минимальное значение
            </summary>
            <param name="array">Значения</param>
        </member>
        <member name="M:AI.Statistics.Statistic.ExpectedValue">
            <summary>
            Оценка математического ожидания
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.ExpectedValue(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Оценка математического ожидания
            </summary>
            <param name="array"> Значения </param>
        </member>
        <member name="M:AI.Statistics.Statistic.ExpectedValueAbs(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
             Оценка математического ожидания от модуля случайной величины
            </summary>
            <param name="array"> Значения </param>
        </member>
        <member name="M:AI.Statistics.Statistic.ExpectedValueNotCheckNaN(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Estimation of mathematical expectation
            </summary>
            <param name="array"> Значения </param>
        </member>
        <member name="M:AI.Statistics.Statistic.ExpectedValueAbsNotCheckNaN(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Оценка математического ожидания от модуля случайной величины
            </summary>
            <param name="array"> Вектор значений </param>
        </member>
        <member name="M:AI.Statistics.Statistic.СalcVariance">
            <summary>
            Оценка дисперсии
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.Std">
            <summary>
            СКО
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.СalcVariance(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Оценка дисперсии
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.CalcStd(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Расчет оценки СКО
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNorm">
            <summary>
            Генератор псевдо-случайных чисел с нормальным распределением
            </summary>
            <returns>Возвращает случайные числа</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNorm(System.Int32,System.Int32)">
            <summary>
            Cоздает матрицу с нормально распределенными значениями
            размерности m на n
            </summary>
            <param name="m">Количество строк</param>
            <param name="n">Количество столбцов</param>
        </member>
        <member name="M:AI.Statistics.Statistic.UniformDistribution(System.Int16)">
            <summary>
            Cоздает матрицу с равномерно распределенными значениями
            размерности n на n
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.RandNorm(System.Int16)">
            <summary>
            Cоздает матрицу с нормально распределенными значениями
            размерности n на n
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.Histogramm(System.Int32)">
            <summary>
            Строит гистограмму
            </summary>
            <param name="n">Количество разрядов гистограммы</param>
            <returns>возращает вектор длинной nRazr, содержащий отсчеты для построения гистограммы</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.InitialMoment(System.Int32)">
            <summary>
            Начальный момент
            </summary>
            <param name="n">Номер начального момента</param>
        </member>
        <member name="M:AI.Statistics.Statistic.CentralMoment(System.Int32)">
            <summary>
            Центральный момент
            </summary>
            <param name="n">Номер центрального момента</param>
        </member>
        <member name="M:AI.Statistics.Statistic.Asymmetry">
            <summary>
            Ассиметрия распределения
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.Excess">
            <summary>
            Крутизна распределения (CM(4)/D^2 - 3)
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.Cov(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Ковариация (корреляционный момент, линейная зависимость) двух векторов
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.CorrelationCoefficient(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Коэффициент корреляции Пирсона
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.CorrelationCoefficient(AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double},AI.DataStructs.Algebraic.IAlgebraicStructure{System.Double})">
            <summary>
            Коэффициент корреляции Пирсона
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.MeanVector(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Vector})">
            <summary>
            Усреднение по выборке(ансамблю)
            </summary>
            <param name="vectors">Выборка</param>
            <returns>Средний вектор</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.MeanGeom(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Среднее геометрическое 
            </summary>
        </member>
        <member name="M:AI.Statistics.Statistic.MeanGarmonic(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Среднее гармоническое
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.Statistic.RMS(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Среднeквадратичное значение
            </summary>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.Statistic.EnsembleDispersion(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Vector})">
            <summary>
            Дисперсия по ансамлю
            </summary>
            <param name="vectors">Ансамбль векторов</param>
        </member>
        <member name="M:AI.Statistics.Statistic.EnsembleDispersion(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            Дисперсия по ансамлю(использует предрассчитанный вектор средних)
            </summary>
            <param name="ensemble">Ансамбль векторов</param>
            <param name="mean">Вектор средних</param>
        </member>
        <member name="M:AI.Statistics.Statistic.EnsembleStd(System.Collections.Generic.IEnumerable{AI.DataStructs.Algebraic.Vector})">
            <summary>
            СКО по ансамлю
            </summary>
            <param name="ensemble">Ансамбль векторов</param>
        </member>
        <member name="M:AI.Statistics.Statistic.EnsembleStd(AI.DataStructs.Algebraic.Vector[],AI.DataStructs.Algebraic.Vector)">
            <summary>
            СКО по ансамлю
            </summary>
            <param name="ensemble">Ансамбль векторов</param>
            <param name="mean">Предю рассчитанный вектор средних</param>
        </member>
        <member name="M:AI.Statistics.Statistic.MaxEns(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Максимум по ансамлю
            </summary>
            <param name="ensemble">Ансамбль векторов</param>
        </member>
        <member name="M:AI.Statistics.Statistic.MaxEnergeVector(AI.DataStructs.Algebraic.Vector[])">
            <summary>
            Возвращает вектор с максимальной энергией
            </summary>
            <param name="ens">Ансамбль векторов</param>
            <returns>Вектор с максимальной энергией</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.SimpleMeanFreq(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Средняя частота (не нормированная, зависит от кол-ва точек)
            </summary>
            <param name="signal">Сигнал</param>
            <returns></returns>
        </member>
        <member name="M:AI.Statistics.Statistic.MeanFreq(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Средняя частота сигнала
            </summary>
            <param name="signal">Сигнал</param>
            <param name="fd">Частота дискретизации</param>
            <returns>Средняя частота [Гц]</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.DivFreq(AI.DataStructs.Algebraic.Vector)">
            <summary>
            Изменение частоты
            </summary>
            <param name="signal">Сигнал</param>
            <returns>Дивиация средней частоты</returns>
        </member>
        <member name="M:AI.Statistics.Statistic.MeanStep(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Средний шаг, насколько x[i] отличается от x[i + 1] в среднем
            </summary>
            <param name="vector">Последовательность</param>
            <param name="eps">Минимально-возможный шаг</param>
        </member>
        <member name="M:AI.Statistics.Statistic.MeanStep2(AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Средний шаг в последовательности (Max(vector) - Min(vector))/N + eps
            </summary>
            <param name="vector">Последовательность</param>
            <param name="eps">Минимально-возможный шаг</param>
        </member>
        <member name="T:AI.Convolution">
            <summary>
            A class that implements the folding of sequences
            </summary>
        </member>
        <member name="M:AI.Convolution.DirectConvolution(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Свертка
            </summary>
            <param name="signal">Сигнал</param>
            <param name="Ht">Импульсивный ответ</param>
        </member>
        <member name="M:AI.Convolution.ConvolutionNormal(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector)">
            <summary>
            Свертка
            </summary>
            <param name="signal">Сигнал</param>
            <param name="Ht">Импульсивный ответ</param>
        </member>
        <member name="M:AI.Convolution.DirectConvolution(AI.DataStructs.Algebraic.Vector,AI.DataStructs.Algebraic.Vector,System.Double)">
            <summary>
            Свертка
            </summary>
            <param name="signal">Сигнал</param>
            <param name="ht">Импульсивный ответ</param>
            <param name="fd">Частота дискретизации</param>
        </member>
        <member name="M:AI.Convolution.StWithHt(AI.DataStructs.Algebraic.Vector,System.Int32)">
            <summary>
            Создание нового опорного вектора сигнала
            </summary>
            <param name="st">Сигнал</param>
            <param name="htLen">Длинна импульсной характеристики</param>
        </member>
        <member name="M:AI.Convolution.StWithHt(AI.DataStructs.WithComplexElements.ComplexVector,System.Int32)">
            <summary>
            Создание нового опорного вектора сигнала
            </summary>
            <param name="st">Сигнал</param>
            <param name="htLen">Длинна импульсной характеристики</param>
        </member>
        <member name="M:AI.Convolution.DirectConvolution(AI.DataStructs.WithComplexElements.ComplexVector,AI.DataStructs.WithComplexElements.ComplexVector)">
            <summary>
            Прямая свертка комплексного вектора
            </summary>
        </member>
    </members>
</doc>
